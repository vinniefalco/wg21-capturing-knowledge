# Evaluation: P1255R11 — A view of 0 or 1 elements: views::maybe

**Paper**: P1255R11  
**Authors**: Steve Downey  
**Evaluated Against**: Captured knowledge from Howard Hinnant and Matheus Izvekov  
**Date**: January 2026

---

## Executive Summary

P1255R11 proposes two range adaptors: `views::maybe` (an owning view of 0 or 1 elements) and `views::nullable` (adapting nullable types like `std::optional` or pointers into ranges). When evaluated against the principles extracted from experienced WG21 participants, the proposal raises several concerns—particularly around the **standardization threshold** (does this make the impossible possible, or merely the easy easier?) and **evidence of field experience** from independent users.

The proposal has strengths: it's been through 11 revisions, has a reference implementation, and addresses a real pattern in functional programming. However, the core value proposition—replacing `if (opt) { use(*opt); }` with `for (auto&& x : views::nullable(opt)) { use(x); }`—represents syntactic preference rather than enabling previously impossible functionality.

**Overall Assessment**: The proposal would benefit from stronger evidence of independent field experience and a more compelling argument for why the status quo is insufficient. Several principles suggest this may be "making the easy easier" rather than clearing the standardization threshold.

---

## Principle-by-Principle Evaluation

### Howard Hinnant Principles

#### HH-P1: Make the Impossible Possible, Not the Easy Easier

> *"I prefer to make what was previously impossible or impractical, possible. Or if not that, to make something that is very difficult, to make it easy. But making the easy easier, I find very uninteresting and not worthwhile to standardize."*

**Assessment**: ⚠️ **CONCERN**

The paper's "Before/After" table (Section 1) is revealing:

| Before | After |
|--------|-------|
| `if (opt) { use(*opt); }` | `for (auto&& opt : views::nullable(opt)) { use(opt); }` |

The "before" code is not difficult. It's a pattern every C++ programmer knows. The "after" code is not obviously better—it's longer and introduces an unfamiliar abstraction.

The paper acknowledges this weakness: *"This is of small value in small examples in contrast to testing the nullable in an if statement."* The argument for larger bodies—where the dereference is "far away from the test"—is valid but doesn't rise to "impossible" or even "hard."

The Pythagorean triples example (Section 3) is more compelling, showing list comprehension style programming. However, this pattern is already achievable with existing tools (`transform`, `filter`, `join`). The paper demonstrates this explicitly in the "Before" column—the code works today, it's just slightly more verbose.

**Red Flags Triggered**:
- ✓ Proposal can be trivially implemented by users in a few lines
- ✓ Functionality is already achievable with existing standard components
- ✓ Primary benefit is "slightly nicer syntax"

---

#### HH-P2: Require Positive Field Experience Before Standardization

> *"Nothing should be standardized unless it has some positive field experience under its belt... field experience will bang out use cases."*

**Assessment**: ⚠️ **CONCERN**

The paper mentions a reference implementation (Section 8):
> *"A publicly available implementation at https://github.com/steve-downey/view_maybe"*

However, there is no evidence presented of:
- Users outside the author's organization adopting this implementation
- Positive testimonials from independent users
- Production usage demonstrating the design works in real-world conditions
- Feedback that informed design iterations

The implementation exists, but existence is not field experience. As Howard explicitly states: *"I should quit asking 'Has it been implemented?' The correct question is: What has been the field experience?"*

**Red Flags Triggered**:
- ✓ Implementation exists but no evidence of external adoption
- ✓ "Field experience" potentially limited to proposer's team
- ✓ Theoretical benefits without demonstrated practical value

---

#### HH-P8: Every Paper Must Answer "What Problem?" and "What's the Alternative?"

> *"What problem am I solving and if this paper's not accepted, how does the programmer solve this problem without this solution."*

**Assessment**: ⚠️ **CONCERN**

**What problem?** The paper identifies:
1. Safety: Nullable dereference can be far from the engagement check
2. Ergonomics: List comprehension patterns require manual filter/transform chains
3. Composability: Unifying `single` and `empty` views for pipeline operations

**What's the alternative?**
1. Safety: `if (opt) { use(*opt); }` — trivial, universally understood
2. Ergonomics: `transform` + `filter` + `join` — works today (paper demonstrates this)
3. Composability: Write a helper function — maybe 10 lines of code

The alternatives are not hard. The paper's motivation section (Section 2) implicitly acknowledges this by focusing on ergonomic improvements rather than enabling new capabilities.

**Red Flags Triggered**:
- ✓ Existing solution is nearly as good
- ✓ "Convenience" is the primary value proposition

---

#### HH-P7: Offer Both Checked and Unchecked API Layers

> *"It's often good to have like a two-layer API, a low level layer that is unchecked. And then a safer layer, checked layer built on top of that."*

**Assessment**: ✅ **ALIGNED**

The paper addresses this well. The design is inherently safe—all operations on `maybe_view` and `nullable_view` are safe. As stated in Section 5.3:
> *"This means that all of the operations on maybe_view and nullable_view are directly safe."*

Unsafe operations (like dereferencing `data()` without null check) look visibly unsafe in code, which aligns with the principle of making danger visible.

---

#### HH-P9: Dangerous Tools Are Fine If Used Correctly

> *"Any good tool is dangerous... they can really help in the kitchen or they can chop your fingers off. You just have to know how to use them."*

**Assessment**: ✅ **ALIGNED**

The paper doesn't over-constrain the API to prevent misuse. It provides powerful tools (`data()`, reference semantics) while making the safe path the default. This aligns with C++'s philosophy of trusting programmers.

---

#### HH-P10: Standardization Solves Cross-Platform Availability

> *"If you can grab it from the library, that means you don't have to install a third party library."*

**Assessment**: ⚠️ **WEAK JUSTIFICATION**

The paper doesn't argue strongly for why this needs to be in the standard rather than a third-party library. `views::maybe` is small, self-contained, and has no platform-specific behavior. Users who want this pattern could easily add a small header to their project.

The argument for standardization would be stronger if there were evidence that:
- Multiple incompatible implementations exist in the ecosystem
- Users are blocked by lack of a standard solution
- The vocabulary type argument (see below) is compelling

---

### Matheus Izvekov Principles

#### MI-P9: Vocabulary Types Justify Standardization

> *"They should be more about the idea of building a vocabulary, right?... STD vector being in the standard library helped because like people are still gonna want to implement their own vectors because they're going to be specialized... but if they don't have any reason to be different, you know, from STD vector in some aspect... they shouldn't be."*

**Assessment**: ⚠️ **CONCERN**

Section 5.1 argues for `maybe_view` as a vocabulary type:
> *"Explicit types are much easier for compilers to generate good code... The more limited interface of maybe_view seems to, in practice, make intention clearer to the compiler."*

However, the vocabulary type argument is weak:
- Will libraries actually use `maybe_view` at API boundaries instead of `std::optional`?
- Is there evidence of coordination failures between libraries that this would solve?
- The paper admits `std::optional` is already the vocabulary type for "maybe has a value"

The paper's own analysis suggests `maybe_view` serves a different purpose than vocabulary types: it's a processing primitive within range pipelines, not a type that appears at API boundaries.

**Red Flags Triggered**:
- ✓ "This is useful" as primary justification
- ✓ No evidence of interoperability friction being solved
- ✓ Types unlikely to appear at API boundaries

---

#### MI-P8: Implementation Capacity Must Constrain Feature Adoption

> *"We have approved features into the C++ standard library, but there's barely anyone right now working on [implementations]... you're probably only gonna get them done in like 5 years."*

**Assessment**: ✅ **LOW RISK**

This is a relatively small addition. The implementation is straightforward (as the paper notes), and doesn't require specialized expertise. Implementation burden should be minimal.

---

#### MI-P11: Implementation Experience Reveals Design Flaws

> *"Testimony from library implementers about actual implementation experience should heavily influence votes."*

**Assessment**: ⚠️ **MISSING**

The paper has an implementation but provides no testimony about what was learned during implementation. Questions that implementation experience should answer:
- Were there surprising interactions with other range adaptors?
- Did the design require iteration based on implementation feedback?
- What edge cases were discovered?

The paper mentions implementation notes (Section 8) but these are optimization suggestions, not lessons learned from implementation experience.

---

## Strengths of the Proposal

1. **Extensive Revision History**: R11 indicates sustained effort and responsiveness to feedback
2. **Clear Design**: The design is clean and follows established patterns (monadic interface matches `std::optional`)
3. **Freestanding Consideration**: Appropriately addresses freestanding requirements
4. **Reference Implementation Available**: Code exists and can be examined
5. **Borrowed Range Handling**: Thoughtful treatment of borrowed ranges for different specializations
6. **Alignment with Functional Patterns**: The `and_then`/`transform`/`or_else` interface follows the monadic pattern established for `optional` and `expected`

---

## Concerns and Recommendations

### Primary Concern: Standardization Threshold

The proposal's core value proposition—safer nullable iteration and cleaner list comprehension syntax—doesn't clearly meet Howard Hinnant's standardization threshold. The "before" code works, is idiomatic, and is universally understood.

**Recommendation**: Strengthen the motivation with:
- Concrete examples where the current approach led to bugs in real codebases
- Evidence that the pattern is common enough to warrant standardization
- Comparison with other languages' adoption of similar constructs

### Secondary Concern: Field Experience

The proposal lacks evidence of independent field experience.

**Recommendation**: 
- Document adoption of the reference implementation outside the author's organization
- Collect testimonials from users who have used this in production
- Report any design changes made based on user feedback

### Tertiary Concern: Vocabulary Type Argument

The argument that `maybe_view` is a vocabulary type is unconvincing. It's more accurately a pipeline processing primitive.

**Recommendation**: Either:
- Provide evidence that libraries would use `maybe_view` at API boundaries, or
- Reframe the motivation around pipeline ergonomics rather than vocabulary types

---

## Checklist Results

### Howard Hinnant's Library Proposal Checklist

| Question | Assessment |
|----------|------------|
| Does this make the impossible possible, or the hard easy? | ⚠️ Makes the easy slightly easier |
| Is there positive field experience from independent users? | ⚠️ Not demonstrated |
| What specific problem does this solve? | ✅ Clearly stated (safety, ergonomics) |
| How hard is the problem to solve without this proposal? | ⚠️ Not hard |
| Is there evidence of real user demand? | ⚠️ Not demonstrated |
| Does standardization provide cross-platform availability benefit? | ⚠️ Weak—easy to add as header |
| What is the implementation burden? | ✅ Low |
| Are there ABI implications? | ✅ None (pure addition) |

### Questions to Ask (from captured knowledge)

1. **"Without this proposal, how does a programmer solve this problem today?"**
   - With `if (opt) { ... }` or `transform` + `filter` + `join` chains—both work today.

2. **"Where is this implemented and who is using it successfully?"**
   - Implemented at github.com/steve-downey/view_maybe. External usage not documented.

3. **"If I can write this in 5 lines, why does it belong in the standard?"**
   - The paper should address this more directly.

4. **"What specific interoperability problem does this solve that third-party libraries cannot?"**
   - Not clearly articulated.

---

## Conclusion

P1255R11 is a well-crafted proposal for a useful utility. However, when evaluated against the principles extracted from experienced WG21 participants, it raises concerns:

1. **Does not clearly meet the standardization threshold** (HH-P1)
2. **Lacks demonstrated field experience from independent users** (HH-P2)
3. **The alternative (status quo) is not hard** (HH-P8)
4. **Vocabulary type justification is unconvincing** (MI-P9)

The proposal would be strengthened by:
- Evidence of adoption and positive feedback from independent users
- Concrete examples of bugs prevented or significant ergonomic wins in real codebases
- Clearer articulation of why this cannot remain a third-party library

This evaluation does not conclude the proposal should be rejected—only that these concerns should be addressed before standardization. The principles captured from experienced committee members consistently emphasize field experience and a high bar for inclusion. P1255R11 should demonstrate it meets that bar.

---

## References

- [P1255R11: A view of 0 or 1 elements: views::maybe](https://wg21.link/P1255R11)
- [Howard Hinnant: Captured Knowledge](../transcripts/howard-hinnant.knowledge.md)
- [Matheus Izvekov: Captured Knowledge](../transcripts/matheus-izvekov.knowledge.md)
- [WG21 Knowledge Capture Framework](../wg21-capturing-knowledge.md)
