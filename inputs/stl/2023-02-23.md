I just transcription as well. Great. All right, so we've got vector optimized, optimized vector move algorithms. This as a sheet of benchmark results with it in Excel which was very nice. I'm not sharing this excel window but. The results shall. Large improvements, which doesn't surprise me. Because the. By large I mean. I'm up to three orders of magnitude. So yeah, large. That doesn't surprise me, because if we look. Umm, so we've got. Let's see what do we have. We have changes to the build to the read me these aren't. So as I just changing the folder. It doesn't seem necessary to me. I think they might be consistency improvements. If you expand the context above. I haven't looked at this PR in detail, but I vaguely recall. It's the little blue context thing right below the down Chevron. Uh, OK, that's a lot of context. While that extended the whole thing, that's alright. Yeah. You, you, you don't wanna hit that one, but now you can't undo it. I. This seems like. The opposite of. Maybe if you're doing. Ohh. Out. Are they just changing the? Read me to agree with what the Cmake Yeah. already does. No, because this is. Like you, you've spent. This is just specifying the build directory so. And then should be able to. You know, you should be able to do whatever you want. Yeah. At the very least, it doesn't seem related to the topic of the PR, and it should probably be a separate change. Let's see if there's a. Let's see if uh. It it does contain a consistency improvement like I I think the reason Misco might have noticed this is when he was following the instructions the the instructions by themselves can't even agree on where the output directory is. Yeah there you go. Uh, here we go. Ohh OK. Yeah. OK. Yeah, that's fine then. Umm. I mean, yeah, I I don't care that much. And and because you know it is unrelated but. Uh, it's a response to another. Uh, you know to something else. Class so I don't wanna be like, no, don't do that because it's. That's, you know, it sucks to have to ping pong around like that, alright? And we have. I'm Charlie. Before you get too far into the review. Umm. It would you be comfortable with the higher zoom? I'm just worried about our viewers in the recording. Ohh yeah. At low resolutions. So this or can we do do the the text separate from everything else? You can definitely crunch the left pane down and you could use unified context if you like that. I do like that. It's the button to the left of changes from all commits that will crunch it to the left. And yeah, there you go. Yeah. So that helps. How is that? I think there should be a lot more viewable. Thank you. One more check. Yeah. All right. So then we add benchmarks, which are the tests. Umm. Add benchmark is under benchmark. Yeah, this is a little bit. Of a deep, uh nesting, but we'll see. We'll come back to that, see if there's any good reason for that. And then we have see. Happy Benchmark Copy N benchmark move, benchmark. The changes to vector and changes to X utility. These appear to just be. It adds a level of like it of indentation. Keeping all this stuff the same. And then also adds a call to copy VIBOL which is in vector. Ah. Yeah, and I guess. Ohh. This is an ADL call. Yeah, this looks like an ADL call to copy the bowl, which is why it can be inside X utility. Uh, without making a sad, but also, that makes me sad. Umm, it's not even a DL's, just dependent. Even if it were qualified it would still work. Oh, sorry, two phase. Look up. I'm, I'm. No. I'm I'm saying wrong things. You're right. Yeah, it's this is actual utility which I don't believe. Yeah it does. Yeah, I I should totally doesn't need vector. So. Yeah, this is a an. OK. Well, but how would we even fix this? We'd have to. No. It would need to be declared. That's the the issue I guess. I guess. Could you expand upon what we're very quickly talking about? Yes. No. OK. So yeah, what we have here is called a copy Bible is not qualified at all. On and you know the parameters are the iterators, and are are all the iterators you passed into the function, so it's clearly dependent. Uh. Like those arguments, make the call dependent on the types of your template parameters, because that's the types of. The arguments. This means it's an ADL call and it's a dependent. 80 I'll call and that means that you trigger look up. Inside the instantiation context of this template. Umm, which is why this works at all. Because. This is an ex utility and copy. The Bible is defined up in vector which is not included by X utility. And so. Without this. You would only work if you if you included vector previously to axe utility. As it is, it'll work all the time because you can only get. It's difficult to get vector bull iterators without having access to vector bool. And and it's looked up after you know. At, you know, at the point where you call, just copy, uncheck. Umm. But yeah, that's kind of nasty. And so STL suggestion is we could declare it however. I mean this is an inline function. Umm. So that declaration I think is undefined behavior. No, it's OK to and this is not actually marked, it's constexpr. You can declare it. And then later provided definition and everything is OK as long as it's defined by the end of the TU. Even if you use Yeah, but that's not. it in a constexpr context, I believe. Yeah, but it's not always if you. Like what if you call? Copy on when it on your own container and you don't include vector at all. Then the if constexpr should not activate and the branch should be consider dead. So the whether copy V Bulls ever actually define should be moot. I'm like 95% sure that the Standardese works there. Yeah, that's right. It should bind in nothing. It depends and The other thing the the other thing is. Umm. the definition context, and you know it's never looked up at parse time. So I'm sorry it instantiation. Yeah. Also, I mean, if we do just declare it then. So that's fine. Umm. I think it's a linker error in the real world. Yeah, but, but you can't ever see it. Yeah, OK, that's fine. But. But we have to declare it inside this if context for. Ranch, right. No. Excuse me, it could be declared outside and should be. It should just be declared top level, not like within a function. Because if you look at the signature, the signature of it I. doesn't care about V iterators at all. It's completely unconstrained. Yeah, but I think even even just having the that declaration appear if you didn't happen to include vector and you're not gonna hit this branch, is UB technically. I believe it's OK to declare a constexpr function and then Why? never define it and never call it. Ah. There, there should be no case where providing a declaration It'll work. is. Umm by itself ill formed. Huh. Because because in C plus the declaration is telling the compiler. I'm gonna have this thing. I'm not gonna tell you what it is yet, but it's gonna be a name. You. You get a notes, a class or function or whatever. There's no actual like semantic checks or anything until you actually provide a definition. It's always OK to just clear stuff. Umm, I think it's. I think technically just having the declaration. Is you be, but it's not. Like it's not something that's possible to check. Umm. And it works and I'll all the compilers have the same behavior. And if you do that. Umm. But anyway. Umm. Ah. It is very annoying that it. Like if you somehow get those vector bullet iterators then you get like a call instruction like it's an actual linker error. That should be a. Worse than that, it's not a linker error, it's it might be a linker error, but it might not be depending on. The order of your object files. So. So. Yeah, the way to fix this that I would propose is declare copy V bowl above, copy unchecked and then that's it. Everything works. You never get a linker error. You never get a compiler error if you call copy unchecked with a non vectorable iterator then the if context branch is not selected and everything is cool if you call it from with the vector iterator then the definition of copy V bowl will be available by the time you actually call the thing and then everything works. Yeah, no. Yeah. So that's true. Like the my concern is just that it could be error prone in the future because you then have that name available. Umm. You know, throughout the rest of the file, and if you happen to call it in a place. That could be reached without having included vector. Bad things happen. In theory, yes, but in practice copy V bowl is really only meant for vector iterators every single you should be guarded by the sort of is VC iterator that Misco is doing here. It seems extremely difficult to get into trouble. Yeah, I yeah, I'm OK with just declaring it up there, but I. We could declare it in at functions scope too. I cannot think of any examples in the STL where we have a function local declaration of a function. Alright, if if there are no other example. If I'm wrong, we should not be doing that. That's squirrelly. It's not, it's a template, isn't it? We can't have a function. We have a block level declaration Yeah. And as a template, yeah. of a template, period. No. Yeah, that's a good point. I did not remember that the template. And you could ask him to stood, qualify it, since we're trying Yeah, well, yeah. to do that with ugly names then. And. Yeah, sorry I didn't clearly cannot pronounce under score capital stood instead of colon, colon, lowercase stood. Thank you for getting it correct. Yeah. And then this all looks identical, which is good. Yeah. Great. OK. So that's just modifying. Yeah. And then this is the actual test of. The actual functional test, not the benchmark. Yeah. Umm, so let's look at. Vector. Umm, so my understanding then is that previously what was happening was you would copy and it would just go through the fallback copy path and like. Run all the iterator code basically right like. Do you references the iterator and copies over 1 little bool at a time? Uh. Resulting in you know lots of ends in orders for for each individual bit. Hmm. So instead what we want to do. And I think it's. My understanding is that that's catastrophic for the processor, right? Because every result depends on the previous result, so it can't really do any work with instruction level parallelism. And it's even worse for performance than all the bit OPS might suggest. Yes. Is that right? OK. Yes, although. Since we're doing all the iterator stuff too. It's possible. It's like doing a bunch like it's doing. Calls or something in between 2:00. Especially in debug mode. But yeah, it's not good, and even even discounting that, like all the bid OPS are just kind of. Bad because like. Though like. In most cases, the resulting word. Like the end result that you need is already in the source vector. And this just So what we're gonna do here, my understanding is we're figuring out where like. Which which chunk? The beginning. Of the range to copy is in. And then we're figuring out which bit is the start and then we're. Calling out that whole section, copy it over, and then for any full chunks we just. Copy them directly. And then at the end we figure out where it ends. If we copy just that portion. OK so. We unwrap. The iterator. You're a const cast. That's weird. I believe this is because if you look at the definition of VCBE iterator, it's the VB Const iterator is the highest parent and then the modifiable iterator derives from it using the constant one for storage. So my putter is always a constar. I That's so cursed. think that's how it works. Yeah, it's pretty cursed. Is it always a rough winner? That's. This was. This is one of the first things that I fixed in vnext. Uh, which is stranded in our TFs branch, but they're the iterators are templated in a consciousness and we do not have Yeah. one inheriting from the other, which is actually nonconformant in some obscure situations. Yeah, well. Yeah, I'm. I'm OK with this. With the contrast in this town in this context, but let's just keep that in mind and make sure we're not writing to these things. Umm. First last destination. Umm. Oh oh, that that's a good point. You you bring up an excellent point. Why are VCBE first and last modifiable? I mean, desk has to be because we got a scribble to it. But first and last, we should never scribble to those. Those should just be Const. Right. That is a good point. Let's. I can't wait to write a comment until we're through more of this. Because it might be, it might end up being self-explanatory. The end. Let's see. OK, yeah, this is just the end of the destination range, which is destination. Yeah, what's the difference? Uh. Or source mask. I believe this should be the. But. The mask for cutting bits out of the end of the first word and at least significant bits of the first chunk. I don't it does vector bool store word by word or double or or. Or. Like 8 or or bite by bite or what? It's an unsigned int. Units of unsigned INT, under score V base. I should say specifically as an alias for unsigned INT. Alright. So these B based putters are. Are pointers to unsigned ints that happen to be the 32 bits We'll say. We'll say in. sequence containing the begined. I'm sorry, containing the one that the iterators pointing at. If I try and say double word by double word I'm I'm knocking it. Remember to say consistently. Uh. And word is ambiguous anyway. OK, so this is all ones. And as. As an aside, Umm, we should, although this is not the highest priority, it's good to make sure the code is kind of being generic about what we base is cause in the V next if we ever want to make V base 64 bits on 64 bit platforms it would be nice if as much code as possible automatically worked, but it's not critical right now. Yeah, I think the the thing that is not being generic about is if we ever wanna make it smaller than 32 bits. This is not generic and I'm 100% OK with that. Umm, that's not worth it. Umm. OK, so all ones shifted. Through the the offset. Umm. And for the destination, let's see. Want all ones? OK. Yeah. So this is going to be all ones. Uh, yeah, so, so all ones in the unoccupied. Region. Except reversed from what I would expect. The first, the first destination mask. Umm. Is ones in the. We'll say rightmost. Places and the source is ones in the left most places. Umm. Is is vectorable. Oh, that might just be endian this. Umm. And then the. Uh. OK. Yeah, technically it's not processor endianness because at no pointer reinspecting the byte representation of the stuff, but vector bool does have a preference for least significant or most significant where starts filling from I always forget, so I always have to look it up. Pretty sure Miss goes got it right here. Yeah, I mean it's arbitrary. You just have to be consistent. OK, so single block source. So that's just if we only have one. Locke and we need to know that, presumably because that means that. Are mask is double ended? Uh, same with the desks. The destination. Umm. I am surprised that we are. Doing this instead of just unwrapping it, but we'll see if that comes up again. We might just wanna unwrap it up here. Like you know, do this task. Umm. You already excluded first equals last. Ohh, that's up here. Uh, yeah, so this is if you're copying 0 elements. And so it's comparing both. Which block you're on and what the offsets are. Umm, so this is when you're. Copying more than zero elements. Uh, last source mask. On shift. UM. This is going to be 32, presumably. Minus whatever the offset is. Umm. And you're shifting OK. UM. And then we combine the masks. Ohh. Started the inverse of of of what I was expecting. I zeros are gonna be where we're copying from, which is why this is reversed from what I initially expected. Umm. Or. Yeah. Umm, where is right shift set? OK, that's if. Huh. Uh. Ohh is right, shift is referring to the direction of the copy, not the direction of the bit shifts. I think. Ohh, it ends up being equivalent. Umm. Ah, OK yeah, this is just. Now we shift by negative is is my off unsigned. Probably. Uh, you cannot shift by negative, it is undefined. Uh. So it's good that Minsky's being very careful about that, just like he's being careful about doing a full shift, which is a nonstandard. OK. Yeah. So that's what this is doing. This is just shifting by the absolute value basically. Of the difference between. Yeah, but this is gonna so is single block source. So this is about the destination. But. We don't know if the destination is in the same block as the source. Ohh but. It could be arbitrary, so this is like realigning the vectors OK. Yeah. So there's like 3. Realigning things so that the like. So that the part you're copying looks like it would if. If the source and destination had started out that had been at the same offset. Ohh, are you are you're bringing up an interesting question. What about? Alias saying where they are vectorable iterators into the same container. Is any overlap permitted because we're doing something sneaky with the processing word at a time. There is the whole special case about you can't have concurrent accesses to separate elements of vector, because they're not really separate. I don't think the plane algorithm has that, so Well, I. are we just subject to the usual one way overlapping restriction Yeah. However. on? However. Ohh yeah, so if. If it's subject to the usual one way overlapping. I think we're OK. Because we're always reading in full words. And then writing in full words. Oh, but if they all? And yeah, and we preserve. And I believe we preserve the. Parts of written when we write, we preserve the parts that are outside the the copied range. Are you right? So you so you really do have to have to be like strictly overlapping in the way that's not allowed. Like in in the way that usually cause that you know causes the usual problems for. Things to go badly. Yeah. Yeah, I think you're right that we're essentially we're doing what the individual operations would have done. We're just doing it. Up to 32 at a time. So and we're careful to preserve the existing data, so I don't think we should stop over anything and therefore we don't need extra aliases checks because if we did, like my brain would explode. I think we're OK here. Yeah. But we should make sure that we test that. So his single block desk? That means that. We're in the same chunk. Then. Yeah, that's what this is doing. So does mask is the the ones are where we preserve data. Oh no. Well, uh. Is this is gonna? Wherever the. I think you're right. The the ones that were we preserve data. Because the parenthesized left hand. Part of that expression says OK, let's only preserve the bits of ebbs that aren't being messed with, and then after wiping out to zeros all the stuff that we want to overwrite, then we turn on the source, fail. Yeah, but we haven't. Let's see where is source mask OHV for. OK. Yeah. So we've already zeroed out. So we've both up here, we've zeroed out. The the bits that we don't wanna copy. And down here we have. Umm. Zeroed out the bits we do want to copy, and then we ordered in. That's fine, alright. Yeah, that makes sense. Than otherwise if. Let's see single broadcast. Otherwise you just do first ask math that desk mask. Uh, which is? Year and. Yeah. Umm. It's not completely clear to me that. Uh, we couldn't always compute, you know. That always doing this is so bad it, but it avoids a data dependency. And I don't really mind it. Umm. And I don't particularly wanna play code golf with this. Yeah. OK. Then we go on to the next destination. And last shift is. Huh. Ah. I see. So this this is just doing the other half of the copy and. Because. Because we're in single block source, that means that we can at most like the the biggest range that we could possibly copy is 32, which can't possibly span more than two blocks of the destination. And you can only be one break, which is why they, which is why we just did the beginning in the end. Directly here, OK. It would be kind of nice to unify the the the tail, the processing of the tails. In each case. OK. UM. So this is just to keep it constexpr in 20. I hate this a lot, but we do it in various other places and. It's better than any other than any alternative I can think of. It's better than hiding in them in a macro. Umm. Let's see. Yeah. And that's just because we need all this men move stuff. We could potentially make it always constexpr or. I. Writing out the men move loop manually and hoping that the optimizer can deal with it, but. Whatever. And then move exists because the optimizer does not deal with it. Well. Yeah. Uh. So vbase 7. Ah, that is. Clever. As hell. So this is figuring out the alignment of on a on a char by char level. Umm. So that if. The offset of your source range. So that if the destination is at multiple of. Uh. Is a multiple of 8 like. Whereas. Is multiples of eight past your your. Your source range. In offset, then you can. Uh, you can just use. Ma'am, copy. Let's say so. Or offset times 7. Yeah. Why is this end end 7 instead of a some mod operation? It could be written as Mod 8. I don't actually know why certain is ampersand 7. Umm, I mean, it's to make it. An end instruction server mod. I'm sure. But. I'm pretty I I would speculate that the compilers people optimization should be able to do that. Of course, in optimized mode, in debug mode, you're right, it would probably emit a modulo by a constant. Yeah. It's kind of strange that we're using ampersand here, but we're I just didn't. happy to divide by 8. On 3790 through 3792. Oh yeah, that's a good point, that division. It's like I'd expect to see and in shift or mod and divide, but the mixture is. Yeah. Peculiar. Uh. Not that I care a whole lot either way. It may be that the people optimizer is not good enough. Umm. And give. But we know we know it doesn't run in debug mode so. I might my recommend just striking the second part of your comment and just say like it should just be shifts. Like if we're gonna, we're gonna care about debug code Gen. we should just do the shift. Don't we have president of doing shifts elsewhere? Where did this come up? Was it caricom? No, it was something else. We. Not an issue actually for a long time we were doing shifts instead of divisions by two and a lot of the algorithms because the people optimize are broke in the back end and we've had to file an issue really filed the issue prior to call precisely Ohh yeah, in in our quick sorts and stuff, you're right. ticket at fixed yeah. Yeah, I don't really. I didn't actually know about the modulo trick. I'm sure I've learned the whatever underlying theorem makes that true at some point, but. Umm. I guess I need to break out the copy of hackers delight after this. Uh, But yeah, I like wish. You mean replacing replacing mod 8 by Ann 7? Yeah. That that's like it. It's so it's own decimal. Like if you go Uh. like Moda thousand, you'll just keeping the last three digits. So it's like ending with 999, keeping only the last two digits with bitwise it's easier. No, that makes sense, yeah. Umm. Yeah, it's much harder to explain the magic multiply trick. I don't have a cute analogy for that. But the shift thing or or no. Ohh no the. No, no, no, that that, that's where if you divide by something that's not a power of two, you can replace with the multiply and a shift your magic. Some cases. Yeah. Yeah, I I think. At least with shifts, it's like. It's common enough that I. And just write it out it it's a little weird but and and if we had a a, you know minus OG mode, I would say just write the division like it's fine but we don't. So. OK, so if. In the in the code above, I wanna ask something in the middle line if you scroll up 1 bit. Line 3791 how do we feel about that, saying unaligned first bits being used with dest? It looks like a copy paste error. It's not because 3787 just proved that unaligned first bits is equal to unaligned best bits, but it seems very suspicious to. Take advantage of that on line 3791. I think it's, I mean this code is inherently. Like it requires that. That they be aligned in the same way for what it's about to do. Oh, I I certainly don't dispute the need for 3787. My question is purely stylistic on 3791. Should we say unaligned desk bits so we match up exactly Uh, yeah. first? My off first bits desk, my off desk bits last my off last bits. Umm. Alright then, alright. Yeah. Because when I notice that I was like, wait, is that wrong? Oh, wait, it's right. But. I mean debug performance is probably better if you use like for instance in both places. Because if it's speculating. I mean, you know, who knows? The compiler might reorder this stuff, but if it's speculating through this if. Uh, then it doesn't need to wait for. Both of them, like if we do it this way then it needs to wait for both of these instructions to finish. Uh, before I can do this before I can do this line. Umm. I would be very surprised if that turned up in profiling. We're talking about, like subnanosecond here. Yeah. This is true. Uh. But I I bet that's why I was written now. OK, so this is if we have any. Any offset at all. OK, we can we compute this source and dest the source and destination mask. Uh, and we write B dest. Yeah. And we write and they're they're inverses of each other. UM. Actually. OK. Yeah, they're strict inverses of each other, but we're going to compute them separately because. It's not clear that way and it's better. Ah. UM. And then we out what are these V 1st and VCBE? OK, yeah. These are reinterpret casts. Is a pointer cast through. Char star. Uh or two char star, which is fine because it's char star. Uh, I'm. So that doesn't cause. Fun aliasing problems, not that it would actually, anyway. Umm. But. Yeah, copy bits into, OK. And the next to our alignment is always the very next character and then we. VCBE last character. I am concerned that we might be copying additional bits here that were uncopyable here. Or yeah. Oh no, but that would come up. That would easily come up because we would have just overwritten them. So yeah, that's fine. That would be caught. Umm is. Is the strategy here right? A partial byte? Do a block copy of bytes in the middle and then write a partial byte at the end, in which case there should be no overlapping. Yeah. Yeah. OK. I believe that is the strategy. Umm yeah V desks Ch. And yeah, copy unchecked returns one after. I think the last thing it wrote. Yeah, and this is the same. Is above. And then we return. The desk and that we computed way up here. UM. OK. So is right shift where we actually compute that? Ohh OK. So this is if. I don't love the name of this is Rachel. Very well, but. Umm. If the destination offset is less than the source offset. Do we need a carry? Instead of just reversing the order. I think it's. So this this is not, it's not when the source and destination are overlapping, but it's when they occur at different boundaries within the 32 bit words. When things are exactly lying, things are awesome because you can just directly copy the unsigned ints over. But if you No. start at, say. Umm. You know why? You should only need to do. We should be able be able to get aligned at some point, right, and only have to do a partial bit copy. Yeah. So if we if we figure out. The so this is for if the offset you're copying into is less than the offset you're copying from. And if that's the case? Ohh it's because. Yeah, in, in, in. Is because in this case you can shift off the off the beginning. And if you shift off the beginning like. So here you're going. OK how many? You're gonna figure out how many characters are copying? You're gonna pull out that many bits from first. And end up with, you know, a bunch of zeros and then those bits and then maybe a bunch of zeros, and then you're gonna shift off. Uh to align things. Ah. No, but that's your name. Even that should not shift off the front. Well so. So basically there is actually no, none, no, uh, no one herent relationship between the urns and the source and the urns in the destination. Some of the urns and the source will need to be mixed across two of the urns in the destination. So that's the carry that miscoe referring to. Essentially, when we're doing this. Transfer from the source to the destination. We don't need to do individual bit operations, but we do need. We do need to do some bitwise shifting and gluing together of blocks to handle the fact that not everything will occur on Nice 32 bit boundaries. Yeah. But I still don't see how. How like if you're copying backwards, is what this case is. I don't see how you can shift off the front when you do that, it's. You would need additional bits. Year ohh. Except then to handle that you you reverse the order in which you yeah OK. But there is no copy backwards here. This is copy forwards. Said he always have the bits. We're always incrementing the VB first. Yeah, so it's a but. It's like a carry, as if you were copying backwards, but you do it by delaying by incrementing VB desk. Only sometimes. Like V desk increments only sometimes. When you are. Vtest may increment. Multiple times before you incrementally be first. I do not believe that is the case. On 3830, we get exactly 1 increment of VCBE DAST per increment of VB first on 3826, but we get an interesting pattern here that does not usually occur in such copy loops on 3828 and on 3832 we have multiple writes. So for every loop on 3826 for the for the main for loop where we're. Yeah. Gonna process a drev first. We actually split that across 2 words of VB Dest, the 1st right, then we advanced forward the pointer and then the second write, and then each individual location in VB desk is written to twice, once by the first half the loop and once by the 2nd. So that's where the blocks are sort of getting fused together. But there is aside from that odd pattern, there's no irregularity in. How we're processing each element is just instead of 1234 And you're right. I I think I'm, I think I'm. it's like 11223344. I think I'm thinking of things kind of backwards to how they are. In terms of like when you encounter like the bits that you need for that carry. Umm, alright. So source shift. Is just the distance. It is it is work, though I'm not. I'm not sure if you're aware, but just so the our viewers are aware my off is not. Umm if if I remember correctly my office not an index within the entire vector, it's a bit index within the word. Is that correct? Yeah. I think that's correct for the vector bowl iterator, so my Yeah, that's why. office never. It's like 0 to 31. If it isn't there a lot of the stuff we've looked at is wrong. Yeah, that's why this works. Yeah. That's why this works like. Umm. Like this covers both. That's also why that assertion about last stop my off being zero and the a single block source case was true. Yeah, that's right. Yeah, like, like, that's why this cover is both like. Copying from different size vectors and the same you know. The same sized ones at the same position. OK. Umm. So we write the first source Val. To the vector. Uh. Increment first our carry Val. Is. The next part. That we need in dest. And then we combine that and write it to dest. And then. Ready for the next destination? And we do this part again. So I shift. I guess because we're no longer at the beginning, we don't need to. Yeah, we don't need to do this masking anymore. As we pull out a whole word here. And then pull out the other half up here. That's clever. Umm. View first what's VCBE last. Uh. Again, if we're overlapping. Yes. So we didn't get a carry. And in the destination we have to do the same. As before. Same as. Up here. And in addition, we then have to do the tail end. Which doesn't need a carry. Rise. You just need to finish up. OK, wait, what's this else branch on? OK, if if we're not a right shift. It should be basically the same. Except we're keeping the use of carry, Val and. Of the carry in the non carry parts consistent. Which is why. Some pictures would be good here. In the comments. Which is why we shift. And then. Front all he needs to write carry. Is this cast of void needed? That's a weird place to middle warning. I think Misco might have put it there because it's needed in generic code, but I think in this case we're guaranteed to be working with raw pointers to VL base. I think that's the type of VB 1st and vctest. So you're right that the void cache should be emitted. Yeah. Yeah, I guess. Yeah, I would have expected it to be on DB first anyway. Oh oh, that that's a stylistic preference that we have. So it Ohh avoid cast anywhere in there. Avoid cast anywhere in is correct that you can. there. Silences the warning for everybody. It the the answer is yes. But no, it depends on how many operations you have. If you have like plus plus X + + y + + Z then you can put it on the 1st and the 2nd but not on the 3rd. That's too late. We can eventually put it in the second or in the middle because that handles the most cases and it's the most visually unambiguous. If you said cast void Increment VB first comma, increment V Dest that does syntactically work. It makes the left hand side of the comma operator void. But it looks weird because we don't usually think of the void cast as binding tightly, even though in this case it does. If you put in the middle, it works because it makes the right hand side of the comma operator void, but it visually is unmistakable. It's clear that we're casting the right hand side to avoid before doing anything. Umm. And the nice thing is if you put it on the second one then that also works when there's three occurrences. Umm it's it void defies the right hand side of the first comma operator and the left hand side of the second comma operator and I don't think we ever have four in the STL. OK so. What cases are we going to have to test? We're gonna have to test. Aligned. One character. On each character, we're going to have to test single. A single block source. Uh, where the personal ascertain the same block. Then we're gonna have to test unaligned both forward and backward. Online by Char both forward and backward. No. I don't like this. Umm. Oh, it's sort of random. OK, that's better than if it was just true, false, true, false, true, false. Uh. I'll allow it. For now. Oh, and it's pretty existing. Yeah, that's just moving that. Moving this array. Here. We could probably constexpr, but it doesn't really matter. And only. You can't have a top level constexpr vector because the allocation would survive. Well, it could be an array. But then it's not adaptable. Yeah, it could be, yeah. Then we would need to make a vector bowl whenever we wanted to use it. OK, test copy, no offset switch length. Where do we? This could be. Why can't we just take a range of the? Ohh, because that would do a copy. I see. Yeah, great. And makes sense. Uh. We can't just copying. His next really necessary here I. Yeah, it's fine. It's not a big deal, it's just a weird style. OK, so this should be. Totally aligned. And we have. That for that and. Yeah, except we have caps on the end. And this should this should be a single block. There should be a full single block. Good. OK, but this doesn't test. On the tail, really. You're copying into a tail, but there's nothing there so. Need to make sure that that happens. Happy Ann. OK, this is identical though. We're not really testing copy and being. Yeah, because it's copying into the full length of the vector. The destination vector. Copy backward. What? Ohh, he goes right. Yeah. Although presumably the point of copy backward is to change the rules about overlapping. That's correct. Yeah, OK. So we need to test that. And of course with copy forward too, so offset in the source. And then this. That weird. Yeah. OK. So that's just because one of these values is omitted. Wait. False, true false for 67. Should we not omit one and then? Have the offset. So I I I haven't thought about in detail exactly what these tests are doing. But I am a little bit nervous that we read through so many special cases in the product code and there's a lot of special cases and there have to be and it looks like they were all diligently taken care of. But when I see that many special cases, then I sort of want to see really exhaustive testing. And So what I would have expected to see here was Yeah. something that tests. For every possible alignment within a 32 bit value of the source and for every possible alignment within 32 of the destination vector bool and for a good mix of lengths to handle. The special cases of single block like exactly 2 blocks or a bunch of blocks. Umm test all that now the problem is you do end up with Yeah, well. the multiplicative explosion, but it's actually not that bad. Like if you have 32 offsets times 32 offsets times 32 possible links, that's only 32 Ki, just multiplied it out test cases. And if we believe that this should be fast now then Yeah, I would prefer so I think. could be doable. I think the test is trying to like. It's very in this way because it wants to test vector bool without like using vector bool. But I think it might be better for the test to like implement its own, like really brain dead vector. Well, the the we have such a thing, it's called it's called With iterators. vector unsigned care. Like you can take all the values that you would put into a vector bool instead put them into a vector unsigned care and now you have a reliable source of truth. You do need to do comparisons you know element wise, but that's what stood equal will do anyways. Yeah, the the reason I I could understand like code not wanting to do the full exhaustive multiplication, but it seems like there would be better ways to do that like testing only. Also we last code. Yeah, yeah, yeah. Basically what that's doing, where it only tests like certain lengths, but. Yeah, this is not really especially because I don't see I'm worried it's. any overlapping tests. Yeah, no overlapping. And I what I'm not seeing is exhaustive testing of the possible offsets. It looks like there might be some there. I just I'm worried. Uh, we we've been burned a few times by algorithmic changes Yeah, I I. where we tested some stuff, but we weren't really diligent about it and we forgot. Oh, wait, what if this source is like 33? That's what I'm gonna say a given like. We can just talk test this exhaustively. It's not a big deal, right? Like we can. Like we can do it. Our strengths. Huh. Uh, for when you say overlapping ranges, could you clarify that you only want to test the ones that are actually supported by the standard? Yes. OK. Ah. That is to say, the. Destinations before the source. Or. You're muted. You're still muted. Ah, sorry, I would say, uh, only the ones that are permitted by the standard, because the answer is different for copy forward versus copy backwards. So you don't want to be too specific. Sorry, I'm still figuring out this mute button apparently. Yeah. Yeah. And then as a bonus. I mean, you know. Like if if we're using a, yeah. Should you clarify what you mean by using vector unsigned care for this? I worry that. What we're talking about might not be captured here. I think you mean like it's as the reference, right? Yeah. Using vector as. Hey. Yeah, I. Yeah, that's a good way to put it. I don't know if we need. I think I'm less concerned about random generation because that I mean we we could always ask for that, but that requires more infrastructure and we we have that elsewhere in the code base, but. In this case, we're not actually that concerned about the data dependency like as long as the pattern of trues and falses is Yeah. kind of jumbled then. And it as long as it's not so repetitive. I think it's the obvious way to do it. It's the natural way to do it anyway. Yeah. Because we really care about is variation in the offsets and the lengths and as long as the pattern doesn't exactly overlap them, we're fine with it. Yeah. I mean, yeah, there's only goes up to 67. Let's just. That's not too bad. It's like 2 words. It's not huge. It's like 2 words in a little bit. It does seem kind of small. But then you don't. Yeah, but then you don't get 3 bytes. Yeah. We could be missing something there. There is at least a Uh. little bit of attention around 3132, but what about 33? What about all the offsets? I'm just not seeing that I wanted to see like 3 nested loops and maybe some hackery to deal with. It's taking too long. But that would make me feel a lot better. And of course, the context here that Charlie and I are well aware of, but have not explicitly stated as we just got done dealing with fixing a bunch of regressions caused by performance optimizations and those performance optimizations were very good. I'm glad we took them, but we got to be real careful about breaking code that works. Umm at runtime because that's always painful. It's a good cause. These are all runtime optimizations. That's what's tricky with compile time stuff. It's less risky because if it doesn't compile OK, we can fix that. It doesn't really ship to users, but if it breaks it runtime, it's always bad. Yeah. Well, so for size, I mean we wouldn't exhaustively test with every size we would test. You know. We would take. I I would say up up to some limit. I'm honestly like 100 is fine. Once we're once up to a. Well, well, no, it won't, but it. But but it would have to be. You know, we, we'd have to either go by multiples of eight or 32. Oh, no, no, that's that's scary. Like you. Don't you specifically Because if we're testing. don't want multiples 8 cause that that's gonna hide baldness that occurs at. You know non power of two boundaries or something. No, but. The problem is that if we're. Are you concerned about the time? Well, yeah, if we're testing both if we're exhaustively testing both the size and the shift positions. Yeah. Yeah. So, so there, there we could we could like The thing That's three things, right? is once the test has been written then it's easy to selectively skip or end early or something. Umm, where we maybe go densely like 12345. You know, up to maybe 10 and then we start skipping stump. But we still make sure to test around, you know the 3032 boundary and the 64 boundary and then throw in an odd prime here. There once you have the core loop written, it's very easy to make faster. But I think the focus should be first on let's just test everything up to the full you know 32 * 32 * 100. Just go nuts and then see Yeah, but I think. how fast it is. But I think everything is like 3 to the. 200 something power. No. So, so, so we're we're all the possible variations. I was just doing the math in my head, there's what offset are we in for the source? There's 32 possible bits. What offset are we beginning at for the desk again 32 and then how long is the sequence that we're copying? How many bits? So that's 32 * 32 times, say 100. That's not that big. OK, I was thinking I was thinking the length, the number of bits and then the beginning iterator and the end iterator. Which is much worse. The length is the number of bits, so so those are the same. Yeah, yeah, but the the beginning and ended rather is different from the offset. Umm. Once you have the bit offset. Of an iterator doesn't really matter where in the vector bool you are. You're right that it is. It is a difference but. The algorithm does not care about words in the vector bool that occur before the beginning iterator. The vector could have a 1032 bit words before that initial iterator. We just don't Yeah. care about any of them. So we really only care about the offset where it is like the the universe sort of begins and ends at the VB 1st and VB last word pointers. Umm, so that's why I think only the offset matter offset in the length matters. And what about the number of of of bytes between them? Umm, I think that's captured by the number of bits being copied. Those are the only three parameters I can see that really matter. OK, so we'll say instead of bits in the vector, we'll say number of bits. Yeah, being copied. Yeah. OK, yeah, that's that's fine. That's that's exhaust exhaustively testable. Yeah. And then if we find 32 * 32 * 100 is too slow, then we can optimize it or run only the fast matrix or something. We we've dealt with this in like the random generator tests where those are a little hefty. Umm or CARICOM, where we we did end up randomizing it but. No, but. But 32 * 32 * 100 is is fine. It's like. Yeah, zero. That's zero. That's nothing. Yeah, it's, it's. It's not like testing all 32 bit floats. Yeah. And even yeah, like is. It's fine now. It may be in debug mode, yeah. Let's see. Well, let, let's take a quick look at the test. And. Oh yeah. The best horse. Yeah, I'm the the fun secret about our And the. test is that they're all compiled and non optimized mode. I mean, we do vary between release and debug and we actually do not turn on optimizations for the tests except for the fast matrix. Which is fine because usually our code doesn't care. Yeah, well, OK. Interesting distribution. Right. Yeah. So honestly, most of the code to do all this stuff already exists. Like most of this exhaustive testing code. He thought his right here, like you just need to. Also do it the vector unsigned int. And do the comparison. Umm. Yeah. And that's fine. I'm fine with that. We could just use well. You know fine with that too. As preexisting. Let's make sure we're not already doing what we want. No. Yeah, I think this is the first time we really care about boundaries. The count stuff cared a little bit, but there's just so many more cases here. UM. It's it's all the special casing that all the if essentially the nested ifs that we really want like 100% code coverage essentially. Yeah, just wait until somebody vectorizes this even more. Well. I guess doing that you just it's just that inner memmove loop which memmove will vectorize anyway? Yeah. So I think that's kind of my feedback. I I don't think the this is I I. It's not hard to to write these these exhaustive tests. But the the actual implementation looks. It's fiddly, but it's fine. And pictures would been nice. I don't think the code is relatively clear. It is the sort of thing that benefits from having a pad of scratch paper as you work through each line. I think with the test that we're that would increase my confidence and ohh before we get to the end of our time slot, the constness you said you're gonna come back and comment on that Yeah, the concepts. later. Yeah, I I don't see us writing through like. Yeah, well. Yeah, like. Well, we be dazed. We. Yeah, that desk of course needs to be writable, but first and last. It might be worth mentioning in this comment that this implies cascading changes like with the character pointers. Those should also be Const. I'll I'll just put another comment. OK. He, he, he. So yeah. I'm sure whoever ends up better than this, we'll figure out without a comment here. When the compiler rejects the reinterpret cast that's casting awake. Yeah, that that's a nice advantage of the. Forbidding of sea cast in our code base C cast are just say yeah whatever. And yeah, Const char star can can can alias in the same way as Char star so. That's fine. Ohh would you need that boy cast on the between the iterator increments, by the way. Oh, why? Container iterators are parameterized on pointer types. Uh. Ohh allocator. Generally speaking on fancy pointer types. In this case, it's the allocator specifically, but it must at least be on the Ah. They're not. the pointer type of the allocator which the user controls. So these are hackable. They're they're not. Are there no hold on art? Can you scroll up? Is VCBE first and VB desk. Are those raw pointers? I thought they were raw pointers. Oh, I'm sorry. Yes, these are raw pointers. I'm not the vector blurring writers anymore. I'm wrong, yes. Yeah. Yeah, yeah, Casey's wrong. Amazing. I'm so happy to be wrong. Yeah. There's something that user can't hijack in it's raw pointers, yeah. Yeah. Raw pointers to actually no raw pointers. General Fine, even if Yes. they are to user defined types. Yes. Yeah. I yeah, that I don't think we need that. Umm. And if the compiler is complaining about throwing those values away, it's being bad and you should feel bad because like. Oh, yeah, yeah, the compiler would not complain about that. That's the one. That's the one reasonable place to put a comma up, you know. Yeah. Yeah. OK. So other than the testing changes, this looks pretty in the Const stuff. This looks pretty good and let's see, we do, let's say we do call test copy. And it calls. Let's see. Yeah, this is all. Probably doesn't need to be in the video review. And it would be easier to do with the editor split. But. Yeah, we're just at the end of the time slot anyways. Yeah, we are at the end of the time slot as well. So I'm not gonna go through and make sure that every single test was called and. Stuff like that now. Plus I'm known to forget that myself. Umm. Yeah, OK. Ohh I should. Submit their view. Before I forget. All right. Thanks everybody. Thank you, Charlie. Uh. Always fun. Uh. And yeah, it's some pretty substantial performance improvements. You know, stop the recording.