Welcome to another VC lives open quarter view. Ah. Today, we're going to be doing the. 82093 R 14 Provision 14 formatted output. This basically allows you to write something like. Example. And just say stood print. Hello blah. This gets us up to the nice standard of printing that other room have very pretty. I like it a lot. Honestly, it's one of my favorite new kind of. Beginner ish features like. New it's one of my favorite new features for everyday developers. So if you look through it. Girl. Let's see. It's like the wording. There isn't a significant number of new API for such a I consider to be significant feature. We have our classic print. Which? Just prints 2. So now we have print which prints 2 of file star where you can choose whether it's stood out stood there. For like a a file that you've opened. Similarly print Ln which will add new line afterwards. And then we got the V prints. Forgot print to an ostream. I actually don't. Really understand what the difference between reprint Unicode. And be printing on Unicode is it's. On to me, I I don't fully understand that I. Until can you? Say something about what this actually means. I do not remember it in detail. I reviewed it and I did a like a wonder one. You know, correspondence between Yep, this seems to do with the standard says, but I don't recall it in enough detail to be able to explain it from scratch. I think it it's does like UTF 8 conversion or something. I think that's a difference. I'd say since my mother somewhere. The text is a little tiny. Can you zoom in a bit? Wrong with me? Can you read it now? Yeah, that should be more visible for the recording. So right. So the difference between viewpoint and Conan viewpoint nonunit code is that the print Unicode. If this is not important on Mac OS or Linux because they're streams are never. Anything other than bites. On Windows, if you're writing to a a like a file or to a pipe like, you're piping output from one program to another, that'll be done in by. However. If you're writing to the console, if you want. Be. God that that the output to come up. When you're using Unicode characters, you have to actually convert to UTF 16 and then prints the console. And so be print Unicode. Does this like magic stuff and it checks if the streamer you're printing to isn't. Is it console terminal? And then it does that Unicode version. The conversion to you have 16 and then prints it out to the. So this all makes sense. Like there's also P2539R3. And this is just saying. If. We use the Unicode API. We have to flush the stream buffer. And it just means an extra flush in be printing. So. Look at the code. I'm going to assume that pretty much all of the. External API stuff is good because I skills looked at it already and my. Feel like he's really good at this kind of thing, but what I really wanna look at. I did. I did forget an only realized at the last minute that we should Right. check our API usage for both operating system dependencies and app versus desktop. So the big questions, cuz we have to target all the way down to win seven and we need to work on both desktop and the Windows Store. We can't use APIs unconditionally that are only available on Windows 10 or Windows 11. And if we use APIs that are desktop only then that requires special incantations to be. Compatible for store and we don't have great test coverage of either. We always test our stuff on the latest OS and desktop. So that's a easy place to mess up when we're merging changes. Gonna works on a developer machine and then it fails. In this scenario that we don't really test, but we did look into it afterwards and we believe it should be OK. It looks like all the APIs are supported down to win seven, and although Microsoft Docs or Microsoft learn. Has some ominous incantations saying, oh, this is desktop only. It doesn't appear that the APIs are in fact supported for store, so I believe it's OK and worst case, we're gonna hear that there's an issue and involved. Have some if defs or something, but the features a leaf it's not modifying existing code and it's not modifying the DLL, it's only adding stuff to the import Lib for binary compatibility. So I believe the risk should be low. But definitely something to think about. Yeah, definitely. So I'm not interested in the same course for this video review. What I'm interested in is. Look at all the changes first so. More test stuff. You got some stuff moving around. I believe that this is just getting moved from. Girls. Can you also zoom this in as much as you can tolerate? Yeah. I need to start getting and. In this inline as well to me. So yeah, this is all getting moved. So. That's actually look at the stuff that I wanna talk about, which is actual windows stuff. Go to have stream no stream. This is where the ostream in our. And is this includes, we print no for right? I don't know. I'm gonna code different Unicode. Can't .1. Yeah, OK. So these are the two things I really wanted to talk about today. We've got. Thanks. Went to a a stream as well as to. Stood out. Yeah. So. Friends. Tested out is very simply. Print twisted out print to the stream stream. Thanks one. Now and then print one and the only difference is that. Print we pass false to print simple. Mental and passed through different info. Not sure about that, I I. Not sure about that implementation, given that it will basically double our. Conscience for these, and I doubt that it's that important, but still seems weird to have this add new line thing. And if we go here? Different temple. Take a file stream. String. If they have format ARGS. And if we're in, if we pass slash UTF 8 to Seattle so. We go. So normally if you write stuff. And. Hey. Collateral. It will be whatever. Code page you're currently assigned to. So for example for me. The code page is 437 which leave is US asking like extended US asking or whatever. And so so yeah, when it's looking at this file, we'll say. Ohh yeah, frosty it's encoded in. After you are asking. Some extensions. And it'll get put into the binary as. If I put something like you know. Ohgi. Now when the compiler is reading this, this set of bytes in the actual physical file on desk. Doesn't really make sense, and so if we for example print out. You get random gibberish and this is what the bites of this UTF 8 character. End up getting turned into in extended US ask. If you would. If you want. To be able to print Unicode to the console. You can also. UTF 8 to see how. Not like you to fit. And you need a dash. You get the same behavior, however, in the actual compiler itself. What's happening is it's seeing this as a UTF 8. I'm. Nicole, did you? Did you recompile with Slash UTF Dash 8I And. your terminal's too small? I couldn't see what happened. Oh, you did. OK. OK. You see the output is actually the same, because what happens with black UTF 8? This is kind of what I wanted to get to was the compiler. Generally what was happening is it was looking at this file it was saying. Ohh yeah this is. You ask extended. Thanks. We're going to take these fights in US Skies ended, turn them into uniform. And then when we're writing out the binary, we're going to take those Unicode characters and write them to disk in US. Asking extended because by default it just uses this, you know. Edge. 437. When I and then when the when the thing runs, what happens is. It. It's a very it's like these three different things that are going on when the thing runs. It then takes this stuff in US apps get extended and writes it to the console in US ask. Have you ask ask you extended? And so. In order to actually write Unicode characters in the console, what you have to do is change all three parts. Your. So first you have to make sure that the compiler is reading in UTF 8. Then you have to make sure that when it writes it back out, it's writing it back out and you TFA into the actual, like, executable binary. Why you really when you write it to the screen? You have to make sure that it's being written to the screen. Unicode characters. This does would print dots is it takes care of that final piece. It says. We've got this V print unit code info C. We print print no format here. This is what happens. Is we? Where's the dirt steer? Actually happens in. That is the declaration one. Different Tina code console. It's a UTF 8 string. Converts it. The UTF 16. Then. Note that UTF 8, UTF 16 string to the console and Windows treats UTF 16. Always Unicode. You can always write whatever you want. Entertaining, you know, code thing. And so if you're using print, you have UTF 8. And you have UTF 8. And the binary. Then we can take that and at runtime. Make sure that the UTF 8 comes out as the correct Unicode characters on the console. This is all very confusing and has a lot of backwards compatibility kind of hide up into it. So if we look here for example. We go, OK. If Constexpr stood is ordinary little literal encoding UTF and we say OK. This is how we check. Go here. This is how we check. That. The. Ah. The string literals are UTF 8. If they are UTF, if they are not UTF 8, actually if they're not UTF 8, then we just do whatever the system does because there isn't really a better way to do it. We just write the bytes to the console and then whatever code page you have is what you get. There is unfortunately not a better way to do this. And ability is. No, that that's how that all works. Separate do you have any comments or anything you wanna ask or anything does? Is there anything that's unclear? Yeah, it might be useful to bring up the the old way of doing it, which is calling the nonstandard Microsoft specific functions that were actually implemented in VS. I think around the VS 2003 or 2005 time frame this is done by my predecessors and I did some archaeology when I joined the team and realized wait, like the CRT has a code path that actually calls right console W much the same way that stood print is doing. If you look for the. Magic identifier oh you 16 text that will bring up the Microsoft docs. It's spelled under score O under score U-16 tax. Yeah, like that. But not stack overflow. Get Microsoft learn. And it's the docs for. Ah. Not this, it's UM. Set Mode Set mode is usually the doc this. Yeah, that one. Yeah. If you look at the second example here, we got this put into the docs once I. I worked with Michael Kaplan to find out how this works. Yeah, this example. So these incantations you need to include three headers. You call this magic thing, set mode file node stood out. Oh you 16 text and then calling wprintf. Note that it's wprintf with UTF 16 will work. If you don't have that magic set, mode incantation doesn't I. matter if you come to W printf with totally valid UTF 16, it will get mangled on its way to the console. Doesn't matter if you set the console code page to UTF 16. I won't work, but with the magic incantation it does. Yeah. Try commenting out the set mode and see what happens. You won't get Koshka and then the. Ideographic characters. Afterwards, it'll just be gibberish. It doesn't even print anything awesome. That's great. Yeah, it used to point to where I don't know what's going on here. Yeah, with without the seven mode doesn't work. That's because I believe, although it's been years, so I might not remember exactly how it works. Without that, even W printf tries to do some sort of conversion on the way to the console. And trying to set the console code page to UTF 8 or 16 it does not help. Umm, only grade council. We can do it properly so that magic identifier or the magic constant used to be necessary and now printf provides a much more modern and portable way to achieve the same result. But ultimately on Windows we gotta call right Console W so that's what the implementation is doing. It's just horribly complicated. I don't pretend to understand it in full depth and I'm very glad that Tyler Brawl are contributor here. Did the investigation necessary implement all that stuff? So this is all. Reading your why wouldn't we confuse things? And it's all backwards compatibility. So however, in the future. If you pass whack I you TF8 to your compilable. And you use stood print, you don't have to worry about any of this because we've got this new awesome way of doing things that does all of the magic stuff for you. Let's actually take a look at this code, which basically we've got. Prince, Prince Alan be print Unicode, be print onion. No. Prince to print temple. You're not like that bull. Add new line, see. So we have view print unit code and pull you print onion code and pull. And that OK, so basically what we're saying is. This print info. Does the check for his ordinary literal encoding YouTube? And then dispatches to either reprint Unicode or V print nonunit. Which is exactly what he printing print. In the Carter, different one. So. In. Ohh. You. Different Unicode info be interesting one getting output string. If we had a new line we V format, the from the string. You know line otherwise we don't add a new line. Really don't understand why this is too functions. Why this is completed? Then we just call stood print no format and you know. Because none of code and pull does the same thing except it prints no format, no non Unicode. We just. Right to the. The stir to the stream, so that's kind of the trivial case. The print no format Unicode. It's like where it gets interesting. This first thing I'm going to comment on this being a template. I don't understand why this is a template. And then Prince? You would prefer to see a runtime parameter. Yeah, I mean it's it's like a A. Yeah, I I would prefer to see like if I knew line, push back and and whack at like. It seems very odd. Is actually code operational idea? So if context. I can I can easily change that as I revise it in response to your feedback. Would you additionally wanna see like an enum class? That's that's the thing I thought about. I didn't end up making that change or commenting about it. But it's a pool. And if we start passing it as like a runtime parameter, it seems reasonable to make an add new line. Yes? No. Umm, you know class just so it's sort of more self documenting. I. You don't have a strong opinion on that, I think. Fine either way. Like. Yeah, I guess the meaning password probably be better, but I'm not like super ******** but that. OK. If you're not opposed, I'll. I'll make that change. And I know Charlie, who is also on the call. Yeah, I I if we had multiple bulls then it would be a slam Preview version. dunk with one bull. I agree. It's sort of, you know, yeah, kind of nice to have, but if I'm gonna change it, I'll do that. So I agree that. Avoiding the template parameter should probably reduce some instantiation duplication, and it's not gonna complicate the code, so that's a great thing to bring up. And this should just become like. Outfit stir equals the deep format and then if a new line push back a new line. Their lives are move. I'm I'm I'm move I. With the final call that makes me happy. Directly instantiated into the. So alright. Looks like the only real interesting thing here is Prince. No format Unicode. This is called in both the print Unicode info. As well as printable. Basically it's saying OK if you're. If you're if you have format orgs, you know if you write something like stood print. Cool. Center. If you actually write this, then we do need to do the beep print. We need to do an allocation. However, if you just write stood print you know hello. City. That's fine. Ohh that's that's great. Well, the VS code terminal emulator being not very nice inside. It works that much. Yeah. So if if we just write the, you know, stood print hello, blah, then you shouldn't get a a duplicated string. They can just direct me. Right. And we do need, we need to escape thing. Ohh. OK. That doesn't make me happy. I think that. It's actually unescaped braces. I could be wrong. But it's because the. Yeah, it's, it's. That if if they haven't given us any four hours, so they they're saying something like Hello World, it's still in format syntax. So if it has like brace brace and then close close those should be collapsed down. So that's what that escape braces Yeah. does. Now function is actually I think it may be is it reverse named now that I think about it it made sense to me when I reviewed it but I think it might be named opposite. Yeah, it's definitely reverse named. It's unescaped really. Yeah, I was reviewing it at like the micro level. I was like, oh, Uh. we should do. Morgan, this condition to make it comprehensible. And I never even thought about the naming. So I'll I'll make that note that it should be unescaped. Have. Have feelings about this? And field. Spelling. OK. And that actually that flows through to all the variables because it's we're not returning an escape still it's returning on escape star. I I can make those changes. That's a good catch. And this is necessary like because the format syntax has us. We we have to handle the double double dot braces. There, there's no way to pass a raw raw string saying no, no, It's. I've I've, you know, put bear braces here and just don't mess with them. I don't want you to do any sort of translation, but it's all in memory. We shouldn't be too slow. Yeah. Technically, we do allocate here. I I'm convincing myself that it's worth it to do this rather than just pass to me format. You'll be tumbling about, OK. So we do actually have to escape the thing. Escape the braces because if you write for example print, you know hello. And this is still 0 characters, 0 arguments, but it needs to actually print. With that. OK, with this OK with this. I'm not happy about that. Alright. OK. So we check if it's an ordinary literal encoding. Then we print no format uniform unless we print no format non unit. This one is boring. This one all kind of boring you care about is this print? No. Format Unicode because this also gives directly goes and print no format. Hello. Love you. So. To print no format Unicode. Look at this code, this is like. Interesting code. This is what actually turns the. UTF 8 input we at this point we know that the input is UTF A. Working so we know that you're code page that you're that you're compiling and whack you TF8 mode, in which case we assume that your car stairs, your your care stars. Are you typing? So. Let us check if this screen cause this stream might be a file. It might be a. A pipe. And in those two cases, we're writing bites, and so we just write UTF 8 to that. However, if you've got a console again, we have to actually. UTF 16 as opposed to YouTube, we cannot write bytes, so let's look in print dot CPP. Don't get Unicode console handle from filestream. Don't discard, which is good. Success returned on error equals to men error success. It's good Unicode console retrieval result. Something interesting, so this can be. The console handle so in. And windows. Pretty much everything is a. Everything passed around as handles. The console output. And then so we're grabbing a console handle. I'm a file star. Now we put in here. In this error. So if we have student error success, the operation completed successfully. This means that. The file star that was passed in. Was actually a console. It was not a file. Found. That means that the. That the that the file star passed in was not a console. Stood when they're not supported. But file star. Doesn't have an output stream that. That means that it's like stood in or something and all you can only take input. Instead, when error invalid parameter. That's broken like you've passed in an invalid file star. So. Look at where this is called. It might also be worth noting that this machinery exists because we don't directly include the Windows headers in STL headers, because they're enormous and enormously polluting, and ideally one would use. That's why we have like Yes. stood win error instead of directly using AD word. We have our own enum and this really morally is astute expected. It's expected console handle and the errors when error, but we don't use it because we were trying to have. A flat sea interface for anything that's in the import Lib. So, oddly enough, while we are the providers of awesome tech, like stood expected, we throw it all away and we go down to the simplest see stuff for our Avi because it gives us the most flexibility. Yeah, it turns out that C++ is not great at ABI boundaries. Yeah, this song. The same ABI spa lot, easier to keep. Strictly ABI compatible. And so you'll see in a lot of ABI libraries that care about ABI. I also work on address sanitizer, and we do this here as well. If you're library cares about ABI, or like talking between DLL. I. Please the boundaries should be seen. Because Pass introduces a lot of. Ways that you can break me back pretty easily. So. Different cases we've got success, in which case it's Unicode console Unicode console. I want found in which case you know it's a file or a. Right, in which case it's not Unicode, and so we just write bytes. It's not supported. Return. That means that there's past instead in or something. And the default. We just throw the the error. Should I have? Is it? Is it not a? I'm going to try and print to stood in. That seems odd to me. I don't know what the on the standard says. Now let's take a look. Actually like to read the actual C++ drop here. But. You print the onion a code. Ordinary literal encoding issues. OK, keep me. Previous strain is a valid pointer to an output C stream. OK, so that's that is incorrect. We should. We. No. Just saying. This is so you're trying to output to an. So your your audio is breaking up. I I didn't hear what you said. I'm sorry. Sorry. Sorry, sorry. OK. To if you're trying to print to an input only strain. It's this precondition. What we do now? As we return. Which seems wrong to me. We don't report an error. So. So in the STL. We we try not to Reis specially don't throw exceptions for preconditioned violations. Usually we ignore them like you just can't Billy preconditions if you do all all bets are off. Silently ignoring them is not as bad as throwing an error, but you're right, it's kind of squirrely. The the closest president is we used to have a case in it was either list top back or deck pop back where if the thing was empty, if the container was empty we just ignored it and that's actually bad tolerating non non standard code preconditioned violating code just by silently doing nothing. That's not as good as having a debug error or something. This should, I think, at a minimum we should probably assert. Umm these are, you know IDL check or still still verify, then we can, you know return or something. But that's a good Yeah. catch. I didn't even realize that. There was a precondition there. And. We want to your father. So. About if it's been a good console or if it's not, otherwise it's an error. Everyone is it's precondition relation. This is also a precondition violation. To be clear. Now one, I wonder what it runtime could cause that. This is like you passed a null file star or a an invalid file You're right. star. Yeah, that does seem like we shouldn't throw an exception. On the other hand, if it's only, I mean obviously no super bad, but if it if something goes wrong in like the internals of the CRT and it returns, you know some unknown error code, it does seem reasonable to throw a runtime error for that. That's a hard question because we definitely don't want to throw for obvious precondition violation. But for runtime errors, throwing his reasonable. And Zack, so it's not supported. Ohh I see what it is it's saying it doesn't have an associated output stream. This is like if you. Whack to know. OK. That makes sense. That's valid. It's just where it's This this is not. going into the ether, so. So we just don't have to do anything, OK? Never mind. OK, OK. this makes sense. So file no returns -, 2 if stream refers to either stood out or stood there, and there is no associated output stream. Perfect. This is not a precondition violation. It's wrong. Never. I think this is just a bad comment. I'm saying. I would like an Excel. I. Thing we can worry about later. And I'll I'll definitely since since I'll I'll rise to response So. to your comments, I'll test that see what happens when we redirect a null and if it goes through not supported then we can have that as a comment. That's a great catch. This this is like the perfect comment for what should be in the the header. So then if it's -, 1. This is our parameter. Otherwise it must be valid, so we get the console handle. Which we can do by reinterpret casting to handle of death OOF handle. Because that was the candle recount. Ohh so it doesn't happen, but that's that's OK. So we get the handle. If it's an invalid handle value, can we get an invalid parameter? You have FD as invalid which. Precondition language. I get console mode. You can try to get free counseling number. I can return value again. If it's not a Unicode console. And our error is not found. OK, fine. Wise we set we console handle to. Reinterpret casted. Council Randall. Yeah, I believe that that's true and the error 2 stood when error success. So the only two we care about is pilot pallets access success case. We return two and found case we return we have you know good console of faults. This is gonna code console. Successful higher we have to flush. Because of this, if the native Unicode API is used, the function flushes the string buffer before writing code. So flush the string. The Flash was unsuccessful. Error. Like to be in a code console. And if it? Was it successful? Throw US system error. Cool. Alright, now the final thing we have to check is stood printing in a code. That's the most interesting part of this. This all this rest of this stuff is just checking whether we should write directly bytes or directly in the code or indirectly I guess Unicode. We're saying, OK. You've gotten to the point where we are writing Unicode. To this works. No. No reason that we're doing this really basic string view allocated string. Stop. For the. Just including string view. This exists because this is being injected into the import Lib, so we cannot drag in stood string and even just dragging in like string view which is provided in the same header is extremely unwise. So we want to not drag in anything that could possibly depend on iterator debug level and the more STL machinery drag in the riskier it is. So this handwritten stuff is lower risk even though it seems like it's unnecessary. Alright, sounds. OK. Now that I'm now that I mentioned that now I worry about So. that graphene break property iterator. Where is that coming from? Is that something that's scary to drag into the import Lib? I didn't check that. And I should have because I have suffered more than anyone should ever suffer based on stuff getting into the input layer when it shouldn't. Unicode iterate. Unless we see, you know, code which of the core hunter. It doesn't claim to be core, it just drags in Yvals core. But if you look at line one, it doesn't have a comment about core there. It does seem that it's fairly minimal though. We might. We might be OK here. The tables are super minimal, I'm pretty sure. Yeah, I think Jack utility limits and sister then are all well, it's these event of course, but limits and actually utility are both. I don't think X utility is EXE. Utility is a big one that's got a lot of runtime stuff. It's got the vectorized algorithms that's 4. super not core. Yeah, it's includes why's age so. Good point. This is not OK. Did Unicode iterators drag it in? What? What was the dragging? What was it including? Was that coming in through the tables? Yeah. And I didn't see the whole chain of. It's coming in from the UCD tables. Ah. It's and that's why you see the tables which drugs and acts utility which drags and. Ah, that's generated. Ohh no. OK. Yeah, that that's a real that's a problem. Yeah, that's sucks. It seems like the cables are just static data. We shouldn't need X utility. What? What are we even using ohh lower bound? Yeah, we we can, we can hand write something there. Ohh boy. Stood up about yeah. I would rather extract lower bound and just have a handwritten 1 here rather than drag and actually tell if we if we got injected in the. This is not a problem. Yeah, this is easy to do. Yeah, yeah, yeah. Or upper bound here. This is not a problem for format cause forehead has like the non the non queries non core header ever. But now we're injecting something into the import Lib for this graphene break stuff and. Yeah. Hmm. Interesting. The whole reason we have the graphene break is so we can transcode in segments of 8K, but I wonder if we should just allocate and just fail if somebody tries to stood print over 2 gigs. That's the other alternative to. And even this winter. You got. When did actually write code like this? Standard library. Sorry, say that again. I was talking over you. Sorry, I just said that I wrote code like this for the rest standard library, so I haven't been. Because I contribute to other people's standard libraries as well. What I really need to do here is make it so that we cannot include anything noncore in the import Lib. We're like one step away from being able to validate that this should be caught programmatically. Let me guess. I had deferred that because we were busy with other things and it's actually kind of obnoxious to untangle the last remain anything in X facet, but this is an indication where we really need that validation. I'll have to think about that. We definitely need untangle. This quested print. This is the We just. most significant issue. Add the defiant that this allows. Now the problem is I'm currently X facet is including a non core I'm 4 headers. header. In theory it's not doing anything bad but trying to add that compile time block will break it. So that's why I backed away from doing that. Umm, but I I should try again. In theory it should be intangible, it just needs some work. And that would have caught this issue. So to so to solve this, do you think we should? Try to make the graphene break stuff core. Or should we just? Not transcoding chunks and just tried to transcode the whole thing, and if it's over the two gig limit cause the underlying API has 22 gig limit, just fail. So. But I did OK cause cause I've implemented this code before for rust. When I did was. I basically just. Created and 8192. Right stack buffer. Transcoded. 4009 or I guess it's a 4096 W care stock buffer. I transcoded 4096 cares at a time. If. This is Unicode. If they if they were Unicode then. There is a. Then you won't fill the entire buffer. Alright. Isn't that big video kind of a thing so. Actually. I don't think I understand how that avoids the problem that the Is it OK for me to? Yeah. graphene back iterator is trying to solve here. So. Can we look at my Rust code actually cause this? Might it might explain it better if I. I show what I'm actually trying to explain. Ohh, how is it licensed? I kind of don't wanna see it. I think it's. T Apache. I would. I would prefer not to put it on this video or to see it myself. Keep my brain clean, even if it theoretically is possible. Yeah, I did write it. Yeah. So so the issue I do know a little bit here because I I did So I wonder. test this, this is that the graphene break iterator is Yeah. trying to solve is that UTF 8 can be up to what was it 4 bytes. Yes. Conclude to you know, encode any you know code point. Or is it 6 bytes? No, that's four. And we don't want to try to. Break on. 8192 bytes if that's gonna interrupt a UTF 8 segment, we need to stop and do only whole code points at a time. I'm sorry, code unit code points. I'm I'm confused but. Code points, code points. Points OK. And so that's what this iterator does is it knows those So I'm gonna. I'm gonna explain. I'm gonna explain. boundaries. Explain a little bit so in Unicode. Units. I'm sorry, code points. Being number assigned to a specific. Character. And so they are the minimal. Like. Element. I've a piece of Unicode text. So code point is that unit. So for example if we look up smiling Kitty. There is an example in the in the repo. If you look for it. Is there? Yeah. Look for under score emoji and you'll find the test code that has the the escape. Just don't do a whole word or case sensitive. Yeah, there you go. OK, so this X1 F 408 is this little friendly Kitty? So this little friendly Kitty is represented by the number. Hacks 1F408. So the code point. As you plus. 01 after 408. OK. No. In order to store Unicode, we don't generally want to store. They 22 bit number. Ohh Unicode code points are 22 bits. And the smallest power of two that you can that that can store that is 22 and so UTF 32 is the standard for life. I just want a thing that can hold a single code point that's called UTF 32. This is the rust terror type, for example, is a is a Unicode codepoint. But you have to. Then if you want to store it or to write it to a screen, you need to either have it in UTF eight which. Every unit of UCF 8 is event. Or you have 16. Whichever unit of UTF 16 is 16 bits. And if you look at the lines above the comment you just So. added, those have all three representations, the UTF 8, the 16 and the 32. They're all there. So thanks for the reminder. I gotten confused between code points and code units. Yeah. So we're seeing here. This code point if we wanted to see it in UTF 8. Would be the bytes F09F9088. And this is basically this is the initial character. An F0. Means that there are 4 units. In this. You look at the the binary, it's zero B 11110000. This says OK first. This is the start of a UTF 8. Code. This code unit starts in UTF 8 code. Right. There are four ones, so this is 4. It's wrong. The top 4 bits. I've been code point R0. Next one is X9, so would be 0B. 010. These top two bits say ohh I'm a continuing code unit. And then the next 6 bits of this code point are 01. 111. This is saying OK. I'm 4 units long. My top four bits are. Right. Orbit our 0000, then 01, then 1111, then 01, then 0000, then 00, then 1000. So this is how UTF a code units get turned into a code point. Similarly here this is the UTF 16 representation of the exact same thing. So what we want? Is. Here. Can't break property iterator. We need to find a pointer to the last valid code point. And Twitter. We need to make sure that when we're converting from UTF 8 to UTF 16. We don't attempt to convert. Up to the middle of a code. Right. So we have, you know. Zero X 11000000. That means that's a 2 by code unit code point. We don't want to only have that one at the end and then miss the remaining parts of the code point. The remaining units of the code point. And so we need to find. The final. In code point that we can actually like convert. And you make sense. Yeah. And I think also based on the comment, I think this is actually doing something even a little bit more fancier because it's talking about characters that consume more than one code point. And I think that's like combining characters where you have like C and then squiggle and then accent and stuff like that and write console W wants to see all those at once. So I think if we do any sort of partial convert and print some convert and print some loop, we do need this iterator. But if we do it all at once, I think we don't. So that's basically my question for refactoring this code is should we try to make the graphene big property iterator totally? You know, core freestanding ish? Or should we just throw it all away and say we can just do the conversion all at once. But if it's over 2 gigs or whatever, then just we fail, which seems highly unlikely that somebody would try to shove that through stood print. In theory, it's should work, so I guess. Investigating and seeing if we can eliminate the X utility dependency is reasonable. Certainly a probably be less invasive. I guess I could try that first, but I was wondering what your thoughts are. So. Explain a little bit the difference between those Griffing break property iterator and what we might consider like a. That's good. Point is that you can have multiple code points that combine together to create one graphical character on the screen. So very obvious one is. If you do. Let's see. OK. It's on my keyboard. Let me switch to. See. So if we have a. In with a acute accent, there are two ways to represent this. In Unicode, you can either represent it as E with acute accent. Which would you know, I said it back to English because I don't know this keyboard very well. 3E. Yeah. Thank you, accent. And that would be one code point or you can do E and then acute accent. Two code points with this code is trying to do is trying to make sure that we don't break. Being code points that form the same character. My question would be. Do we need to break? Do we need to make sure that we don't break between 2 characters that form the same code? Then from the same wrapping. He like, did you test and make sure that we couldn't write console down, WWE write console W combining acute accent mark. So so I tested a different case because I didn't realize that it was the combining character case that we really cared about. I tested the special the new emoji like Black can't that uses the 0 width joiners. You know, cap and then Black Square with a 0 withdrawing her in between. That should be displayed as black add emoji and this code correctly handles that regardless of exactly where that 10 byte sequence appears on the 8K boundary. It gets printed as a whole black cat emoji, but I didn't test the E with the cute accent. That is a good question. Expect is that you could just print the first part of the graphene cluster and then the second part of the graphene cluster. I would actually be surprised if that would work, because right So that's my question. console W if you gave it an E and you say just print this E it's gonna print an E and then if you give it a free standing accent and you say print this, I think it's not going to go back and try to update the character it already printed. I think that's going to fail. So I think this graphing break. Is necessary. Yeah. Yeah. Then this means that the rest of the library has problems with it. So let let let's try this. So don't be TWC. Making calls. Or. Better. He. Finally. This file format website is very useful for stuff like this. X301, right? Yeah, there we go. We write console W. Handle you see. For characters writers too. For characters written. This is see. That was not see, OK. You know doing wrong here. I think you need to look at the right Council W docs. I think there's a function need to call to map that stood out. We'll handle constant to an actual handle. I am not a Windows 32 programmer and this and this PR I I joked Yeah. before they we started this review that I overhauled the test code to use Windows semaphores and that is the most I've programmed in the Windows API the long time. Most of the time I see response but platform specific. That's it handled. It's good handle. Yeah, that's it. Take some man stood handle. You're looking at a set, not yet. But I'm looking at. Thank you. You run this, we should get. No. Now. If you do it one at a time. Here we go. We do get it. That's what I thought would happen. That's very interesting. I have supplied that that works. So you do not. Yeah. So you do not need to do the graphing break code. That was when I was tracking. This this says to me that we can do the far more simple case of going to the end of the string. Are going to the end of the 8192 bytes. And then popping back until we find a. At the beginning of a code white and use that as like the end pointer. Does that make sense? Yeah, because we we can recognize the boundaries between UTF 8. Reckon you recognize the boundaries between code points and UTF 8 stream without caring about exactly where we are, because the the values tell us whether we're starting a new one or not. That's very easy to do. That is, that is interesting. Does write console W say anything that this works because I'm I'm a little nervous about depending on the results of 1 experiment. If the documentation said it could handle it, I would feel better. It probably doesn't mention it though, because this is pretty obscure. It does not say anything about graphemes. OK, silent, interesting. Point clusters. Sure looked like it worked though. Yeah. So we should do more testing. Yeah. Staying but it seems. I mean, we could do simple search back for the beginning of a code point. There time. You can have a graph you. I am still tempted to just say. Go back. What if we don't break it into a K segments? And what if we just do it all at once? Because the the whole reason I think we were originally avoiding this is because we wanted to lock, but then we decided that we don't actually need to lock when we do this. So I wonder if the the argument for breaking it up into a K segments and still holds. So the original reason that we did this was because I didn't like that we were. Doing allocation. I wanted us to do it in a stack buffer. Taking an 8K stack buffer or something? Because that's how I implemented it. Erupt, basically. Hi I'm certainly allocating a slower. I think we're already allocating in many cases if we print the new line because that stood string. You're right, it's a potential performance issue. The thing is, if we're physically writing to a console, I wonder, I really wonder if it matters because the console performance, I mean, they've improved it, but I think that's gonna dominate. I haven't profiled this at all, but I would be very surprised if Yeah. our allocation were the limiting step in like physically printing the console also. If you're physically printing to the console how many like you know gigs, can you print before it just scrolls by too fast for the user to see? Like at that point you redirect your file anyways because you don't wanna, you know, have the console printing slow down. So I wonder in that case because we're actually displaying stuff to the user if it matters. Whereas if we were, if this were on the print to a file path, we Yeah, that was. were could run completely headless, then yeah, yeah. I would be like, OK, we don't wanna allocate. Yeah, my my feeling is kind of like. If you're printing more than 4000. Caracteres to the console. They don't care about your health case very much. And. Like. Will be smaller amounts that we're that you print. I would rather not allocate. So like if you just do it in 4K chunks. You can 2K chunks like it's not a big deal. Especially because we don't have to do this graph being clusterization. I would rather not. Rather not allocate whenever possible. I think it's a reasonable The thing is, the code has already written so slightly adjusting it to use the simpler technique of just finding the next UTF 8 boundary, which we can detect with a simple it's arranged test. I just need to look on Wikipedia to see what the value is. Yeah. That would be that would be simple. Checking right thought test really really like you. Just you just search for the last character that has either the top 2 bit set or. Not the top bit set. Yeah, that can be done with handwritten code by effectively. Either. Either there will be 0 XXXXX. Or is there will be 1/1? That's all we care about. We need to find one of these two characters, one of these two. You know that now. We come in my. OK. We're doing a bunch of transcoding multiplied twig car. To beat you today. Yep, that makes sense. It string Yep. Yeah, this is the accounting number occurs required. It's the number of character required is greater than. Gratian string dot capacity let me reset it. So we all allocating in this case. Right. Yeah, I don't believe we actually use a stack buffer. We use the the allocated string. Yeah. So we're basically saying, OK, we're going to allocate. Shut down. Up to 8192 and it's The thing is a big tracking thing, then we'll do random stuff, but we don't need to have all that stuff. So this is a lot of complexity basically. Which will go away once we remove the graphene clusterization style. Well, I think that I think all that complexity will stay. It's just the graphene bit means that the the step define the boundaries simpler, but we're still doing in chunks, so it still needs allocated to stir. This doesn't sure that the user comes to us with like a mega text. We simply reuse the same 8K buffer. So after the first allocation we are non allocating and we can reuse it. So that's nice. Yeah, that that's definitely true. But on the other hand like. What's happening is every time you call print, you get a new allocation. Already do get an allegation. It's not make me happy, but we do do an operation. Broke for a SEC. One SEC. Ohh but like the this checking for. This if it's greater than capacity, we do not need to worry about this at all. I don't think. Now we do cause it starts off with new capacity I believe. No, I see what happens. Yeah, this is trying to avoid like allocating 8K every time but. It it doesn't need to allocate. So I think. The only other comment is I would like this to be a stock buffer. The thing is, like I would worry about that we we try to be pretty. Conservative in our use of stack space because we don't know how much is available. The user could already be in a pretty deep call stack by the time they call the STL, and if we overflow the stack, it's unrecoverable. Umm, the the largest things we have in the STL like the random number generators which are like 2 or 4 kilobytes. I forget how big and that's unavoidable from version twist or and in CARICOM I had literally no choice but to use a stack buffer cuz we physically cannot allocate now we're no fail. So there I had to use like a one KB stack buffer and I felt super bad about it because I was like I don't know how close we are. But that that was like the upper limit. AK is a lot. I don't. I don't think we can do that. It seems risky for a potential optimization. The thing is, I'd rather keep what we have now. Because we can revise it in the future if we find that performance is an issue, the internal usage of a buffer here we can change that without other code needing to care because we're not passing it across functions. So I'd kind of rather stupid for what we have and then if we profile and we're fine, Right. this is actually problem. Somebody calling stood print with fairly small strings. Then we can go back and say, well, what if we use like a 1K buffer and then if it's over that then we allocate you or just something fancier but. Yeah. We refer to avoid starting with a big stack buffer. That seems like premature optimization in a way that could decrease reliability. It OK, so the one thing I will say is that. This. Probably doesn't need to exist like like what we care about is. At work we can allocate. Enough always, because we know that the size and W cares is always. Points that are equal to the size in careers. So we could just allocate the number of terrors. If that makes sense. Oh, I see. I see what you're saying. Because it's a, it's A at most a constant factor more. The the question is, does that actually save anything because the initial allocation is? A could cause we're we're doing it exactly. So you're saying we could have a case where the initial string is 8K occurrences of a? Yeah. No, no, the opposite. The initial string is a bunch of big emoji that. Consume. You know, they're like, you know, 4 byte each or something. And then so we we say ohh we only need 2K W carts. No, we've got the uh the combining, they actually use surrogates. OK, so the case, maybe it might may not be as simple as that, but it's the initial stuff is all. So we have a bunch of Chinese text that takes up 3 bytes in Yeah. UTF 8. Yeah, and then collapses down to smaller UTF sixteens. And then And takes up. next one is all a bunch of ASCII A's that do need the whole 8 case that we do 1 allocation and then we discover we need to resize. Then we hit the high watermark and anything beyond that we can reuse the allocation. So that doesn't seem like the end of the world. The number we're actual reallocations is fairly small. It does seem like just allocate a constant factor more the promise that stood string insists on initializing everything. So if we allocate more than we need, we actually initialize all that stuff to 0. At least the first time. Which seems also in desire. You're not using stood string. Yeah. CRT unique. He put her don't way. Yeah, we Malik. And then we Yeah. move. And then I think it scribbles a null Terminator. Yeah, that's a good argument in favor of just allocate a little bit more than you need. So you're saying it's? N right, because you can never have more WRT coming out than care is coming in. That's compelling. That's only a lot simpler. Yeah. I could be convinced of that if we're going to allocate then. Make it a little simpler there. Yeah. Because like, it's not. Not much more. I mean, actually, I would argue it's probably not at all and more expensive to allocate. 4K or 8K then it is to allocate 4K2K. You're still allocating a page or two pages or whatever. Yeah, right. But other then then this really like if we're gonna simplify that, then they're really pushes me towards. Let's just do the whole conversion all at once. Like none of the same case stuff. Throw it all away. If we're gonna allocate, like just allocate. Enough space to convert the users whole string and then later maybe go optimize it. With, you know something fancy stack, buffer, whatever. But what do I basically worry about? Is the OK, I could change the code to March backwards a bit and find that UDFA boundary, but that's introducing more risk if we do the conversion of all at once, then we know that if the basic stuff works, all the complicated stuff works too. And but I'm getting nervous that we're rising at the PR's logic close sort of to the end and. Going with something simpler seems even if it's a bigger code change, it's gonna result a lot simpler code. I think I'd prefer to do that because either way we're gonna allocate and for most things it doesn't make a difference like user gonna come to us with a string that's a few 100 bytes, or maybe a couple K like in my testing, 8K is already a whole page that's already pretty big, so I think there's gonna be very little difference between do it in aka chunks versus do it. All in a single step, and that will dramatically simplify the code, which is I think what we're both worried about. I prefer to do that change. If you're OK with that. Yeah. I'm gonna that I think. I would be certainly down if somebody brought in. This kind of optimization back if they show a use case for it. Or if they are somehow writing more than two gigs to the console. But but yeah, I think this is reasonable. Yeah. OK, cool. Yeah, certainly, yeah. There's an optimization PR follow up that uses a benchmark and we definitely be open to that. But the most important thing is to make sure that we're not going to paint ourselves into a corner with an ABI or something in the import Lib that prevents us from ever making this better. We could worst case is we would need to retain the existing stuff as is and add something entirely new to the import Lib a V2. Which we could do. I I am happy with. I would be happier if this allocation stuff was. I would be happier if the allocation stuff was not on the ABI boundary like. This is an API boundary. It is an internal API boundary. I guess we could make it transparent UTF 8 string too. Never mind. Never mind. We can do transcode either 8 string 2. No, it's. Yeah. And importantly, this is in an unnamed namespace. If you look at it, it's not marked with an explicit calling convention. That's actually one of the revisions I get, so this is fully local to this TU yeah. See this allocated string stuff. It's all the unnamed new space. The only ones that are on the boundary that are actually linking to user code. Those are marked stirred call, and they're just like the right Unicode console. Whatever. This does not pass any allocations back and Perfect. forth to the header. Yes. I just fixed the conscire. Star says. I'm gonna go print it to the console somehow through magic, and we do all the allocations internally. So I think that is a good firewall. We're gonna be ABI safe. Perfect. I'm happy with that. I think that's the only thing I have left. I just wanted to. The the real the real meat and potatoes of this is I wanted to explain to people how Unicode stuff on Windows worked. And how Unicode code points work and I think I succeeded in that. So hopefully y'all, who are watching enjoy this. Semi code reviews Sunny look into Unicode and how it's printed on Windows. Thank you so much for coming to the VC libs Open code review and I'll. He also.