WEBVTT OK, welcome back to another VC libraries Open code review. I'm Stefan T Lawhead and still maintainer. And today we'll be looking at a PR that will convert template metaprogramming in our ratio header to constexpr functions. So as usual, starting off looking at our repo and I'll show you how we track work. I'll go to projects. We use a code reviews project. These are all of the PR's. That are awesome contributors have submitted for our review, so I'll just make that full screen. They go through multiple stages of review. The one we're looking at today is in initial review state, meaning that maintainer needs to look at it. Once approved they move to final review and once 2 maintainers have reviewed a PR it moves to ready to merge. This is a good way to catch issues before they get merged into the repo. I'm going to help educate all the maintainers as to what's changing in the code base because. One of the most important things we do over the long term is spreading knowledge about how the code base works amongst uh both maintainers and contributors. So here's a PR. I'm opened by Sam 20908, so I will look at this PR. This is once it loads 2450 ratio. Use constexpr functions instead of TMPS template metaprograms and this fix is an issue we had filed labeled as throughput. We may want to relabel the PR. We like to have the issues, uh, match the PR's. In fact, I'll probably go ahead and do that. This is a suggestion, um, possible enhancement that our contributor Alex Soutenu V filed back in October and he observed that we use particular style of code in our ratio header. So I'll be going over how this works. It's written with struct template metaprogramming and we now have constexpr functions that are in general. More readable, Umm. And possibly higher throughput. Uh, throughput meaning um, speed of compilation, um. Although it remains to be seen whether um, context or functions will actually have the promised throughput improvements, but in theory they should because they're just functions compared to instantiating lots of structs. One of the fun things we get to do as library implementers is after we write all of the code that the standard forces us to write. We add it to the headers and then users complain. Um, they say, hey, you know, we were just compiling our code, and then we upgraded and we didn't start doing anything differently. But now our compilations are slower. And it's because the standard told us to add a bunch of code to the headers. And if the user is compiling in a sufficiently new standard version, well, then all their headers gain extra code and it's slower, and they're now paying a cost for benefits that they're not yet taking advantage of. So that's kind of sad because we can't do a lot about that when the standard. Requires us to add code. We do have mitigations like we only enable code in new standards modes. Um, so if you remain compiling in C + 17 mode, you're not going to see all the C + 20 stuff in general. But if you are compiling with the newer standard mode switches or C Plus latest, as we add new code to the header, stuff gets slower. Partially this is compensated for by. We find ways to make the libraries faster to compile through issues like this one. The compiler itself also implements lots of optimizations, and in general computers get faster over time usually. So it's sort of, uh, we win some, we lose some when it comes to throughput. So hopefully here we'll be getting some throughput improvements. Another reason to do this, even aside from the throughput, is readability. This struct template metaprogramming technique is not the most readable. So before we get into the PR itself, I'd like to cover exactly what we were doing in ratio, why we're doing it this way, and then we'll take a look at the actual code and see if this is preserving correctness and hopefully gonna have some of the readability improvements that we're hoping for. So let me open up our repo. Here we go. I've got everything, uh checked out here. Let's uh look at the ratio header. OK uh, I've just opened up um our OS repo. Umm. In VS code is workspace, so I can hit control P and type in any file name. It'll take me there. So here's the ratio header and I can also open up the standards that this corresponds to. You could also look at CPP reference if you wanted. So if you weren't aware, uh, we have covered it in um, some previous code review videos. Um C plus and C + 11 has had headers called ratio and chrono. Chrono actually contains a units library. The the units are only for time, though it would be nice in the future to see it extended to other units like meters and kilograms. But just having units for time is still plenty powerful because one of the things it can do is have units like seconds, milliseconds, nanoseconds. That are convertible. Um, and this is embedded in the type system, so you don't need to just have like a raw like 1500 representing 1500 milliseconds. You can actually put that in a variable of type stood chrono milliseconds. And if I could find duration, no, I think it's in the header synopsis trying to remember where everything is specified. Here we go. There's some convenience type depths, so in the Chrono header a type like stood Chrono nanoseconds is a stood chrono. Operation templated on some signed integer. It's actually long long in our implementation, and then something called stood nano. So you might ask, OK, well what's a stood nano? That comes from the ratio header, which is specified in clause 20 General utilities library compile time rational arithmetic header ratio. So this is a header in the C plus standard that you could use directly if you wanted, but in practice it's generally used through the kernel header and this encodes a compile. Time ratio as template non type arguments, meaning here just integers to a otherwise empty struct or class. So here if you have ratio of something like 5 comma seven that encodes 5 sevenths 5 sevenths in the type system and the ratio of like stood Millie. There's some type defs down here is a ratio of 1 / 1000. So the formatting looks strange because the standard has tried to line these up pretty nicely. I'm not sure exactly how much that buys and so a ratio of nano is 1 / a billion. And this allows us to do things using these helper variable templates and structs like ask or two ratios equal. Can we multiply 2 ratios? Can we divide them and add and subtract them? And these are needed when we do things like conversions, so when we convert between Chrono durations. For example, if you want to convert from uh let's say microseconds um to milliseconds. Actually, let's do it the other way around. Suppose I want to convert um 5 milliseconds to microseconds. I should get 5000 microseconds um. So I gain a factor of 1000 and we get that by using ratio. I believe it's divide we can divide. Let's trying to avoid trying to think fast to avoid getting things flipped. If we divide Millie by micro, then we'll get the value 1000. Saying that there are 1000 micros in a milli and then that's how much to multiply our stored number of milliseconds by in order to get microseconds. So we get the type system to perform all of the conversions for us. I mean it all compiles away so we don't pay any runtime overheads, but we get compile time type safety and then we can do things like the kernel library was designed by Howard Hinnant, the proposer of the original library. Um, such that we enable conversions and Chrono only when they don't lose information. So you can losslessly convert something like seconds to milliseconds. If you have 5 seconds, that's 5000 milliseconds. But we do not implicitly convert the other way around. If you have 1500 milliseconds, if you try to convert that to an integer number of seconds, that would be 1.5. But we would lose that .5 as an integer that would lose information. So we don't allow that sort of implicit conversion. You have to either do so explicitly saying I want to truncate, I want to round, floor, seal, we have all those helpers now um or um you have to use a different type like. Duration using double if you want floating point durations, which have their own hazards, but that's a topic for another. Code review. Uh, uh, we'll, we'll talk about floating point plenty. Um, so with ratio um, how do we implement all that multiply, divide, add, subtract stuff. Let me switch over back to VS code. So in our implementation what it looks like is ratio is templated on NX&amp;X. As an aside, we. Uglify as we call it our internal identifiers to avoid being, um, stomped on by macros or conflicting with user code. So names of the form under score capital are reserved for the compiler and library. We conventionally avoid names of the form under score followed by a single letters like under score N This looks too much like a macro, so even though we are permitted to use it, we add an extra letter. So that's why you see an X purely an internal STL convention. Other implementations might say something like double under score. Uh, because that's also reserved for the library. But uh, we used under score capital generally, so that's why you see this sort of ugly code here when when you've been either maintaining or contributing library for a long enough, you're brain just starts to ignore all those under score capitals. And it actually lets you see what things are intended to be usable by users versus for internal use only. And then when we need to implement things required by the standard, for example, the standard says OK, ratio can be templated on a numerator and a denominator. But there's nothing stopping the user from asking something like um 10 / 20 um. But the standard requires that ratio is nested, um, static constexpr Max T NUM, meaning numerator be reduced. So this needs to be a reduced sort of normalized or canonical form of the ratio. So we need to compute that and we do so at compile time using some of our compile time technology here. Right now I'm looking at the repos main branch and not the PR. So we've got some logic that deals with the signs because. The standard requires us to Umm. I believe if the denominator is negative we need to move that negative into the numerator. I'm speaking from memory that I could check the standard itself and we also need to reduce the fraction. So if you go remember your math lessons, we can reduce fractions by taking the greatest common divisor and if we have 10 / 20 the GCD of those is 10, so we can divide both of them would get 1 / 2. O. We implemented in our current repo the greatest common divisor with a struct and the reason why we did that is we implemented this. Trying to think back this. The Chrono appeared in C + 11, which is also when Constexpr appeared. But in C + 11 constexpr is highly limited. It was possible to write things, but you could only have a single statement, so it made it very difficult to write most complicated functions. It wasn't until Cplus fourteens extended constexpr, which we now just think of as playing constexpr functions, that it became possible to have things like temporary variables and multiple statements in context for functions, which actually makes it a lot more usable context grown. Dramatically in power over the years? Um. So when Chrono first appeared, um, we weren't yet really able to use constexpr functions for a lot of things, so we continued using the original classic technique. Usable all the way back to C + 98 of having structs do template metaprogramming. Not because we liked using structs, but because it was the only way to get things done. So here we have a helper struct, and this is all internal because it's you can see it's all ugly names, so this will compute the greatest common divisor. Using the classic Euclidean algorithm, we've got some special cases or base cases for what if one of the values is 0? And we can use the modulo operator on the non type template arguments. So this is how we had implemented GCD originally. These names here maybe not the clearest names, but we have an internal helper GCD X that is then used by the more public but still internal under score GCD struct. Here we've got some additional extra things happening here and this will be relevant to the PR as we're looking at it. Sometimes we need to forbid overflow so in some cases. We need to add together um, uh values at compile time, but we don't want them to overflow, so we actually enforce this using a static assert. We have a struct that takes an A and A/B to add and then we pass it to an internal helper safe add X. And here what we say is if the signs are different, that means we're adding negative to positive or vice versa. So that can never overflow, because no matter how extreme the values are, adding a negative to a positive or non zero um, can only bring them closer together to 0, so it's definitely not going to overflow. But if they're both negative or both positive, we need to worry about overflow or going to negative. Also consider that an overflow. So instead of actually performing such an addition and then discovering oops, it overflowed, which would be undefined behavior, we ask without overflowing if they would overflow. So we have to phrase it in a very specific way. The absolute value of 1 is less than or equal int Max minus the absolute value of the other um and then uh. Here in safe add X only if. We can determine that the uh operation will overflow. Um, will we actually perform that plus? But if we see that the signs are not different false, and that the addition is not safe false, then we can detect through a struct template partial specialization that the addition would overflow. That's what this comment here is saying. And then we can simply static assert. As an aside, instead of simply saying static assert false, we can't do that. Because, uh, for the arcane and kind of annoying reason that if we said Static cert false, the compiler would be perfectly justified according to the standard in saying as soon as it sees that template definition, oh, you've got a static assert false there that can't possibly compile. I will reject that on site without even caring what A&amp;B could be here. We only want the static assert to terminate the compilation if this thing is actually instantiated, so we need to sort of delay evaluation of the condition. We've got this helper always false. That is a variable template. Unsurprisingly, is always false. But the compiler doesn't know that. Um, that we never bother bother specializing this to have any other value. So if we phrase it as static assert, always false, and then give it some template argument, in this case the struct itself, the compiler will only activate the static assert when this template is actually instantiated. And then we say integer arithmetic overflow. So this is how we basically do an if and then terminate, but in struct template metaprogramming. Sometimes Umm instead of terminating um we want to um trigger sphene, meaning that um in Chrono we are required and some points to make a conversion disappear if it would overflow rather than emitting a hard error. So we do not want a static cert all the time and that's why we have this bool here. If we pass false then it will trigger an error, but if we pass. True it, we're saying we need this for the purposes of sphene um. Instead, we'll harmlessly absorb this attempted overflow and we just won't produce an integral constant answer. And then that will go off in sphene. So this is a very arcane implementation detail, but it is needed for the purposes of Chrono. It's not exposed in the ratio library itself, which is why this is purely internal. There's no way using the ratio public interface to do something like I want to multiply or divide these two ratios, but if it would. Integer overflow? Don't do it. Just not have a type def at all. Um, arguably, perhaps that should be publicly available, but it's not. So we need to implement that, but only internally. So this is what I'm template metaprogramming in, in the form of structure look like. We're sort of encoding things like if statements and terminates and conditions, but they all have to be phrased as things like partial specializations, explicit specializations, default template arguments. And this is not very readable. I mean, I've been doing this for over 10 years and I in fact I wrote some of this code here. And even then I need to look at it and then think really hard about, OK, exactly what you know. Are we doing here? Um, what are all the possible I'm conditions? We're detecting exactly which things get instantiated. It's a lot of work in comparison to constexpr functions, because when you write a constexpr function, you get to read and write ordinary C code with if statements and local variables and all that good stuff. So now that we have the full power of CPUs 14 constexpr and beyond, C + 14 being the lowest supported standard mode that we have. Uh, this enhancement issue is about converting this old codes over to something more modern. Um, but preserving all of the stuff we have here about defending against overflow, spinning when necessary, and so forth. So that's the background there. Now let's actually take a look at the PR. So here is PR 2450, a lot of background for only 30 added lines, 27 removed or edited. So let's take a look at the files. I'm going to Alt Click to minimize. So these are changes only to the product code, Chrono and ratio not changing any of the tests under the theory that the test should already have sufficient coverage. I believe they do. We added, I believe pretty good coverage of the Kronos Phenax and I think we've got. Um, some coverage of the ratios we could actually look uh, one nice things about having the STL in Workspace is I can just do things like search for ratio and ask. I only want to look at our tests so I can say, Umm, tests and then we have stood. And that's getting corporation, which is hilarious. So I could ask for whole word, or I could use a regex to look at boundaries. OK, so we've got a test. This was a test for a regression test for bug. It was in our old internal bug database. That's the number. But we've got tester, exercising, ratio, add, subtract, multiply, divide. Make sure they're equal or not equal. Let's make sure that the ratios are reduced. Um, uh. In some specific cases, like ratio add um, we need to return a fully produced answer. Um. So we've got static certs for all of these, so this is some good coverage. All the uses of Chrono are also covering this. Including our calendars and time zones, the new tests that we've got. So I believe that the test coverage here is good. Certainly if we find deficient test coverage, we can always add it in the future. But for this PR, I'm OK with it being product code changes only. Unless I see something that looks very concerning, then I might want to go verify that, OK, we have test coverage for this. OK, so now let's take a look at what's going on here. The changes to kronor small, we had a least common multiple helper that's being converted to a constexpr function. And then being used in the common type. OK, but that uses the GCD function that's being added in ratio, so I'll look at that later. So let's look at ratio. Uh, let's see. We're converting ABS over here. I'm just scanning real quick to see what's happening. Um, some discussion between uh contributors Misco and Sam about what safe ADX is trying to do. I'll look at that. OK, so this looks like a fairly one to one conversion, but the diff is looking somewhat horrible because, um, the diff algorithm is picking up the empty lines that used to be between the struct specializations and isn't matching them up to the empty lines that are within the function. That makes things actually pretty hard to read. The rest of it is OK to read, so I'm thinking even though I don't usually like it, I'll switch to split view. I don't think hiding white space will help. OK, this is hopefully a bit more readable. OK, let me minimize this. OK. Let me Scroll down, look at this real quick. OK, yeah, this is, um, easier to follow. Uh, because we don't need to look at 2 interleaved, vastly different implementations. OK, so now I want to verify, uh, looking at the old code in the new code that all of the behavior is being preserved and that we're not losing any special cases like what about overflow and so forth. Let's say, oh, I can answer questions from Cameron, he's asking. I assume that the still doesn't care about cling CL supporting the standard mode of stood supposed 11. That is correct. So the we support the claim compiler which actually ships in Visual Studio. An optional thing you can select in the installer as a first class citizen, meaning that we support it for both the compile time and codegen, and we tried to support as much as possible subject only to you know, the features that it supports itself in the compiler. Sometimes we even support it better than MSVC itself, it depends who implements core language features first. However, our STL considers MSVC's standard modes as a minimum, so. With the MSVC compiler stood, C-14 actually means C-14 plus all the C-17 stuff we had implemented at the time that we implemented standard mode options in the 1st place, which I believe was VS 2015 update 3, if I've got that correctly. We do not have support in MSVC or in our STL for ACS Plus 11 only mode. We will support down level disc plus 14, but as far as we're concerned that's where time began. So although the client compiler itself supports AC plus 11 only mode RTL, the Microsoft STL does not make any attempt to support that. So yeah, so you'll see some things here as camera noticed um, that are not allowed in CS plus 11 only code. I, I for 1:00 AM very glad that we have C + 14 has a minimum because going back to C + C + 11 would make constexpr very difficult. If I ruled the world, I would make you know 6 + 17 or 20, the minimum. But there are good reasons why we have support down to C + 14 so that customers can continue compiler and your code without major changes. Uh, OK, so let's take a look at this. Um, first we have the UM simple struct ABS, which is an absolute value at compile time. All this stuff works with the type def from C student or student dot H int Max T That's the maximum integer width in our implementation is just 64 bit, so it's actually the same as long long. But ratio is specified in terms of impact, so that's what we use everywhere here. So the input is in maxval, so in the constexpr function land. Uh, let's see none of this is template yet. Um. Template I I go through a mental list of all the decorators we now functions. Template now template. Static doesn't need to be static. Inline constexpr strictly more powerful, so we do want constexpr. Explicit is only for constructors and definitely not virtual. That's for member functions. That's all good, we use no discard and all return types of pure computation. Not super consistently in old code, but in new code we try to be disciplined about this, so that's why we've got no discard there. That's good. We return in Max T. Because that's the output, so that corresponds here. Um, the function we're going to use the name under score ABS, I believe that's OK certainly we had no concerns about under score ABS shadowing other stuff as a struct name, so as a function should be fine, and we're just converting it over. There's also no one definition rule concerns about converting a struct into a function, so I'm OK with that. The input is a constant maxval. We're not going to modify the parameter in place, so adding cost is absolutely the right thing to do. The functions no, except it's definitely not going. Any exceptions, that's all good. And then the return values here evals less than zero, then negate it. Otherwise return Val unchanged. So exactly the same as what the struct was doing. Great. We're losing comment here. Computes absolute value Val. I'm totally fine about that. I mean it's called abs. Sort of self documenting. This was our old policy of comment. Literally everything here. I believe it's obvious enough that we don't need the comment. So sounds good. OK, next um. So here are the struct is being preserved. Um, this is because safe malt is used by Chrono. I can go find that control shift F search for safe malt, not just in tests. So safe malt is defined by ratio and then it's used in ratio add. And ratio multiply. Uh, ratio multiply says um. I do want to phenate, meaning that we won't have a numerator and denominator um. Uh, or sorry, sorry, safe molt's ***. Sphene. Static asserts fine. OK, yeah, these are true. And then this one can detect overflow during multiplication. Yeah. I can't remember why we passed through here actually. Because this is the. Yeah. I'd have to look up exactly what we're doing here. I'm not concerned for the purposes of this PR since it's not changing this layer, and this layer is necessary for all the spine, like converting all this to be constexpr wouldn't have. A lot of value, yeah, but that's why we're using a struct there. OK, but we do need to convert this call. So ABS ax value now just becomes a plain call to ABX. And because of the magic of constexpr, we can call a constexpr function in something like a default argument to a function template and the compiler will go evaluated for us. So now looks good. I'm currently we are not using constant eval, um except when absolutely necessary because compiler support is still in progress. So even though in theory ABS here could be defined as constant Val, I'm much more comfortable using just constexpr. The difference is that constant Val enforces that any call actually be performed at compile time. I mean is never emitted as a runtime call it. So like if you're in Int main and you call a constexpr function, the compiler is totally allowed to just. An ordinary call to it. But if you call a constant eval function, it actually doesn't need to boil that down to a constant here, because this is internal only, we just only ever call it from context for context. So being constant Val wouldn't really achieve anything. It wouldn't, you know, we could do it, but it wouldn't. OK provide any optimization benefits or anything. So totally happy to see concepts for there. And this just converting these to function calls that's good otherwise it's unchanged. OK next we have a change to sign of which is doing the same sort of thing. Sign of Val was giving an int Max T Now the interesting thing is here sign of is returning either - 1 or one. Not like a bull because we want to do things like. I think we here we compare and I think we might actually multiply by sine of elsewhere I'd need to go. Find that good this morning I saw that. I can check real quick. But emitting uh, an IMAX TV? That's not the right one. under score sign of. Yeah, we do multiply sine of times sine of, so that's why it's in um, uh, one or -, 1 rather than true or false. OK, so again we have a notice card function that's constexpr returns int Max T under score sign of exact same name, takes maxval also accept so same signature and then this returns what we returning before the values less than zero then -, 1 otherwise one. Again, we're dropping the comment to compute sine of Val that's in the function name, so doesn't provide any value, whereas the comments are being retained here. Like computes ax times BX without overflow. These are quite important because it does say like what this thing is doing, like what does safe mean and why is this specialization being detected. But for sign of the function name says everything we need, so that's good. Uh, OK, so now it's time to read this, um, comment from Misco. Misco says Safat X the stack, asserting that it's valid. So I think we should be able to port it over to a function. Um. Sam asked, wouldn't that make the expression nuts? Fineable. And then he asks, um, if the signs of is different. Yes, I agree because if you wrote if constexpr here. That would mandate all this stuff via compile time, and these are parameters, so you can't actually do that. Yeah, and then they then the parameters would be non type template parameters rather than just ordinary arguments. We could phrase it like if bad condition then do something like throw because a a any attempt to throw an exception is an error at compile time or call like. Another technique we use is call a function that is declared but not defined and that will be an error at compile time. But yeah, I'm not. I agree with Sam. I don't see a lot of benefit to trying to convert safe ad over um. Also, this PR doesn't rule that out. We could always do that in the future. Um, here we use Safad. Of this value, this value. And the third one, why do we have three values here? Does this one? Oh no, it's the second one is. Uh. The nominator to ratio, so we only give two values to safe mode. That's right, it's hard to keep in track with all this double coin value stuff. O safad. This one computes if we would overflow. It could be done, yeah, with the throw technique basically saying because the only call to it is in a constexpr context, so we would never worry about like actually throwing in, throwing an exception. Yeah, I I think that could be done later as an enhancement, um. I like uh. I don't think anything in this PR prevents that. Yeah, it it's strictly optional. Yeah, I will comment. Um, OK, let's comment. I believe that it would be possible. To convert. Safe add to a constexpr function but the. Um, overflow. Enforcement. But I believe that the overflow enforcement. Would be best expressed with. If would overflow. Throw. Actually. Um, I think we just typically call a non constructs for function. If would overflow um throw or call a non constexpr. Function. Which is a technique that we've used elsewhere. Um. The only usage of safe ad is at. Compile. Time. I could quote that if necessary. Yeah, I want to do so. That's ratio line 98. So I'm going to bring up our repo. Open up STL Inc go down to ratio. I'd love to just be able to do control P that'd be pretty cool. Um, hit Y to get an absolute link, go down to 98. Here's the safe ad. I'll get the context and I can copy this URL. You can also right click and copy permalink, but I do it that way. Uh, however. Um. I believe that this could be done. As a separate optional step after this PR. I don't believe that it's critical to do now. OK, how's that sound? I believe there would be possible to convert safe ad to a constexpr function, but I believe that the overflow enforcement would be best expressed with if would overflow throw or call a non constexpr function, which is a technique that we that we've used elsewhere. The only usage of safe ad is that compile time pal. However, I believe that this could be done as a separate optional step after this PR. I don't believe that it's critical to do now, OK. OI think that looks good. Yeah, trying to think, um. I would prefer things to be incremental. This is already changing. Like, this is not a difficult change here. It's not super scary. Um, but it is changing code that is used by ratio and Chrono. I'm an existing code, I'm in fact it's unconditional, so it affects even C + 14. So that makes me a little more hesitant to just go wild and change a whole bunch of stuff. I'd rather be a little bit more incremental here when we're writing completely new code. That's leaf code that's not used by an existing stuff. Um, I think it's OK to be a little bit more daring, um and do things like, you know, larger refactorings, more aggressive changes here. I think that doing sort of a limited conversion of ABS sign of and GCD is a good start and then later we could continue converting. It's sort of doing it from the leaf nodes up. So I think that's fine. OK, so here this is the usage of sign of. So Safad is unchanged, still pass ANB, but then instead of saying sign a value not equal sign of value, it's sign of a X not equal sine of BX. That's good. And then second Arg is parenthesized. Yep, I can't. Think we parenthesize because of this angle bracket. I think that's why we were concerned. Interesting. We were very paranoid sometimes. Um, if ABS. Of X and you're making sure that we're not flipping any variables. That's good. Less or equal it Max, Max minus ABS of BX type. OK, that looks to have been completely converted over. Do I believe that we still need these parentheses here? Plus, SQL is a single token. These parentheses are really not necessary, but they were preexisting. They were equally unnecessary here. I'm not going to ask for them to be removed. It's OK. OK, next. OK, so now this is the big change to GCD. Here we had and this is one of the reasons why it's a nice clean up. Um. We had a public struct, um that predigest predigested things by taking their absolute value and then passed it to this recursively instantiating struct with a base case. And then we had the we had an explicit specialization down here, um that absorbed 20 arguments, which I found as I implemented the stuff I believe that it was very convenient to have. Even though technically math textbooks say GC is 00 is not a thing, it's not one. OK, so this is also going to be a notice guard constexpr function returning it. Next we're going to call under score GCD. So saying name. That's good, we're going to take ax and BX. During Max's, but they're not going to be confused because we are going to modify them in place. So that's good. That is what allows. It allows us to write this as a loop rather than recursively calling. So I like that it's going to be no except. OK, so we're going to start by absorbing this case, which used to be a an explicit specialization on the public function if. X is equal to 0 and BX is equal to 0. That's exactly this case. Then we want to return one, and we're going to preserve the comment, contrary to mathematical convention, avoids division by zero and ratio less good. So if they're not both zero, then we can take their absolute value. That is what was happening here. X is absolute of ax. BX is absolute of X. OK, so now we've done this, and now we're going to use the. GCD X helpers here, so this loop down here should be equivalent to this. So we're going to loop. Um. This partial specialization absorbed cases when BX was zero. So while BX is not equal to zero, we need to do work when it is equal to 0. This would absorb it, and we're just going to return a X return X. So that is done. We don't have the comment here. Computes GCD of X and zero because that is, you know, really obvious here. I'm fine with not having that comment. It was the contrary to mathematical convention, one that was. Very important. Um. Yeah, it also occurs to me that, OK, so we we are keeping this. We don't need computers because these are the internal ones. Computes X and zero or ax and BX. But we're losing this comment. Computes GCD of absolute ax and absolute BX. I think I would like to retain that because that's an important thing that affects the interface of this GCD function, even though it's internal. The fact that it takes the absolute values um. I think we should, we should retain that comment. Uh, whoops. I don't want to add that favor. Um, here we go. Copy. Let's see. I think we should preserve the comment. Um, as it explains something important about the behavior slash interface of this function. OK, I think we should preserve the comment computer GCD of ABX, MBX. Yep, there's still the names as it explains something important about the behavior slash interface with this function. OK. But other than that, um, we have handled. The 00 taking the absolute value. Umm. When X is zero, we just return a X. Otherwise we need to loop. OK, so here, what was the loop doing when X is nonzero? We sort of exchange things. First we compute. OK, here, let's see. Let's say I'm doing. Store is constant Max T X2 is ax, so store ax is a temporary. Now assign ax equals BX, so that puts BX here. Good. And then BX is going to be the original value of X, so X2. Mod BX yes, this is good. And there's no real convenient way to do that better. Uh, there's like food exchange, but that would just make it harder to read. Um, this is simple. I like it. OK, that looks good. And that's GCD. Much easier to follow. Um, rather than having a grand total of like 1/2, is it four or 344 struct template, either templates or specializations. Now we just have a single function with if statements. Awesome. Okay, ratio is now going to be uh, changed to use it and we're even. I'm not wrapping because we don't have all these spammy double colon values. As an aside, we probably would have introduced variable templates if we had them when we originally wrote this code, but we didn't, so we had to use nested value static context for data members. But now we can just function call. So static constexpr Max NUM is NX times sine of DX times ABS of X divided by GCD of NXX. Yep, that's all the same. Instead of counts expert next den denominator is ABS DX divided by GCD of NX DX perfect. Here we have a GX that's the GCD a DX1DX2. Yep. And GX GY converted over two. OK, so that's perfect. And then let's take a look at Chrono O Chrono. Hadn't LCM least common multiple um. Here we are losing the comment. Compute LCM of AX and BX. That's just the name of the thing, so we don't need that comment here we have a notice guard constexpr function returning maxt named under score LCM. Um, under score, capital LCM. Uh, these can be constant Max DX, constant Xbox. No, except that's all good. Then we're going to return. OK, so we're going to return this here. I'm just going to copy and search. Uh, Nope, they're all. It's because the double column value. So if we converted. Parans. Yeah, OK, so converting double cone value to parentheses, it's the exact same expression. Um, so no type is there. I could have verified that visually, but control F is sometimes easier. OK, that's good. This weird space is just because of the wrapping here. Is not actually in the code. And then this GCD calls now function call. Same with LCM. LCM is still doing nontrivial work, so there's no reason to try to lift that out. OK, that looks great. OK. So aside from the um. The comment being lost. The main question is do we need to convert safe add over and I believe that is definitely not necessary. It's only correct as is. It's not even really inconsistent because currently safe multi still expresses a structure that hooks deeply, as we saw into the Chrono functionality. UM, safe a DX or safe ad only has the one caller. Got this good also good thing this is different. Morally than the conversion that's happening here. We're converting the struct stuff into context for functions, but we don't need to handle error cases. There's no errors that we're trying to absorb. This is error handling. I think that doing that as a follow up PR or filing an issue for something like that is entirely reasonable. I don't think it's necessary. And if we did do it, I think that we would simply need to decide should it be calling a function. Um, there is. I can also look at precedents to add to this comment, I think format had one example where during contextual evaluation we have a function like. You see this because you violated so and so yeah, here we go. Inline void, you see this error because our idea is out of range. It's not constexpr or we do define it, but it's not constant expert, so. We call this function. In context for evaluation, when we want to, uh, emit an error and the compiler will complain, hey, this thing is in constexpr and the name of the function is an indication. This actually indicates that we're sort of working around a limitation in the core language. It sure would be nice if we could emit a custom error during context for only as like a nice string. We don't have that, so this is a not awesome work around, but it does work. So I think I'll go ahead and quote this. Because this is only used at compile time, that's a format. I'll just copy the name of the function. OK, let's go load up the. Header. I'm going to go back to format. Go up a bit too far. Here we go. Format. Hit Y for permalink, search for function um copy definition. And I can. Ohh it's pending good so I can update it in place. Uh, let's see. It would overflow. I get the rid of the bit about throw. We don't want that. Um, calling on constexpr function and then, which is a technique that we've used elsewhere. Here's the inline 1. Umm. And then the calls OK this one. This one's even better to quote because I can show the constexpr function pretty easily. Like this? How do I have two of these open? Ohh this is the issue. OK. OK, great. OK, I believe there be possible to convert safe add to contacts per function, but I believe the overflow enforcement would be best expressed with if would overflow call an context function, which is a technique we've used elsewhere. In line void you see this error prone Pran constexpr function that calls it. The only usage is a compile time. I believe it could be done as a separate optional step. I don't believe it's critical to do now. OK. Yeah, the original function. The original issue talked about converting things over to um Constexpr, but I see no reason to delay this PR. For something that does not deeply affect this existing code, it can be done as a. Wow, this uh, it's probably just in my remote desktop. Um, surrendering looks a little messed up. Um. I don't think you should delay this PR. It can be done as a strictly orthogonal separate step. That won't change any of the existing code, but then would further convert Safad when we could look for additional opportunities like is it possible to convert somewhere all of safe molt? Are there other uses that should be updated? But I think this is a good first step and. Is nice and self-contained and um. Doesn't touch on the, the question of OK, how exactly how do we enforce this? Um, so I'm, I'm happy, I'm happy with this. I'm going to update that comment. Uh, really the only thing is that that comment, I can just go ahead and push that after this. So I can go ahead and finish this review. I'll just comment and I'll push changes right after this. OK. And yeah, that's the existing thing. And Alex, who submitted the issues, already approved, so he's happy with the changes that are being made here. Uh, OK, I think that's it for this PR's. Are there any additional questions? Let me look through the chat. Casey agreed that the parentheses seemed like overkill in LCM. You know, if I got to push changes for the extra comment, I can push a removal of those parentheses. I can go ahead and do that, even though I didn't. Get a comment for it. Yeah. It's obviously not a huge issue but you know, we try to avoid them when they're well known precedence operators or and I think pretty much everybody who took, you know, algebra in elementary school, most that multiplication division of this president. So yeah, in fact, I believe the parentheses were guarding against. The uh ohh wait, you're talking about these parentheses? Yes? Ohh no, I like these parentheses. Um, so this is a special exception. It is true that multiplication and division have the same precedence, and they're well known. Evaluated left to right. However, it can be visually ambiguous if you say um X / y * Z whether it was intended for y * Z to group together. It's certainly unambiguous according to the rules of C Plus that you value left to right. And I believe if you ask a mathematician that yes, it's also an ambiguous, but many people just conventionally will write X / y * Z, and they do mean y * Z to be grouped together. So just to avoid any hint of, you know, surprise. This is the one case where I do believe it's OK to have parentheses. Uh, even though they're technically not necessary. Uh, it could also be expressed as BX. Put that first and then. The parentheses are, uh, not needed, but actually there I think, uh, we would want to. Yeah, we want to avoid that. We would still need parentheses. We would want to avoid any overflow. So I'm actually happy with how this is written. The parentheses I was thinking of are where are they? These ones here. These parentheses are necessary because they're protecting the less. I believe they're protecting the less equal um from being, uh, parsed as like a start of a template Arg list and safe add X. But I don't think that was ever an issue because it's less equal and that's a whole token. Even in the horrible days of C + O X, when compilers were still implementing, you know, all the rules for nested angle brackets, I think this was never ambiguous, at least I I think this is completely unnecessary. That's why I was thinking, oh, should I just remove those brands? What do you think about those? Should we get rid of those or. Yeah, those two and OK, that's that's preexisting. It was there before. Weird, yeah, which is why I didn't comment on it. And if if there were no other changes to push, I would have just let it go because it was definitely pre-existing. It's not even that bad. But if I got to push changes for the comment that I do really want to keep, May as well change this thing that's like 2 lines away, but here I think in the LCM. Even though they are technically unnecessary, I think this does warrant the parentheses, which is probably why I wrote it that or rewrote it that way in that first place. I can't remember if I wrote this or somebody else did, but I like these ones. OK. So I believe that's all the comments. So I think that's it. If you have any further questions, feel free to leave them in the comments on this video. Otherwise, we'll see you next time. Thanks for watching.