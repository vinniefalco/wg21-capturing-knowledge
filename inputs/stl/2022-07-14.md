WEBVTT Alright, uh, hello everybody. This is Nicole Mazzuca on the uh Standard template library team and today we're doing video code review of P2387R3O sorry PR 2661, which is the implementation of P 2387 Vision 3 pipe per user defined range adapters. Share my screen. We're doing this PR here. And we will be, uh, so. So this is implementing the, uh, this this paper. Type support for user defined range adapters, so basically. What this allows is. Oh gosh, let's see if there's an example. So the idea is in the. Standard library. Right now we have these. Views. That, uh, you can pipe into. So, for example, uh, let's see. Oh gosh. Yeah, so transform view. So if you are writing some code. And you have a vector int. You can then type this to ranges transform I think. Rest of the team tell me if I'm wrong. It needs to be. Views transform do we lift that out to ranges itself? Yeah, that's right. It's stood ranges, views, and it's also available as stood views, but I don't think it's available as stood ranges. It's going to need to be transformed with an S. Yeah. And you're going to want to, because otherwise it won't have the right type. Thank you. Dark ah yes so. This will. As you can see. Include iostream. And then it works. Binary and execute the code. Wait for Tron. Oh, this is very slow. Someone should talk to the person who made this. For people who do not know, I was the person who implemented this on Windows, so I'm the person who made the MSVC and therefore you can blame me for being a bad programmer. So yeah, you can see here our initial vector has 0123. We have a range iteration over this V pipe, two view transform which just returns I + 1 and we get out 1234. So these are really cool, but there is no way really for users to write their own and So what this paper does is it allows a user to write their own range adapter. As I understand it so. Umm? Yeah, so let's take a look at the. PR. We've got some debugger changes, some changes in Windows core to just add like small things like we've got the the spine back, which is a new feature. New feature Mac feature test macro. Is that what we call them? That's correct. So new feature test macro CP live ranges has a new value and so in C + + 23 mode it's set to 202202 for this pipe support for user 9 range adapters and in 2020 mode it has this 202110 value from. What is a view? And then we have changes in. Functional. We already in C + + 20 had bind front. What find front does is it takes a function. And it takes a. Instead of arguments and, it basically binds those. It's it's. It's similar to Haskell, so if you have, you know, void. No F. And you bind front. Then you can then call X. You know 0.0 no putter. And this is equivalent to F0 0.0. Put her. We also, I believe, do we have a different one? Different binder, no OK, we just have bind front and then in. We, we added this bind front because we saw that it was useful, but there was never a they we couldn't figure. We couldn't find a reason for find back and this allows us. We've found a reason for it in this. Paper, So what this does is instead of having these arguments be at the front of the function call, they are at the end and so you have to do this and this becomes. And then you call F0 0.0 and then all the arguments that you passed to blind front and so this is just a basic implementation of. About Korean, basically. Not making changes. All right, and so that allows us to implement. This one thing these pipes. Uh. And if you look back at our. Tyler, what we want is view views transform. To be equivalent to like like this V pipe 2 views transform, this should be equivalent to views transform. Transform view. The. And I. Return. And so we can use bind back to implement. Cool, alright, that's enough of the background. Let's take a look at the actual code. What we actually need to implement, so look at the actual proposal itself. This paper adds 2 additions to the standard library. We have range adapter closure. And we have bind back. I'm going to review bind back first because. If we look. This find back should be approximately exactly the same as being in front, except this thing. This bound args will be in the OR. Where is it? Go for binder. Whatever the the bound args, the the arguments that you pass to call back will be passed at the end instead of the beginning. So we can do something with my absolute favorite program anyone has ever written. Which is. And we're just going to take a look at the difference between buy and front. Back because they should be. Almost exactly the same. I'm missing. Nope, that's not what I wanted. All right, so let's look at this. Can y'all read this? That is pretty tiny alright for our viewers on the recording. I'd recommend zooming it in. Now we need to figure out how to zoom this in, because I didn't think I had. Answer. You could just try uh, or on Windows it would be control, scroll wheel or control plus minus. I don't know if that was my first attempt and it's about to work. I'm learning to be a Mac person. Try command plus maybe. Yeah, that was my first attempt. Yeah, that was my. That worked. Yeah, see. OK, it's not like this. Well. Thanks Microsoft Teams. OK, well instead of doing this. Then we are going to. We're going to save these to a file and use VS code to compare, because I know that VS code is quite good at this. It's also worth noting that VS code can compare unsaved files with the. You don't need to launch like code, double dash diff. You can use the the files list on the left side. It is. It has so many features these days you need to know like exactly where they are. So how do you do that? It's the upper left explorer. Uh, click that and then simply select both files with shift or yeah and then right click compare select. And that works whether they're saying. All right, so let's look at the stuff here. So first, obviously, front back, correct? This one instead of doing. Yeah, OK, so it's it's going like here, so it's no except no except stood. Invoke stood forward the function object. Look down. Well, those are the same in both. Then we have. In the blind front we have stood get. Index sequence stood forward. CV, tuple, TID, tuple. Comma stood forward. Unbound, unbound args. And in the. Call back, we have stood forward, unbound, unbound args stood get the tuple, so these are swapped, that's correct. Then we return the type of. This invoke with the function object the get the forward. So we return the invoke function object unbound args tuple. And then we return invoke a function object of get. Of forward and invoke function object unbound args tuple. So these are clearly just swapped. We we see the beauty of the triple. Repeat everything for perfect for real perfect forwarding. I really hope that at some point we. Fix that in the language, but for now we have to actually do the triple forwarding or the triple. Bold. Repetition for perfect forwarding. Here we've got front binder and back binder. Obviously correct here. We've got front binder back binder, front binder, back binder. Exactly the same. Then, uh, the call operator. For front binder. The No, except gets pulled down. So. No, except no except no except no except call front binder call back binder. Then exactly the same that looks correct decltype call front Finder call back binder exactly the same return call front binder callback binder exactly the same. Looks correct. Then exactly the same for cons reference and it's all the same, exactly the same for our value non cons preference. All exactly the same and then for R value cost reference all exactly the same. Then we go to. Find front end. Find back which should be exactly the same except for doing front binder versus back binder and for the static asserts. So in the first static assert we've got front, front, back, back. Define front requires the decayed callable to be move constructible to bind back requires the decayed callable to be move constructible. Define front requires the decayed callable to be constructible from an undecayed callable. To bind back requires the decay, called the constructible from an undecayed callable. Front back front back. Front binder back OK so. I see no need for any changes. We will. Not savings. Are there any other changes to functional besides those additions? Don't seem to be. It's has cpox plus 23. And if has C + + 23 perfect? OK so functional is complete. I was, uh, raising my hand. Although you you couldn't see, it's what's up. Since you mentioned the the wonderful the triple I wanted to provide an explanation for that. Yeah yeah yeah the as you noted the the triple repetition is something that does not fill us with joy. Lack of no except auto in the language is a known pain point. UM, the decal type one is interesting because the language does have decal type auto. You do not actually need to repeat all this stuff, but we do in the STL at least here and the reason why is that there's a subtle difference. If you say decltype auto that will need to instantiate the body of the function in order to determine what it returns. If you say decal type of spam out the expression again. You get spine. If that expression does not compile. So if we want these things to participate in expressions phenate, we need to say decal type of horrible expression. And that's why all of the invoke machinery does. Even though we do use Decltype auto in other places in the STL, this is the only way to get Stephen A when these things are being considered. Right, and just to be clear, what Spena is is when you're doing overload resolution. If this thing doesn't compile. Then, uh. This operator open paren close paren, just. Is not a part of the overload set. It doesn't get it. Doesn't. The compiler does not attempt to even call this operator, even if it like. In theory would be a better match. Is that? Your understanding as well. Uh, yeah. It's pretty good characterization and then other things like type traits can use the presence or absence of things like functional operators to report the right answer. So for constructors it makes is Constructable report the right answer for functional operators that makes the relatively new is invocable type trait report the right answer. So this means that buying the thing that buying back returns will be queryable by is invocable you could ask is invocable that function F you had? With a double and a null putter, TT and that will give the right answer because if Sweeney causes the operator print print to vanish then is invocable can sense that. But if it just gets a compiler error then you're doomed. Right exactly cool. It's not making any important changes cool, alright? So. Let's see how this works. Ah yeah, OK. I was looking at this before and I have. Pinions I don't. I don't love how this does this, so. In C + + 20. Actually, let let let's look at the the. The. The the the paper for a bit here. And. See if I can find the actual wording. Mike Photos on the proposal. Right range adapter object. There are a few different ways that the different, UM. Standard libraries chose to implement. Their internal range adapter objects like view transform. And. So. The paper could have chosen. Whichever one it kind of wanted, it happened to choose the MSVC. Kind of style of doing it. And what this does? Is. Basically. Oh my gosh. Where are you? OK, yeah, and So what the the idea of this is that you have this trans. Actually yeah, let's look at the joint pun. So we have, uh, this join fun, uh? Function object type which inherits from type base join fun using the curiously curious template recurrence. What is it? I think it's CRTP curiously recurring template pattern. There you go. That basically this pipe base gives you all of the extra things that you need on top of having this. Call operator and this call operator is. What does the actual like. This is what? Gives you the view. Uh. And then. When you call join with. No arguments. What this pipe base thing does is allows it to use bind back to then. Return this back binder that will then be callable with this range and then the range itself, or that that new. Function object will be callable with a range to give you a joint view. Similar for transform fun you have. This pipe based partial. And this returns a transform view. And you have this partial overload. But that does the thing I don't know. So. What? But the MSVC is very manual, the MSVC solution is very manual, but it's also. You can obviously extend on top of it, and it's also kind of the simplest solution, and so, given that we already basically implement the standard, we just do it in these ugly names that users can't use. What the? What the person who's done this PR has done is. Given us this new range adapter base. Which is a ugly name that is either the new standard version or the old pre or pre. It's not actually pretty standard, but it's the old pre like user accessible version. And in C23 mode we only have this new version and in the plus plus 20 mode we only have the non user accessible. I don't love this. I understand why they did it, but. I don't know. I don't know if there's a better solution. I'm going to say I don't love this. But I'm not sure if there's a better solution. And then I'll think about this more. You know, on on my own time. Start review. Then most. Ah, so this is the actual. Ah, OK, so you can see, you know, use range adapter base. Don't know why this pipeline is now getting. Moved up. Well, let's see. I wanna I want to ask about the thing that you don't like. Share those concerns. Is existing code being changed to use this new conditional? UM, base class essentially. Right? Because the the the the major problem with anything that. Depends on standard mode. Is introducing AI problems mix and match, and usually most of the time when we add stuff in CS plus 20 or C + 23 mode, it's a pure edition, so there's no ABI. Can things either there or it's not, but the moment that something exists but changes form in a standard mode, especially if it's like a class that could be used as a base class. That's very concerning. We might be able to get away with it if like the layout is the same. But the fact that it's expanding to like a different base class and then it's actually being used by existing stuff, that's like. The second highest level of concern. Yeah, and I I don't know. I don't love having two different implementations of basically the same thing in the standard library. Umm? Yeah. So they're what? Potential reason I haven't looked through the whole PR to say whether it's possible. Like if for example, if the existing ugly machinery is always there and always used as the base for existing machinery and then in 23 mode we provide the new non ugly name that is expands or reuses the existing functionality. That's fine. Yeah. And could avoid just replicating both of it. Yeah, it's it's without seeing all of the code. I can't say whether that's absolutely possible. Uhm yeah, uh. So. Always have. Right? Space. And then, which would you categorize what you were saying is like basically have, uh? Range adapter closure inherit from Pipe Base publicly or something like that. Yeah, the most transparent thing would be to have it be an alias, but if it needs to add constraints, can you have a constrained alias? Is that a constraint alias right above? I don't believe that that's possible. OK yeah, OK constrained. Really think we can make anything? Why do I think that users could partially specialize this? Could partially specialize range adapter closure, which wouldn't work if it was an alias, so I think it needs to be an actual class type that derives from the ugly range adapter closure. Do we actually allow that? Just who actually are what? Does the standard actually allow you to specialize template classes or class templates that aren't explicitly called out as specialize able, yes, the opposites are different for class templates and for other templates. The default for class templates is that you can specialize them unless we forbid you to do so. The default for function templates and variable templates is that you can only specialize them if we explicitly allow you to do so. And that's because history. So yes, the standard officially allows you to specialize region after closure. C++ is an insane language. OK cool, I'm not sure how we could. Implement things to work. If you do though, yeah. So it's possible that that's a defect in the standard that maybe we need to address as implementers. Cool. All right, I'm going to. I'm going to say that that the C++ is an insane language, and let's continue always have white base but have. Strange dot. Or pleasure. Hey thanks. Uh, to? To reuse code. Umm? Oh maybe we could. Rename I don't know how anybody else or how anybody else feels about this, but. The. That's equivalent to removal. In addition, but the problem is that if you have a class that always exists in 20 mode, that inherits from one or the other, that's essentially what they've already got here. The status quo. The the the whole concern is next match, so the the one piece of advice I wanted to offer was in in this comment, especially because this is a. Relatively new contributor is trying to explain what the concerns are, so like it mentioning the FBI mix and match problem is the the real motivation. Right? Good sense. Umm? Ohh how is this crazed? What's on this praising? I think that gets the the the idea across, and yeah, this helps under put the the rest of your comment in context, yeah? This would avoid. Like differences. Physical AI. Yeah, would be. Observable. Uh, right? You could like. I think this would. Be an odr violation, probably. Yeah, basically anytime you have a base class who's pruning changes, that is an odr violation. We certainly do a lot of that the the whole way we've been moving the libraries for the past seven years is by knowing exactly what sort of odr violations we can get away with, right? But pushing our luck here is not something we'd like to do. Yeah. It is hard to reason about because you have to look at like. One version of code and then mentally think about two or more versions simultaneously and how they would coexist. And it's hard to explain because nothing like CS plus is not really built for this. Uh, right, and nobody else teaches this. Yeah, how to violate the OTR properly is one of the hardest parts of our job. Gonna be. Really nice if we had real. I feel like SWIFT really does this right? If if there are any language designers out there who need, uh? Any who want to see anything about how to do code reuse or shared objects, right? Look at swift. Do not look at C++ or C. Look at swift. OK, so this is plus. She is much better than C++, but only by virtue of being simple enough. Yeah, OK, so it looks during the combat thing. From that thing. Yeah, like she won't emit inline functions or templates because it doesn't have to be like on that sections you have to actually manually control that. OK, uh, so it looks like this pipeline is getting pulled up from somewhere. OK, let's check if these are the same. What is going on with my VS code and its ability to move the? There we go. So weird. Ohh it's. Always cause it doesn't like moving back and forth between. I like the additions and the subtractions. That's fascinating. Are you gonna let me OK? We're going to do not in line view for a SEC. Just a copy. We'll go back to, in my view, I think you can if you're willing to right click. You can copy all of the deleted or changed lines at once. It's just you can't. Copy of subrange of it in this yeah. Some some editorial limitations. I understand it. That's all. There we go. OK. It says old. Uh, let me copy. New. OK. Uh. And now we're doing the thing that I didn't know existed. It's very exciting. OK. So got the old code in Red, new code in green. We have renaming closure left and or left and right closure left and closure right pipeline now. Inherits from range adapter base. Of pipeline closure left closure right? Can you not use like that in the header or in the in the? Inherent list. Nope, the injected class name is only valid inside the class scope itself, right? Begins at the brace. Cool OK. Put your left left, close your right right. Renaming things but seems fine. We're switching from is nothrow convertible. Two is nothrow constructible? There are reason for that. It's an internal thing anyways. It's probably not that. Yeah, it's not that big of a deal. Those type creates do differ in their treatment of explicit constructors. Yeah, is explicitly constructable then the constructible trait will say yes, the convertible trait will say no. Right so this now. Let's see. Look at the proposal. Umm? Ohh we have it right here. The behavioral program that adds a specialization for range adapter closure is undefined. Ohh so so the the only place this would be different. Is if you are constructing. A. If you're doing something like. If you, if you're doing something like be to view one to view 2. This will construct that pipeline. And. In this case, like, because we can't. Talk about or or. The user cannot speak the name pipe. This will basically. Hmm, OK so this allows you to have explicit copy constructors I think. Or explicit move constructors. Because yeah. Speaker. Right? Let's see. And ranges. Actually don't know where this is. Let's look at the index of library names. Ohh it's not been merged into eel it into the version that Ellis uses. What she must have? It's merged into the draft standard, but Ellis. Lags behind a little bit sometimes and it has not updated yet. OK. So. Range dot adapter dot object. OK. Expression R has decal type R. Models range. The following expressions are equivalent CR2C. Where is the thing that, uh? Talks about operator. Pipe. You know, Casey. I'm I'm like I feel like I'm missing something. Oh there we go the expression CD produces another rigid after closure object. EE is a perfect forwarding caller wrapper with the following properties. Its target object is an object of type. The KT deco type D direct non list initialized with D. It has one bound argument entity an object C of Type 2 KT decltype C directs non list initialized with C. That sounds to me like it calls explicit. Constructors, so this this is a. This is more correct than it was before. Am I? Does anyone do? Do people agree with that it wasn't specified before, so I I don't agree that it's more correct. OK, but yeah, this is the change that the paper had wants us to make. I agree, OK, cool and and this occurs in a. It looks like it's strengthened actually, although it's internal so it doesn't count towards the common strengthened no except specification. So really we in some sense we should have been saying constructable anyways, because we're definitely we're definitely constructing there with. Will under score L and so forth. Describing that as no throw convertible was not really correct, so I think this change is positive. Oh, OK. It is true that only pathological types will differ in their nothrow ableness there right? But it is technically possible. Yeah, this is a change. Technically we require movable. For these things, and movable requires the move constructor to be implicit, so. Yeah, but but are the no thrownness required to be the same between implicit and explicit. I thought you could certainly should be. You think you can make a pathological type whose move construction? Differs in though, except this depending on whether it's explicit or implicit. I don't know, but I'm not willing to say that no user. Because it doesn't really matter. What's the constructing? Correct on initializing. Yes, yes. Uh. Hey well, how would you say this? This is like a more it's not more accurate. A more correct type trait. I think saying it's more accurate is fine. OK. Right now we go back. Have one close your left. Tie two, close your right left, stick forward, tie one file, one right stood forward, TIE 2 Vol 2. Template class time no discard context for auto operator. Open paren. close paren with a value. Reference no, wait actually. Why are these different? Uh. Uh. Ah, it adds uh non consent calling operators. Which. I went there. Why were there not non constant call operators already? Because we didn't need them for any of us standard types. Got it, only had to work with the standard specified range adapter types before and they worked insane ways. Got it. There OK, yeah, so this goes right. No, except no except right, right? Right, left forward tie Valve. Which is exactly the same as no except no except right left forward tie Valve requires requires. Want duplication and see what's left, right, left, forward tie Val requires requires right, left, static cast, high refresh Val which is stood forward. That that is the specification of step forward with some extra magic dust and then return, right left stood forward tie Val. And we have return right, left to forward time. Perfect. This makes sense to me right left. OK then with the ref bra you have to do no except stood. Move right stood move left stood forward tie Val. Did move right, still move left stood forward, Tie Bow turn stood move right stood move leftward, perfect. Uhm, is there a reason that we had the construct ref before? 01 was plain and confused, and now that's being split into plain constant times. L value in R value. So that's the splitting that's happening. Cool. Makes sense. OK, so yeah, this is, uh, still obviously correct. And then this one is no except no except stood. Move stood move forward, move, move forward, move, move forward, right, left, right, left, right, left. Right, left, right, left. Right, left, right, left, right, left, right, left right, left right. OK cool, I am convinced of the correctness of this. I think we conventionally order these L value constant value, R value constant R value when we have all four overloads, don't we? There's that just something I do and not something that's STL. Well, let's check optional. I think I've seen both. Actually, we may actually be reflecting inconsistent ordering, and the standard hmm, if you look at optional, you're probably going to see what I do because I implemented option. That's kind of constant. Not not fun. Go look at not fun in in functional real quick. OK. Graph contrast rifraf contract. I am good with reordering this. That is also, it's a more natural reordering because it keeps the moves together, yeah? So it makes it a little bit easier to review. Yeah there is. Operator. To keep me move. Pretty yeah. The X value overloads together. Back craft. Perfect. Alright, I'm with pipeline. We've already looked at pipeline. Now. The rest of the changes. I don't believe that there should be many changes. We use this public range adapter base. You're going to ignore that for now. We're just going to look at the rest of these range adapter base. The way down range stop your face. Some formatting changes, formatting changes. Range adapter base. Come on. Change that to bass. Formatting changes this is an ugly formatting change. I do not appreciate this claim. Format 11 or 14. And change it after base. See if there are any. Skype. Space left in the file. There should not be. There are not OK. There's any in the rest of the. It should be exactly one OK. Correct? Then finally our last bit of new code. Be done. So. It got derived from range adapter closure and pull constant volatile range adapter closure tie wrap. Is there a reason that this should that this isn't using the classic just derived from? Where is base of? Does the voted in standardise depict this and that's an excellent question. The there is a difference is base of. Curiously does not care about access, control or ambiguity. It's an extremely powerful type trait. Ah, it's derived from. And he has no other base classes of type range adapter closure U for any other type U. Entity does not model range. Ah, I see. So this wow, that's really interesting. So basically what this? What this says? This is checking. That T models. Moving back. What this is actually saying? Is. Given. This object which. Should be called. Just noticed this one. Write it down. Before I forgot, no, that's not what I wanted. So. What this is checking for? Is. Given a constant volatile Tyra, which doesn't matter that much. I don't know why it has a comfortable tile there and not just the tiraf I guess so that constant volatile. Ties can still. Be fine. Any thoughts on the comfortable with happiness of it? This is a concept. It's not. You would ask this for like INT. Yes, but it does not, because you're not actually going to pass anything to the requires. It's not like a function itself. I don't see what purpose the Council will hear and on the line above serve. Because really this is asking could we deduce? Yeah, make this be. Oblivious to CB qualifiers on tie. Yeah right, if Ty is volatile something, ah OK, that erases the CV then we need to have volatile appear in the thing that we're determining it for a specialization up above, right? And therefore that means we have to go ahead and just apply constant volatile. Both blanket here to the tie. OK, cool, so this is making sure it ignores both calls and volatile. Making sure it ignores both constant volatile. Uhm? This is just a simple question about the naming conventions in here. What do you use? Single under score versus double? Umm? So. Because that's the convention. Right, But what is the Convention apply to? I mean, right there you could say a single score for types double for args, but I'm just curious what your role is. You could mention this. We use double underscores for parameters that requires expressions, sorry, could. Tyler, sorry you have an echo. So after you're done talking, please meet yourself because it is like screwing with my brain. Yeah, so my understanding of the of our thing. So OK, the standard allows us to either use like through lots of rules. Basically we we. Reserve all identifiers that contain a double under score or start with a single under score and a capital letter. So. We do reserve like every implementation reserves both this identifier as well as this identifier, and this basically means that you aren't allowed to break our code by hash defining under score under score object to be. New, I don't know. And so these are both correct. These, like from a strictly standard's perspective, but. The MSVC standard library, uh chooses to always use under score capital for pretty much everything. Sometimes we don't always follow that convention, but but that is the Convention. I do believe that the other standard libraries choose to use double under score, lowercase, although I cannot confirm that. Yeah, but but we just always use under score capital. Is that a correct reading of the situation? That that wasn't accurate description until Casey and I introduced exceptions. Casey, I think was the first. I might have been. The first I think you were with I was technically that's right yeah. So the two exceptions in our library are CARICOM and ranges CARICOM. If you look at its center uses double under score, lowercase, and yeah, specifically, take a look at Xcaret kind of rude dot H. That's the one that will feature the double under score lowercase. And that's because we derived it from off Adams Rue repo. But I said look at the the header X kurkov rue under score dot H. Yeah, that one. Scroll down a bit. You'll see all those identifiers and that's because I had mechanically transformed the original C repo into C++ and did a bunch of other things to make it friendlier to MSVC. And although it's semi mechanical and we it's difficult to regenerate, I wanted to at least have the possibility of staying In Sync with upstream, so I opted to simply prepend double underscores. Identifiers. As the most minimal transformation, this was actually back before VS code added the ability to transform Regex do regex replaces with case transformations. Now it has that ability, and I might have used our conventional under score capital if it had it back then. So that's purely for staying In Sync with upstream Casey and ranges introduced double under score, lower cases for an entirely different reason, and let me let me try to capture my understanding before I get the definitive explanation. I think we talked about this and I was like why not use under score capital and it would involve choosing like even longer names for some things like instead of R&amp;L we need like double under score, under score, capital RX and we have to worry about stopping over existing names and he just felt it was simpler for very limited scopes to use the double under score lowercase and I said OK, that seems reasonable. You've convinced me is that, is that right Casey? Yeah, that was basically the reason I. I also find double under score names more readable. I'm not going to disagree with you under score capital. I don't know throws my brain off. I don't. I don't like capital letters very much, just that's all. Uh, do I, uh, I prefer lower case, but I don't know for this specific thing. I think our Convention is clear and following convention is more important than strict readability. There's not that much of a difference. OK, so. What this does? First, we've got the cost volatile cost volatile. All this does is say OK, we're going to ignore any cons or volatile on the. Type so you could write to write from range adapter closure open paren constant, for example. It would, it wouldn't matter. With this checks if it, uh, it checks if it is possible. For the. Language to. Figure out. Yes. Type. And. The language is only able to do that. If this type. Is inheriting or inherits from exactly 1? Range adapter closure type. Is that accurate? I believe that's accurate, yeah? Template argument deduction will, uh deduce it only when it's public and unambiguous. And yeah, importantly, things like conversion operators cannot be used to make that work. Yes. Awesome. And I one thing here is I believe that this will say that this is derived from rain to rain. Range adapter closure. Even when. This type inherits from range adapter closure. Of some unrelated type. So if we look back at the standard's. Go back to the standard's. We want the cheese to model derived from Granger doctor closure. T specifically. With no other base classes of type range adapter closure, you. So this makes sure that it's only derived from exactly 1 range adapter closure type. However, it might be it might be deriving from an incorrect range adapter closure type. So. Let's check. We don't have, doesn't look like. We have any names. For this, yeah, we don't have any suggested like. Uh. What exposition only names so we don't have to worry about like following the standard use for our exposition, only internal names. So. Look at this. This. OK, I see. So this derived from range adapter closure, specifically checks that it's only one and this is range adapter common. Checks that it's derived from. That the type the remove CD ref T of type. Is derived from ranged after closure of type. And it is only derived from one range adapter. And type is not a range. So that says he does not model their range. Right, he has no other base classes of type region. After closure. You for any other type U. Right? And T models derived from range it after closure T. Right? Is this necessary? That does not look necessary to me. Casey, you're the expert here. What's the question? The removes the graphs, yes? I'm not sure why those are there. I guess they liked them. Apply is ranged after common, more lazily. The actual use of sites you definitely should second one. Yeah, I think you're right that the first one is not necessary given the specification of the concept. Yeah. I don't think you do, because is base of. This is base of. Obviously doesn't care about CV qualifiers. And yeah, the the pointer conversion test is devised to not care about them either in the definition of drive from so. Yeah, we probably don't do that. OK, I'm going to say remove it because I I concur that it is not necessary. But the the second remove CVRF T is necessary, yes why? That's within the type. It's not outside. I see. Going to remove the first DRFT. 2nd. Second, remove. DfT is still necessary. Ohh I'm thinking. We do need the raft because. Is range adapter common? Checks for. Or we don't care about rush. Yeah, we do care about. Yeah, we need that. Yeah, OK, I I'm good with this one. Even though we only really need we. You don't need it on to arrive from range adapter closure. The third term of the of the concept there. Uh. Nobody forced to sell that units here. But if Ty is a reference type. Then, Oh yeah, we can still convert to Constable Atile. Even if it's just like a an int ref, it'll still convert to controller tile range after closure. Because it's just adding CV qualifiers. I understand correctly, it does mean that this constant volatile is not necessary. I don't believe CV qualifiers to a reference type doesn't do anything right, but I don't think that the constant volatile. It is important anyways. Because no matter what type. This is. Like if it isn't CV qualified, adding CV qualifiers is still totally fine. Right? I would say that there is. I might recommend that there's a lot going on here. It instead of handling like the CV and possible, or at least the CV removal in two different ways. Perhaps handling it uniformly in the the derived from common one below could be better. Yeah, because if we decide like there, we would decide once and for all. OK, do we need to remove CV ref? Do we need to just remove ref on the incoming thing? Do it at that layer and then the rest of it can assume OK. I'm working with the CV unqualified type or something. Could be similar. I know that's CVR. I know that that is not, uh, an official term, but I like it. If you have a better term for it, tell me. It would be a CV qualifiers and rough qualifiers, which is the reverse. OK, I'm good with calling him CPR qualified. Or CV ref qualifiers, except that's not really our ref qualifier, that's a missed over that. We're all we're accustomed to. Yeah, the only true ref qualifiers are red qualifiers on member function declarations. OK, well I'm going to be a bad Kitty and use. Give you a qualifier and my other Kitty is going to be a bad Kitty and bother her mom while she's doing work. I love you Willow, but go away. OK, so then down here we need to. Stevie Ray FT. And then range, do we need to receive DRFT of of tie here? Because in theory a constable matile tie could not model range while tie itself. Is modeling range? Yeah, this is suspicious. Yeah. That's it. And again, I'm not sure whether the Rangers removes CRF here or to ensure that the caller passes in something without qualifiers. Yeah, but we haven't seen the the uses yet. Yeah. OK. So is invocable range and after closure range range can type range into. Tie is ranged after common tie. Are composable ranged after closures. Is ranged after Colin left yes. Is Ranger chapter common right? Yes, can't compose left right? That works for me. OK, now we get to the actual interesting code range adapter closure. Which if we go here. We add range of after closure. Is an empty type. OK, so it has no members that we can touch or that the user can touch. So template class D. Template class derived. Requires is Class B derived. And same as derived, remove CVT. Derived OK. No. Uh oh. That's implies that we don't need remove CRT here, because it will never be. And you CD ref qualifiers because it is the same as. I'm going to ignore that for now. Actually, I'm going to write a comment, the latter. If you're not necessary since. I must be class type 19. Reference. And must not be qualified. According to the. On line. OK. Then we have template class. Other requires pipe are composable range of after closures derived and other. Expert auto operator pipe. Other end end right? No, it's up. Ah, OK, so these are OK. We have one for Rep, Rep and Construc. Umm? The fact that this doesn't have. All of me. CV Ref qualifiers makes me uncomfortable. We have seen this pattern elsewhere. This isn't inherently wrong, it is a good question to ask, though sometimes this is desirable. It's usually only when a. Class cares about moving, but doesn't necessarily need to fully respect CV ref. What what's the one that really cares? Something like tuple get needs to have all four overloads, because yeah, sometimes you don't want to ignore the references of what you've got. This may be a case where it is reasonable to have both. But it would be nice to be motivated from standards, yeah? OK, pipe pipeline set of cash derived rifraff started this. That forward OK please. Just call move. Same repeated pillow. Right? Ben the pipeline starcast, Yep, should be moved, but you just read it up there. Riff Raff and both these are composable. These are composable. Construct. Ah, I I have a question is drive the? Can you scroll up to the top of the class definition is derived to base class. Yeah, it's the thing that this is templated on so. Should move is different. Should move, will preserve the fact that this is a range adapter closure. Whereas the static cast was not only moving, but casting. So I not saying we should or shouldn't change it, but that is a difference. Yes you are. You are actually right, this needs to be static. Cast arrived for F this. This static cast is not just a. Uh. Uh. Is not just a. Move. Also cast to drive. Let's try this. It was a. But no, no, it's not a pipeline, it's a range doctor calling here. Cool, thank you for reminding me. Umm? Then if it's an invocable range adapter, closure, diaphragm range. Ohh interesting. Fine fine. Got it OK, so these two are the ones that allow you to make a pipeline, so that's what allows you to write. A to B where A&amp;B are both. Range adapters and not just are to be where B is a range adapter and R is a range. So. Then we have pipe is invokable range adapter, closure drive through range. Operator. Ah, so this is a friend. Change left five down right. Uh, OK. Interesting, uh, OK. Let's see if this is open now or this is done now. Where is VSO dev.azure.com? There's the GitHub Auto links page, maybe the fastest way to get to it if you haven't already. Put it into your browser. I forget the actual URL expanse too. Yeah, I'm just gonna go. That's a really high number and I'm wondering if that actually should be a devcom I'm wondering. Yeah, I believe it. Are there from work items? Ah. It is resolved. So we can remove that resolved. Here only means that it's been reported to EDG. It hasn't been actually used. Ohh so OK. So it really means it has not been. Cool well, never mind then. So transition work around. Don't work around Syracuse driving down right to forward range left return static cast right down, right stood forward. Rams left perfect. StarCraft draft and androids decorations left. Yep, constant. Construct. Perfect, OK, uh OK got it. So the important thing here, the reason that we only care about construct versus rifraff is that we're just doing a construction and. Erie cause refresh should not construct differently from construct and ref should not construct differently from construct. So that's fine. And, uh. Yeah, OK, cool and then but this because it's the function call operator. We do actually kind of care about this. The constant the the full range of constant and our value and our value and. Cool alright so. Let's look at the comments you've made. And let's see if we can. Uh, create a. OK, so. Umm? Looks really fantastic. Umm? And. You directly. And I don't have a lot of concerns. With that the only major things. See. Are some weirdness services with? Move City RAF. He uh. From the ordering. And. The ABI. Concern with. Uh. Pipe face. And rain. Adapt or closure. Have question before you submit that. Umm, did you review the tests earlier? I did not no OK. Might recommend in your comment if you submit this, just mentioning that it's a partial review, not of the test yet. I have reviewed. Speak. Alright then first. OK. I recommend. Making pipe bass tie a. I recommend making. Range, adapt or closure high. Drive from. Don't have to. Three you. That code. OK. I've not yet reviewed the test that I have reviewed all the product codes looks really fantastic. It looks like it follows the standard per directly and I don't have a lot of concerns with it. The only major things I see are some weaknesses with the draft summary ordering and the API concern with pipe based arranged after closure. I recommend making range adapter closure. Ty derived from pipe based TI so as to reuse that code. And make existing uses of type. Space. Can you use? Right? Uh. And revert existing users of pipe please. Back cluster, use that code and revert existing uses of pipe based back to pipe base. OK. Uh. Pipeline type is number 2, is not explicitly constructing. Correct? Right? Call operators. As you're reviewing your comments, I would recommend explicitly noting no change requested for the ones where you're simply commenting to avoid any confusion. Yes, like this one and a couple of the last ones, yeah. It's when we're saying, hey, this, you know this is good. I understand what's happening here. You don't want the contributor to go change it and mess it up. OK. Oh yeah. I'm gonna instead write same with. Arrived from range, adapt or closure. I know you can't comment. And then. Uh. I am not sure about the necessity. Ohh please. Oh no, actually yeah, they are necessary, never mind. Then Orange doctor closure range complete. OK, the fact is that I'll have all the receiver of qualifiers may feel comfortable and I'm wondering whether to send you these does require them or not. That's. Show me plastic. All right, I think that's all of the comments. Make sure. I commented all in functional. I did not. Alright. Thank you so much. And your. Don't you just a minute? Sorry, uh, what do you want to say? It's OK on that, uh, the fourth comment there. Fourth comment where you said same as derived from. Yeah, here here we go. This one you said. Same with derive from range adapter closure. That is the thing you're commented on. Did you mean simple? OK, thank you. All right cool. I think that's all. Awesome, hopefully this, uh, has been a good first attempt at a. Open code review. I will know in about. Three months because I am the person doing the closed captions. So thank you everybody. And have a great rest of your day. Now I need to figure out how to stop recording.