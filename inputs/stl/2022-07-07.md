WEBVTT OK, hi everyone and welcome back to another VC libraries Open code review. I'm today we'll be looking at P12O6R7 conversions from ranges to containers. Again, we looked at it during the last video code review, but as this is a very large PR adding 7186 lines and removing or modifying 275, we did not get through all of it, so I will try to get through as much as I can in today's session. As we catch up, uh, after the previous partial code review, my uh, submitted 6 comments and then Casey pushed 6 commits here, so I will try to see what has changed in the last couple of weeks, and then we'll resume reviewing. So actually, let me also expand what I commented on as a reminder of what we looked at. Remember, we looked at the list container. We looked at some of the common changes to X utility. OK, so. Let's go to files changed. Let's go to this. PR is not quite as large as it seems, because many of the changes are test code. The actual product changes are less. So I'm going to Alt click on the Chevron and expand and then minimize everything. There we go. OK, so I'm going to use get here to show changes since my last review. This will select the last six commits. Yeah, including comments or changes in response to our contributor miscoe's comments, so that's great, OK? So we've got some changes to deck. These are actually fairly large changes. OK, so some of these containers I haven't even looked at yet, so I am not going to look at for these recent changes. Changes to the containers that I haven't even looked at yet. I'll simply review those when we get to them, but we'll look at list and I think I might have looked forward last time. We'll look at forward list as well. So we got forward lists. We got lists there. And then I see some elderidge issues have been submitted, and then we also looked at X utility OK. I want to understand what's happening here. OK, so these changes are not too big in list. This is. I remember a preexisting issue that I had noticed where assign took two iterators. So this is saying hey list. I have a range of things I would like to replace your contents with this other range and before we unwrap iterators like vector iterators down to raw pointers, we conventionally need to verify them, which means we go through a helper function in debug. Code and this makes sure that the iterators belong to the same parent container, so you don't accidentally say VEC one dot begin. VEC 2 dot end unrelated iterators would be bad and for random access iterators. This verifies that the iterator is not transposed, they need to be in the order first last and if you give us last first, that's incorrect. So that's what ADL verify range does. And we need to call that before unwrapping down to rough pointers or something unchecked, so that change is good. That was a pre existing. Thank you in forward list. Let's see what's happening here. So. The new Prepend range function and I do not remember seeing this. This might actually be new to me. We used to call the public function insert range after and now Casey's calling an internal function. This is presumably being done for efficiency. So call the internal insert range after and tell us we're going to pass our before head pointer to a node. That's the internal replacement for before begin, and then instead of passing the range directly, we can get iterators into it and they can be unchecked iterators here. We don't need any verification because with the range we know we can grab first and last or begin and end without transposing them or getting wrong parents. So ranges you begin is unchecked. Begin our internal function range ranges you in range, that's good. Insert range after is changing. It looks like a large change because the classes are being renamed apparently for consistency. So template class inner class sent for Sentinel iterator insert range after because this is internal Now this will take a node Porter. This is our internal node pointer type rather than a fully wrapped constant iterator which participates in debug checking and all that node and interfirst concept in the last insert inclusive first last exclusive after P node. Comment was correctly updated. We don't need any verify because this is internal and working with unchecked node putter. If the range is empty then simply take that pointer to a node and wrap it up in iterator and return it. Otherwise do the same behavior, but what we're being given is just the P notes. We don't need to say we're putter. That's all good. Then the public insert after this is where the check moves. So if we're in error debug level equals two. Verify that the where iterators container. This is how our internal function to find. An iterator's parent container that needs to be re address so it needs to be the stood address of my permit L2. This bit here I can't remember if I talked about this in a previous video code review, but this is related to our. Uh, compressed pair optimization, to avoid storing allocators, because if an allocator state list which is the case for vast majority of allocators, we don't want to spend an extra byte or actually 4 or 8 bytes in the container, and this lives in a base class to avoid having too much machinery dependent on things like the allocators size, type and different type and all that. So a lot of machinery. But it all exists there for a reason if. That where iterators parent container is wrong. We say forward list erase after iterator outside range. This is bug. This was clearly copy pasted from another function, but it should say insert after. I will remember this for the moment I'll go comment on the full diff. I actually forget what happens if I comment on a sub range of commits. I think it would work, but I prefer to do it on the full diff. I see that happening as well for insert range after down here, so I'll comment on that. That's forward list otherwise. This is fine. We pass reporter to the internal function. Here same check, same incorrect assertion. Return insert range after reporter and then if we give a range we say you begin UN. So this is fine. It's only the sum. Assertion comment I always check this because the validity of comments and strings and assertions they are not checked by the compiler and they are a common source of copy paste errors or other things that need to be modified. But those changes are otherwise good. Let's see what's happening in extra utility. I remember talking about copy move in and seeing that it was replicating all the stuff that copy memmove is doing here. This is being mostly centralized, so if you're saying if you're calling our internal function copy move in first thing we'll do is we'll copy. The move, we'll give it the 1st. We'll give it first plus count for the end and then the destination. That's our result. If the contiguous iterator output is a pointer, we can just return it directly, otherwise and then here. Casey has a nice comment. Result is unused, so the compiler can optimize it away. Return dest plus static cast art. OK, so that's fine. It is interesting that this does not cause unused variable compiler warnings. I would potentially have expected to see. I may be unused, however. Uh, unlike a preprocessor like an if dev, Umm, the compiler can in theory see that the if constexpr could conditionally use this, so I'm not going to comment here as long as there are no compiler warnings. I'm happy. And if there were compiler warnings, we could just silence them. Next up, copy and unchecked. I remember there was talk about or my talk about whether size T was always the correct type. This is now being templated on an integer type size tie. Then if def. CPP Lib Concepts when that's available, we can have an internal static assert that this had better be integer like it can't literally be as integral V because this could accept things like the 128 type that IOTA View uses internally. But if we find at compile time that we are eligible for the memmove optimization, then we're definitely working with things that fit in memory, so we can Statcast to size T without worrying about overflow. What's going on down here? There's talk about, UM. Whether we needed some of the static asserts UM, and we decided that they were not necessary. So that's why this is being dropped. And same here. This expression will just have to compile and then this count can be constant. OK, so that looks good. So now let's go to the full diff and I'll comment on forward list before I forget anything else. And also I may quickly check to see if there's any other copy pasted if there if that exists in other files, then I'll just want to say please audit globally. OK, so it's forward list. We had. Here, yeah, that's incorrect. That's an STL verify. So basically anywhere that says STL Verify is that the first occurrence in this file. It's 22. Yeah, here it is. So I can say it curves below and I'll edit it if I find another. OK. So. This function is insert after. But the. STL verify message says. Erase after occurs below. For insert range after still says erase after. Sir, right after. OK, we got comment number one. Uh, let's see if any other classes are effective, so I'm going to pop open everything. Let's scan 4. Still verify how many currencies only 10. That's not too bad. That's pre-existing. Commented. The second one that I commented on preexisting. OK, here we've got a new one. This one is debatable because we just say list insert. Here it was actually the member function. I argue we probably should say insert range. Uh, I'll comment here. I. This is. Beta ball. Well, I'll say. See. Yeah OK, I'll say Umm, this is trying to decide how to phrase it debatably on issue. But as this function is. Insert range the estl verify. Message. Should probably. Say that. 2. OK, let's perforate this. This is debatably an issue, but as this function is insert range, the still verify message should probably say that too. Insert isn't exactly wrong if interpreted as a general term and not a specific function name. If we had mentioned it in backticks, then it would definitely need to change. OK. I'll assume Casey will want to change that, but if he thinks it's reasonable, then I suppose I wouldn't argue too much. And. Here we just have a very generic comment string iterator incompatible. I don't know if I like that. That really seems like it was copy pasted. Uh, but it was copy pasted from insert. Insert just says string iterator incompatible. OK, we're following precedent. Can't argue with that. No comment. What's the final occurrence? Here are replaced with range that's two iterators and we say string iterators incompatible. Presumably copied from. Replace Yep, OK, so that files question. OK, so it's not a global issue, it's just definitely two and forward list and a debatable one in. Uh, what was it list itself. OK, so that's all still verifies. Uh, now, let's see. But there is to review. OK, so I had apparently reviewed algorithm and I will score. I think our move some code movement and algorithm. Here's all the tests. I'm just scrolling through and then feature test, macro test and algorithm hit the code movement for get final iterator unwrapped. OK. So now. Let's take a look at X utility. Should be able to sign off on this because I just looked at the incremental changes. So this was the fusing of the ranges, copying them, move on to simpler. Now we looked at that. Copy and unchecked. Sentinel copycat this is where we remove the static asserts. Get Finder and wrap. This is the code that was exactly moving. It's the largest addition here. Here we're changing the Sentinel copycat called it copying my move on. OK, so this I think we can now call done since I do remember getting through this whole header. And then we looked at lists. Spark this. This has also changed since last view. I I see what I see what GitHub does. It's if I mark something viewed when they cleared the check mark. That's where that changed since the last view comes from. Interesting that I'd mark list as viewed and not X utility. I wonder if I had actually gone through all of extra utility. I could have sworn I did. I'm a little bit nervous about marking something as reviewed when I have not actually gone through it exhaustively. I had a comment on the very last line that strongly implies that I got through this whole thing. Yeah, it's really this that I know. I verified large code movement. OK, I'm pretty sure I've reviewed this all file. Try not to get too bogged down in obsessing over what I have seen and not seen. OK so list I believe I also reviewed this whole thing. I'll scan through it so we've got the Sentinel Conn Sentinel. Stood move first. For adding the new tag constructors. And inserting the initializer list here. This is just unwrapping. Remember, being confused as to why it was happening, but I didn't object. Prepend range append range. Assign and checked. Now we're going through and looking at how the nodes are being reused. We've got the verify that was added. This is also just unwrapping. This is the new assertion I'm. This might have even been pre-existing or existing in the last year, and I didn't notice it. And then the final deduction guide. OK, so I believe the list is good now. Let's take a look at forward list. I think that's the one that I ran out of time last time. Yeah, because I looked at it. I was like, OK. It differs enough that I do need to spend a lot of brain cycles making sure that it's all good. OK, so if Dev CPP Lib containers ranges, this is the new feature test macro I am. Going to check that it is actually the right spelling. OK, both plurals that is looking good. Yep, because if you say if DEF total typo then it'll just never be activated. Presumably the testing would catch that, but you never know. Completed on is this a container compatible range for tie forward list tag from range T then perfect forward range. Refer frange construct my pair which is the contains the allocator from nothing. OK, then we need an F list insert after opt two. This provides exception safety. Insert OPP from our newly constructed getal. Umm, use that insert opt to append a range unchecked. Here we take the range and get unchecked iterators to it. That's good. So after we've attached all those nodes, we can allocate a proxy and then finally attach the nodes before head. That's interesting that we do it in that order. Why do we do it in that order? That's consistent with what we did for the range constructor. Can't argue with that. The move constructor? Yeah, that's totally different. OK, that's good. Next if you have arrange, an allocator will be very similar. First you construct. My pair, which is that compressed air machinery with the allocator and then otherwise everything is the same. It's too bad we can't delegate, but we found that delegated constructors have undesirable effects on codegen here. OK, so that's all good. Next we have prepended range. If Dev CPP containers ranges again. Template container compatible range OK call this unchecked helper insert range after or head ranges you begin ranges you end OK. And of course there's no end range for forward list because we don't know where the end is a sign sign unchecked. This is being updated consent in the can be passed by constant value. This next can also be top over cons. That's a nice correctness improvement. Here this is just a cleanup. Instead of testing my first next again, we just started next. Let's just test next. That's fine. It's also not too invasive. If I saw a lot of invasive cleanup site asked for them to be separated, and then here append range unchecked Casey's moving you first because we no longer need it. That seems reasonable. It is passed by modifiable value for some user defined iterators. That could help things. It should never hurt. Umm, same sort of change here. Mark next is top of contest reasonable OK sign range if dev containers ranges template compatible range assign range call assign unchecked with you begin you end. That's all good. OK, we're changing access control here. I want to make sure that we're not. Having redundant access specifiers were clearly public here for insert after, so we switched to private. Then we go back to public, that's good. OK, the reason I'm pausing is because I was just thinking, UM, we've had serious 23 changes here in the if depths, but when we switch to public and then define insert range after that's unconditional. This happens even in C + 14 mode. But it's OK because this is actually being extracted out. The. Public insert after is going to call it so it doesn't need to be unconditional. OK, so there is some refactoring here, but it's for a good purpose. It's not just a random cleanup, so it's fine. OK, so extracting out private machinery template on ITER and possibly different Sentinel. Turn the iterator insert range after, otherwise it's going to look very similar to the signature. I'm sorry about that. I'm considerate where it's going to be utter enode then interfirst consentino last. OK, insert inclusive first last exclusive after P node comments been updated at first is last and we have nothing to do. Return make it RP node. Otherwise get that first insert after Reiki helper from the allocator. Chain up the new nodes to it by moving 1st and it's passed by modifiable value and then once they're all. Attached then attach after. He noted the where and make it her. This provides strong exception safety. I think I had a question last time about whether it was necessary, UM, but that ended up short circuiting because there's no better way to do it. There's like no more convenient way to do it like this actually is quite convenient. It handles the loop for us, so we're not paying any extra costs, so this is fine. Public OK. Umm? We commented about what's interesting is if you look at the full division, this is just change this being damaged for no reason. What's funny is that, uh, the message isn't even right anymore. UM, the message used to be right forward. List insert after location incompatible because the where iterators parent container is not us, then it's being changed to forward list erase after iterator outside range. But we're not saying erase after some range, the where has no relationship to 1st last. No, that message is actually really bogus. Same with insert range after it should be where is not compatible. Yeah OK, I I need to expand this comment. Additionally, UM that message. Is changing from. Location incompatible. To. Better outside range. But I believe that's incorrect. OK. That this function is insert after, but they ask to verify message says erase after. Additionally, the message is changing from location and compatible to iterator outside range, but I believe that's incorrect. Occurs below for insert range after OK. Casey know what I'm Speaking of. And then all this stuff is being extracted. Return insert range after we're putter, unwrap first unwrap last, because we've already adial verified OK, so now the function is just being reduced to do the verification. Or sorry functions being reduced to an ideal to check the container parent, verify the range and then unwrap everything. OK then, if defc live containers ranges we're in 23 mode and if template on container compatible range insert range after again no notice guard because this is modifying function you could easily call it and then drop the return value on the floor. We're going to insert after consideration where range refer frange when we're on IDL two, make sure that we're as container is equal to the status of my L2. We talked about the message called insert range after with where putter. You begin, you end of the range. OK, that's good. And then finally a deduction guide. UM, if dev containers ranges template on a ranges input range R&amp;G and a class Alec that defaults to allocator for ranges. Range value to RNG enable if it looks like an allocator. OK, that's right forward list from where, uh, tag instructor range rifraf Alec is Alec Prince Pren. Reduce forward list ranges range of value to range L OK, this deduction guide is good. OK, so that's a forward list we got. Listen forward list so I remember looking at vector and thinking it was big. Let's see shall we warm U with another node like container? Let's look at uh. X trees the cot? Let's look at X tree 1st and then map and set. Trying to build up the courage to look at vector. OK, so xtree it's node base, so it's gonna seem similar. We are clearly public for insert and then we're switching into protected because our drive classes will need to see this before we go back to public template intersectional avoid insert range unchecked that our first consent analas consult on my head is get scary, which is our scary data structure. Scary is a technical term actually. My head. This points to the Sentinel. Code for as long as we have not encountered the last increment 1st and placement before my head. The element to your first. OK, that's how we insert nodes. It's good. Go back to public. So all of this is being extracted, we verify and then we pass the unwrap first, unwrap last and then this is going U here exactly moving except for you first being renamed at first. That's good, so it's being generalized if Dev cclub containers ranges template container compatible range for insert range range for range insert range and checked you begin range you inrange just insert everything. And effective containers ranges OK for the input list. We can call insert range unchecked. And pass with pointers. Yep, that's a nice optimization. OK, X tree is good. Let's take a look at the actual drive containers map and set up. Here's map. So all the tag constructors are being. Lumped together, I'm here. I'm not doing the exhaustive out against the standard, I'm just looking at the code itself trying to make me see if it makes sense and is consistent. Umm, if people have containers, ranges and if OK, so I'm gonna ask. Review these template on container compatible range for the value type range map constructor tagged from range T range. Refer for range nothing coskey compare of Pred Konski compare of Pred Consolator type profile or just console locator type profile. This one should default to my base key compare Pren Pran. This is the type. I wanna see if this is pre-existing. We try to construct temporaries with braces, but it is preexisting. We do, say parents here, that's fine. But if we have a period, we should use it. We have a pretty now we should use both if we have just the, we should say key, compare it out OK. And then this insert range unchecked, give it ranges. You begin range ranges you and range OK, all those constructors are good. Uh, next uh map has deduction guides. Uh, while these guides are repose, if dev people containers ranges endif. OK, and it makes sense to stack these within the has CXX 17 guard around all of. Of the deduction guides, generally we do not like to nest these ifs too much. We'd rather say if has 17 and if if has 20 and if for like just different member functions. Even though strictly speaking 20 is a subset of 17. However, 17 is when class template argument deduction was added, and it's natural to guard all of the guides with 17 and then additionally light up new constructors with the if Dev, so this is fine and consistent with what we do elsewhere, I think. Template on ranges, input range, RG class, PR the predicate defaults to less of the range key type of range. Class Alec defaults allocator convert range to alloc type range OK enable if. Several criteria need to be met conjunction, so PR had better not be an allocator. Alloc must be an allocator. OK this. Any constraint prevents some confusion between the. Uh, possible guides when allocators appear in different places, even though it looks like it might should not be necessary map if you're deducing from range T range. Rifraf PR has a default. Alec has a default deduce map of range key type, range range mapped type range, the PRED, and the Alec. OK and then here. If you don't have a party at all. Template on range. Class Alec. OK, so let's see this handles nothing pred. And not this handles what range range. Prad range Pret Alec, but we need one to handle range Alex. That's why Alec appears here without a default. That's Alec. And then Alec could better be an allocator. Map has a constructor that requires takes allocator. And range key range range map type range. The Articat will default to less of the range key type range. Exactly the same here and then the Alec. OK, that guy looks good. Multi map extremely similar changes. I'm just going to be on the lookout for copy paste errors, but I don't expect to see any because there's no like messages or something. So key compare if you have a product, use it. If you have prenatal, use them both. If you have just all use key, compare now. Then insert range. Uncheck from the base class you begin. You end if dev containers ranges multi maps are deducing. We get a compiler if any of this said map. Otherwise, the same defaults the same constraints. Yep PRPR Alex Alec. Yeah, that's all good. OK map is done. Let's take a look at set. OK, again, extremely similar so I can sort of speed through this. I still got to lookout for copy paste errors, but I don't think there's gonna be any key compare. If you have tried to use it right now. Right now is key compare now insert range, uncheck you begin UN end Yep. Uh, these are the guides. If defc build containers ranges here, I want to make sure that nothing was like incorrectly copy pasted from MAM template on input range. If the PR less of ranges range value T OK here we don't need that internal range key type thing. You just get the range of value T. But we do need to go into the ranges namespace for that. So that's that difference. Alec is allocator for that thing. Umm PR had better not be an allocator allocator. Should be an allocator. OK, that's a good set of ranges. Range value T OK. And then if you only have the Alec. It had better be an allocator to do set ranges, range value T, lots of ranges, range of value T and Alec OK, that's good. Multiset key compare Pred Pred key compare you begin you end. That's how good guides are deducing multi sets. This is PRPR Alex Alec got the same constraint here. Got to be an Alec. Yes, OK. That is good. Now let's do unordered. Humanize that, that's xash. OK, again the same sort of deal where we're going to call an internal helper insert range unchecked. Once we've got unchecked, begin unchecked and so nice for efficiency. Here we were clearly public for insert, jump into protected, then go back to public. Excuse me. Template cluster class. Sentinel void insert. Range unchecked it refers consentino last this is extracting the body. Here we want to call the place function member function drfirst that's being extracted. We still need to verify out here and then unwrap both. That's good. We're still in public FDC flip containers ranges template compatible range for our value type range insert range don't need to verify anything just call insert range unchecked you begin you end and then here for efficiency insert range intact eyelids begin ilist end awesome. Yep that's right if DEF OK let's look at unordered map. OK, so here we've got. A zillion deduction guides. OK, so there's enough here that I gotta verify against the standard because we've had issues even in the standard with guides being missed, so I want to make sure we don't miss any here. Let's take a look at unordered. Map. Also, I could have sworn that we have one. There's one constructor that. Was missing in the standard itself and we implemented it. And we have an LWG issue. So the issue here is that if you look at all of unordered maps zillion constructors, it's sort of handling defaults like if you don't pass a hash or whatever, and as these things were added over time due to an oversight, one or two combinations were omitted. Let me. Actually, this is interesting and interesting to talk about. Let me bring this up so I've got a bookmark for the LBG table of contents. I'm pretty sure I filed this issue, but it was not recent, so it's going to be maybe near the middle. I would have talked about probably unordered. I don't know if I would have said unordered positive there's 43 occurrences. See if I can find this. I would have talked about constructors. Not preserve functions. More missing allocator. Extended constructors for unordered. Yeah, this seems right, and it's new, meaning it has not been addressed yet. Oh this is Billy. OK was not me. Thanks Billy. We suggest where is the current proposed resolution? Adding constructors of the form take a range and an allocator. Take an input list and an allocator. Provide. Definitions for them. Same for unordered multi map. Did we ever? We should also guides. That's interesting, this doesn't mention, oh, this issue probably predates CTAD, doesn't it? Yeah 2016, this may have predated the class template argument deduction. OK, so aside from that, which I'm pretty sure we do have implemented, that means we should check do we have? Constructors for range and Alec, and I think we do because I see this from range. So let's look at the paper. Unordered mam from range. OK, this is actually simpler because we just provide. But we provide one here. OK, so it actually is following the pattern of. Let's provide several overloads. That provide various defaults. Uhm? And the one that's missing is range followed by just an allocator. It's not this one. This one's got way too many arguments. This is range size Alec. Grain size hash your Alec. It looks like the new proposal is equally affected by this LWG issue, presumably because it imitated the existing. Functions are the existing constructors. So because this. Is not it's not the end of the world. I don't know if I would write a comment here saying that we should file an LWG issue. It seems like we should because otherwise, like I'm maybe the first person to notice this, UM. Perhaps we should point this out. Uh, this got a forward citation of 35 or six with that. Missing ohh allocators think structures for priority queue. Yeah, let me check real quick to see if UM, we come into 2713 in. What is this unordered map itself? Unordered map. We didn't. I thought we just implemented it, so let's look at the unordered map constructors. And it would be. In a in an allocator as the signature we're looking for. Yeah, we just straight up implemented it without actually commenting that it's technically implementing a PR, uh, proposed resolution. And same with the the CTAD below. Usually we we do like to comment that I guess we just went ahead and did it. Ah, let's see. This was, uh, wasn't this one of Casey's proposals? Yes, he was actually involved here. I will add a comment. Uh, it will be no change requested, but I will observe that I believe that. This is affected because let's bring here is just range. No, here's range in Alec. OK, I'm confused. Am I missing something or did Casey's implementation just replicate the thing that we did in? Our code OK, so unordered map. This one specifies from range range and then immediately goes on to size type, so that can't be it. From range, range size type no. Delegate from range range size type. And then deduction guides. OK, Casey is splitting out all of the default args in different instructors. That's following our existing, but he is implementing the one that is range and allocator so. I will comment saying that I think his implementation is doing the exact right thing, like we're replicating our extension, but we really should at least mention in this LWG issue that it's also affected. OK, so let's comment here, UM. It appears that. This paper. I want to link to the actual revisions, so I'll need the full number. Doesn't mention. This. Signature. But it's consistent with LWG. 27 thirteens proposed resolution. And our implementation. Where we added such instructors. And the reduction guides. Without any. Comments. No change requested for this PR, but I believe we should at a minimum. Umm? Contact the LBG and add a note. 2. Alderbridge 2713. Whoo, I don't want to do that. Now it's 2713. That copy this. P 1206 R sevens. New constructors are also affected. That's what we get for not solving it in the standard yet. OK, so let me double check these links open and open, Yep. And yet more missing allocator extended structures for our containers. It appears that P 1206 R 7 doesn't mention the signature, but it's consistent with LG 2713 proposed resolution and our implementation where we added such constructors and deduction guides without any comments. No change requested for this PR, but I believe we should add a minimal contact the LWG and add a note to LBG 2713 the P. 1206 or 7's new constructors are also affected. OK, let's do the right thing. OK, so let's make sure that each of these constructors otherwise has a reason for existing. If Dev people have containers ranges. So we have template on range in order to map from range T just a range. So let me switch over to highlight mode. We've got this one so far, the rest being defaulted. Uh, my base uses key compare Prime Pran allocator type print Pran. This insert engine checked. You begin, you end OK. Then, if we have an allocator. Here I want to scroll the right key compare. We need to use that L. OK, this is the one that does not exist anywhere yet. Uh, insert you beginning with. That's always going to be the same if you have buckets. That is this one here. Key compare allocator type. Because we don't have an allocator here, my base. Yeah, here's a good reason to audit everything to make sure we don't miss something. We need to rehash up to buckets and then insert a bunch of stuff, OK? If we have buckets and L, that's not this one. That's this one here. Size Tye followed by allocator. We can do that. My base key compare use that L, use the buckets and then insert OK if we have. Buckets and hasher that's up here buckets and then hasher. Uh, my base, so you got a hasher? Construct a key. Compare from hash Arg. And then we don't have any allocator allocator type on pren. Use the buckets, so we're using all arguments. OK, good if you have buckets, hasher, and an allocator Al. So that's not this one. There's no key equal. Yeah, it's this one. It's, uh, buckets hasher allocator. Size type hasher allocator. Yep, so that one. Umm, use the hash Arg. Use the allocator. Use the buckets. Insert OK, that's good. Let's go back up here. If you have buckets, hash your key EQ. That's this. Then let's use the hash. Argue the key eqr. We don't have an allocator, though. Rehash buckets, insert and then. If you have everything. Buckets hasher key equal and allocator buckets. Hasher Key Q allocator use all of them. Hash arq. Argall buckets insert good. OK, that was a lot, uh, let's see now guides OK? Guides can be simpler because we actually don't care about the values being cast as arguments. Uh, let me go ahead and expand this now. FFC flip containers ranges, so we're templated on range of support range range. Here we can have some default hash here. If you don't have 1 hash of range key type key, Q is equal to range key type Alec is allocator range to Alec type OK. It's interesting range to Alec type. I want to see what this is, but I do remember we used it elsewhere trying to think like why would the Alec type be different than? Oh, that's right because it's a pair. This will be OK. This will be V. This needs to be pair of constant K&amp;V so this alias is needed to form that obnoxious type. OK, so that's good. Enable if hash has got to be a hasher. Because we have a specific concept for that key, Q had better not be an allocator. Alex should be an allocator that looks good, so range. This guide size type prevents deduction in certain cases. We need that. Hashire Q Alec OK so this is the fully defaulted 1. The deuce unordered map from range key type range map type hasher key to Alex. We've got all of them. If we only have size type for buckets and then Alec. Then we have an unordered map of key diet map Tye from range hash of keytype equal to keedie because these are all defaulted and then Alec OK. If you have range and Alec, we deduce the exact same thing because the buckets don't influence anything. Yep. That's all good. And then finally, if you have. And Hasher and Alec. But no key EQ in there. Then keidai map type, use the HASHER, but provide equal to range key type and then the given Alec. OK, that looks good. Unordered multi map. OK so this is going to be highly repetitive. Again I am not too concerned about copy paste errors here because it's especially between the multi containers. It really is just a search and replace. There's very little go wrong so I will give this a cursory review. We're always saying multi mapped. Most I want to make sure we don't forget the buckets, so there's because that's like the one line I see that. We could forget and it would be very subtle. Uh, we're using the buckets when it's there. That's looking good. Yeah, that's good. And then the guides again. We should have those four guides before. Yep, 4 guides before. OK, so each of these unordered multi map. Yeah, of course we have to admit the same type. And. This really should just be a search. Replace key dot map type hash your key because we have them all here, we need to synthesize hash of range key type equal to range key type. But we do have the Alec. Uh, here hash Range key 2 range key dibalik. OK, because we don't have anything. If we have the hasher we can use it, but we still need equal to. We can use the Alec. OK, that's an order of map. Let's take a look at unordered set under 52 lines. Again, we can speed through this one fairly quickly. This one's a little bit different than the map, but not too different. So if we have nothing, use key compare allocator type. If you have the L, use it. If you have the buckets rehash buckets. If you have buckets, use it and all use it. When I Scroll down I'll like to select a bit and then that way I don't lose my place. So, buckets rehashed hash argues it buckets hashar al. K buckets hashar key QR, but no L and then finally buckets hashar key QR now OK. And of guides we do expect 4 guides, but now we don't need all that. Uh. Type 4 allocator. So if we have all the types, we can just reduce an ordered set. If you only have the allocator, then we'll use it, but we'll synthesize range of value T hash range value T equal to range value T OK. If you just have the allec again exact same deduction. And then. Here, if you have the hasher, use it, but otherwise synthesize equal to. OK, that's good, and allocator defaults to allocator ranges. Range of value T. OK, that's good. It really is, it is. Uh, less than awesome that there's no way to say I would like him to span out deduction guides for any combination of parameters here and including like defaults in the middle. It's just the core language doesn't have that, and honestly this cursor rarely the only place in the STL. This weird like super spammy set of overloads happens is in the unordered containers. This is by far the worst of them because they want to make so many things optional. OK, and then on order multi again very similar not to worry about copy paste errors so nothing here. Use the ASL. Use the buckets. Use the buckets, use the L, the buckets the hash Arg. Buckets the hash argue the L. Buckheads hashar key QR binol. Buckets Hashar key QRL. OK that's good. We've got induction guides again, four of them. It's always a murdered multiset. Yep. And all the types it's emitting are the same. As what we would expect. OK, that looks good. OK, so that's all the node based containers. Uh, let's look at deck which is quasi node base. That's a lot of changes. And well, 234. It's not that much. Yeah, it's more vector like because we we need some. Extra code here. OK so. Priority, ignoring white space. I'm already ignoring white space. This is as good as it gets. OK, this diff looks horrible, which makes me want to switch to before and after or side-by-side really. Yeah, let's do that. I'm reading this interleave code is obnoxious. OK, so let's switch over to deck. What is this comment here? Ohh, this is Misco saying refactoring the internal helper could be a separate PR. Yeah, can't argue with that. I wouldn't demand it, but it could be separate. OK, so uhm. I'm actually I'm tempted to view this in VS code, but I think I can view this on the right side of the screen. My screen is wide enough here. OK. So we're in deck. My least favorite container. If Dev, CPP, Lib containers ranges, that is the correct spelling. We have our new tag constructors container compatible range as the constraint construct from either range reference range and sometimes it comes out or found. My pair, either nothing or L, otherwise they do the same thing. Construct an AL proxy tie. And this is for leak protection. As usual container proxy putter, so we're going to install this a proxy for our iterator. Debugging into our get data. Then construct from. You begin you end Roxy release and which will actually make it effective. OK, that's good. Here's the refactoring where we're generalizing this Sentinel. It could take conventional and instead of saying initialize first class input iterators, the comment becomes initialized from input range first. Last. That's reasonable. We're going to call and place back internal. OK, so now we're adding prepend range. This is, we got to make sure we're in right access control, which I'm assuming we are. We are indeed public after push front. Let's prepend range. If Dempsey public containers ranges, there's the end of the guard template container compatible range. Prepend range takes a Range Rover range. OK, so we're going to do here. I could compare against something existing. This would look most like the insert, but it is special case to exactly prepending. I'll just review this because I'm familiar enough with how deck works. I think I'm familiar enough we'll see. So first thing we do is orphan. All we are inserting a bunch of stuff to the beginning of the. Deck deck has UM, interesting requirements or specification that. Inserting things at the beginning or the end of the deck does not invalidate pointers and references to elements, but iterators can be fully invalidated. This is because Dex elements are essentially allocated in contiguous blocks, but the blocks themselves are separate. They're chunked, and then the iterators can involve an intermediate data structure. In our case, what we call a map, which is really just a vector of block pointers. That intermediate data structure can be reallocated and that. Even invalidate iterator so that means deck along with the unordered containers. The only STL containers that can invalidate iterators without invalidating pointers and references simultaneously. So orphaning all is correct here, even though we're only prepending and the elements or otherwise remaining stable. OK, so next constant old size is my size. Let's have a restore old size guard. And we will pop from the front. This is some new machinery we added. I think this was Alex cutaneous PR to remove Sphene. I can actually let's bring that up because that was an interesting PR. Let's look at STL Inc deck. Deck doesn't change that often, so I'm pretty sure I'll be able to find it quickly. There's deck. OK, history, it's definitely not my little operator. Friendship is magic. Here we go PR 2308. Deck reraised to scope guard indeed. From our contributor Alex Butenyl V UH, which replaced. We used to have. Uh, the old logic tribe again, do a bunch of emplacement if something bad happened, pop a bunch of stuff, reraise, meaning, throw, and then catch end, and now we have RAII, which makes the code a lot clearer and better. When exceptions are thrown. And justice to save. And it's got a. You know, I'm, that controls how we pop if things go bad. So that's what that is. So if an exception is thrown, we want to pop. From the front because we are prepending, we're going to call it guard. Uh, initialize with this and our original size. That tells us how much we need to pop, so we don't need to otherwise record any other information. And then we have two possibilities. If we have a bidirectional range, then because we want to take our range and we want to prepend it, but we can only in place front, then if we have bidirectional range, we can start from the back of the range. And. Uh, push front to replace front in order, so that's what this is doing. So if constexpr we have a bidirectional range, then auto uast is ranges get final iterator unwrapped. This is that code that got moved constant to you first is EU begin, so we don't need any checking. We know it's a range while you first Nyquil you last. You last is the one that's being modified here, but we always see the order like first and then last. This is this is good. And then prepending order in place front internal avoids any checking. You last is. Cast the end and we know that we have a range. You first is not you last, so we need to unconditionally decrement and then we're looking at an element, and we can dereference it. So this is correct. Otherwise if it's not at least a byte irange, then we have no choice but to reverse direction. So here auto you first. This is the one that we're going to increment is you begin comes out of you last. While we have anything to do in place front internal. This says PREPEND flipped, so we're going to, uhm. If the range that we are prepending contains the values 1020, thirty 40 if we. If we in place front in order, we'll end up with 1020 thirty 40. So what? The deck will contain at the beginning will be 4020 or 4030, 2010. I can count backwards that's flipped, so we need to reverse it. So after we have successfully placed everything, and this emplacement could construct an object of a different type, it could be consuming from an input iterator, so we'll never get a chance to look at that. Tell you again, so we really do need to emplace, but once we have that we can. Do this stud reverse so this requires the elements to be. Assignable or swappable? Uh, I wanna say swappable for reverse, UM I do want to check to see if prepended range allows us to require that. I believe it does because it's similar to range insertion, but let's check the type requirement we can find out how many elements without having to have account because we can just ask what's our size. So my size, the current size minus the old size that we save. That's how many we just added. We can static cast that to different type store that in NUM and then this is where. We say stud reverse from begin begin NUM. Uhm? It is interesting that this is begin. This should really be unchecked. I think we can say unchecked. Begin here because like we're forming. I'm decorator, like, uh, they're expensive to check. Uh, we know that we're forming a valid range here. Now it is true that deck has not been thoroughly modernized. We we really modernized vector. We haven't spent nearly as many cycles on deck. This could be consistent with our existing code. Whereas the list has gotten some attention, let's see looking at the OK, like looking at insert. Insert just says reverse begin, begin, rotate, begin, begin. We do not try to call our unchecked functions, so it's consistent with precedence precedent. I don't think we're going. I don't think I'm going to ask for a change here, even though I think we do have. What is it unchecked? Again. Yeah we do and sometimes we use it. Primarily in move construction. Sometimes an assignment. We're not super disciplined about it. Sometimes, like a sign does. OK, we're we're just halfway consistent. Uh, we do use in spaceship. It's new code. Casey's writing a new code. I think I I'll mention it. OK Mr was asking about changes here. Uh, the different changes. I'll mention it. How do I wanna phrase this? I observe that. This. Reversal is using checked begin. But since we're forming this range ourselves, we could easily use. Unchecked begin. Uhm? Deck appears to be. Currently. Inconsistent. About UM how much? Effort to apply towards? Yeah, that's very verbose. Currently inconsistent about using unchecked iterators internally whenever possible. I see that some call sites do, but not all. Consider this. Uh, to be UM changes, optionally requested. I wouldn't. Object if you want to keep this as is for now, I can't really imagine that Casey would. Say yeah, I want to leave it as is because saying unchecked begin would be easy. It wouldn't. I as far as I know, it wouldn't have any other propagating changes. Just like a quick check to make sure we always say unchecked, begin and deck, but I won't demand it. Deck is not a paragon of performance to begin with. OI observed that this reversal is using check again, but since we're forming this range ourselves we could easily use unchecked begin deck appears to be currently inconsistent about using unchecked iterators internally whenever possible. I see that some call sites do, but not all consider this to be changes, optionally requested. I wouldn't object. If you want to keep this. As for now. OK, so after we flip your stuff I'm still going to check the type requirement, UM, regardless of whether we had bidi or not, we have succeeded so we can nail out the guards container, saying, OK, we're going to commit to this, and then we're done. So let's check prepend range. This would be in the probably a proposal. I could check the working paper. Let's see what the proposal has said. It would have been a diff to either deck or the container requirements. I want to say it's probably in. Let's check deck first. And this was prepend range prepend range. OK, this is talking about effects and complexity, but not requirements. So we gotta go to the overall sequence container requirements. OK, RG denotes container compatible range. We're on prepend range. Are these optional? They're probably optional because vector doesn't have it here. Go prep under range. Inserts copies elements range each iterators difference exactly once. No two *** note the order of elements in RG is not reversed. Thanks container deck forward list lists. OK, that should have been monospaced, uh? Or is the type requirement so there is no type requirement here. Interesting. Why are we not seeing this? There's some, there's something that's has something like this for vector. Let's take a look at the OR is it? Umm? Yeah, see like here. Assign range. Yeah, so like if I say assign range. I'm like a vector. This says for vector if R is neither sized nor forward, T must be move insertable. So this means if I can't instantly tell how big the range is and if it's not a forward range where I could just get the distance and see how big it is, then it's like an input only unsized range. I have no idea how many elements are going to be. Maybe they're coming from some sort of istream iterator, so I need to repeatedly and place back into a vector, but that could reallocate, so it's not sufficient for the elements to be in place. Constructible meaning in placeable from the iterator. They also need to be move insertable because reallocation will move elements, so that's where their type requirement comes from. That doesn't need that because it doesn't reallocate. It just allocates new blocks. However, this flipping is a new operation. Listen, let's see. Listen forward lists don't need it, because hold on. List can link elements in the reverse order. Now for lists can do that too. We can traverse forward but link them up the opposite way. I'm pretty sure that's what it. With that pre pen dots we if we have 1020 thirty 40 then as we consume elements were like 10 and then we change 20 we add them in forward order and then we and then we fuse them to the list whether list or forward list. So there's no difficulty. It's only for Dec only. Deck needs to flip. But there should be a requirement there. Would that exist? I'm trying to look for trying to think about precedent. Uhm, insert where comma first, last should also have the same requirement. Does it? I think let's see so. Yeah, here we go. Container insert where iterator comma I comma. JT's got to be in place constructable if you're a vector in a deck, you got to be move insertable, move constructible, move, assignable and swappable. That's I think some of these requirements are actually not always needed, but. In general, some of them are needed to reverse stuff more. Ah. Reallocate and insert range does have that requirement. So insert range is fine and it should be called out there. But Prepend I think. I think this is a defect in the wording. Clearly the implementation is doing the right thing. There's no other way to do this. Yeah, that's a defect. Deck needs that additional requirement. Let's see if this has been patched, otherwise I will ask Casey to file an LDG issue. Ohm. OK, it's not just a code review, it's a standard review surprise. Uhhh, OK, Container Library 424. Let's let's see quirements. They actually reformatted reformatted this from a table, a horrible table into something better. I think it was optional. Container requirements. Nope, not that optional. Umm? What was it? Optional sequence container requirements. I'm looking in the wrong place. Uh sequence container. Here we go. We're going to maximize this for a second. OK, so. Like do not wanna highlight OK on selection. We are on prepended range. Here we go prepend range. Preconditions T is in place constructable required for deck forward listen list. OK so it is a defect in the current working paper. OK, so let's get the section. Wow, paragraph 94. I guess that's the downside of breaking up that enormous table. OK 24 two four sequence requirements. OK, so prepended range I can comment on the flipping. Which is this here? There appears to be a. Wording defect here. Ah. And 4910 I'm pretty sure I'm not transposing digits there sequence requirements. I can also cite the live standard on eel dot is. It was like paragraph. What 94 something high, let's see. 94 text mines. Make big. OK. Slash what? What 95? 97 says. A prepend range only care about 95. And 97 whoops. These are italicized. I don't even need to look. I do need to look for the rest of the formatting. UM, place Constructable is italics. TX ranges begin, and the types, so we've got. Tea. X. Ranges begin range CP 17 in place. Constructible is a towel sized. Forward less and less. OK. Alright, I was going to get the short link to this. 21 dot link slash sequence dot requirements load the live draft standard. Scroll down to. 95 and 97. No, that's gotta be square brackets. It's like something's wrong here. 97 however, there should be additional requirements for. Deck uhm. Possibly only when the range. Actually not possible because we can cite the other one when the range is weak. What was the precedent we found it was the assign. Can I find that quickly? Assign assign range and there I can point to the. This is new wording. So the insert one was even better because that one talked about swappable. Yeah. Interesting, this one doesn't say uh about signed or unsupported was the. I thought we saw wording that said if it's neither sign or neither sized nor forward. Uhm? Size range. Yeah, here we go X from range RGB. Assign range. Yeah, so it's really. I would want to ask for both, like this constraint about neither size nor forward. Actually here it is, not size. We don't care about size, we care about Bidi. Umm if it's not bite I then we gotta do the reversal. Yes. OK, so we're going to do where's the swap ball. It was insert. Here we go for vector index swappable. OK so 41. Scroll up here and get the original text. You can copy this. Same section, so I'll just cite it as slash 41. And instead of weak, I can be specific and say not a bidirectional range. Not. Bidirectional range. Similar to how 41? Says I would say it requires because that's the term of art. Uh, preconditions, I'll chop this out because we don't care. Da da da. And chop out the range in a OK. I forgot. So for vector and deck this is unnecessary, but I do like my standard citations to look pretty. It's gotta be moving insertable into X. It's got to be move constructible. It's got to be move, assignable and swappable is not italicized. OK, we just swap requirements. OK, and I did say similar, so I'm not mandating excuse me. That would be exactly that, UM. I will phrase this as a question should we file should we should? Should we file an LWG issue? OK, there appears to be a wording defect here at W. 21 and 4910. Seek requirements 9597 says a pretender range preconditions T as in place, constructible X range begin marks required for deck forward lists and lists. However, there should be additional requirements for deck when the range is not bidirectional and similar to how 41 says preconditions for veteran detectives also move insertable index move, retractable, move, assignable and swappable. Should we file an LDG issue. Let me double check, uh, these links make sure I didn't mess them up so the working paper. Yep Yep. Yep, OK, we're all good. Added. OK, that was repent range for deck. Let's see. We've got a little bit more time. I think I can get through. We'll see if I can get through deck if Dev, CPP, Lib, container ranges. Now we are appending range given Range Rover Range again we want to orphan all iterators because we are going to modify the size of the deck by emplacing consider old size is my size auto you first issue begin consulto ulas is you end restore all size guard. We're going to pop if things go bad this old size. Four, as long as first does not last, increment you first and place back everything. If it succeeds and all putter, OK, nice and simple. In place fun front we can refactor to column place front, internal. Overhaul in place for internal doesn't care about orphaning. Then we do this. This should be a pure code movement and in 17 mode we return front. OK resize. OK, so resize the refactoring here. We need to orphan all because in place back internal is not going to handle. I'm assuming when it's extract it's not going to handle any orphaning, so we should do a single orphaning and then in place back and that's the reasonable. It's better than repeatedly and placing back in that orphan, that's why we didn't bother before, so that's actually an improvement. OK, so we've got in place front internal here. We've got large code movement. I always want to make sure we're not damaging code 99% of the time you're fine, but we gotta catch that one. Percent where things are damaged, so I'm going to copy. You can't see what I'm doing. Let me move this over here. So this is old and lace front. Old and place front. Shouty comments remind me that it's not actual code change to CPP that's control KM. Here's new code. OK, is that the same level of invitation? The code is so good enough. OK, let's differ. And what do we get here? We get a little bit of OK, so there is some change, but it's OK. Change UM, this is now templated on class data. dot ties, void under score and place for an internal taking ties valves we add cons to the size type block that is an improvement because we don't modify that and then clang format. Readjust the spaces, the type and the arguments are now ties and valves. This name is new. We've never said ties before. I think we usually say types. Size is actually fine. It's probably better than what we've been using. I have no objection. OK, so that's a good code movement. Umm, OK. Let's expand again, Umm, so we just did in place. Front internal. Uh, now? A sign I'm assuming we're going to. OK, we're extracting something out assign range. Which is essentially the common version of a sign, but can handle different Sentinels. That's why this exists. OK, so we were public. Implementing pop back, so that's fine. Uh, we're going to jump into private and then go back to public. OK, so template class inter class sent void under score sign range take interfirst consent last. Same orphaning but instead of addl verifying and unwrapping and unwrapping, we're going to assume. That first and last are already unwrapped, because that's. What happens here? We verify and unwrap or just pass unwrapped O that's why we don't need to verify and unwrap here we do need our own unchecked begin and unchecked end. OK, so now the comments are changing. But the overall structure of the code is not. It's changing a little some of the some of the increments changing so. This overall thing is trying to reuse elements. We used to say try to assign over an element in the container and then if the container is too. If we run out of elements, we need to insert at end. So actually the control flow is changing here. The control flow is changing. It used to be try to insert everything, but if my first. Is equal to my last. Then I've run out of container space South. I need to inplace everything at the end. And then once we're finished consuming values, UM, if we're still not if we consume all the values from the input range without running out of space, the container we need to cauterize the container and chop off any elements that we don't want. So that's why the erase last is here. This is now being inverted, so there is a significant control flow transformation. I have no objection to this, but I want to make sure that I reviewed carefully, because this is where bugs occur. It's so easy to mess up control flow. So here as we iterate, if we run out of elements to consume. Ohh and what's interesting is actually iterating over elements in the container, not elements to consume. So that's why this is being transformed OK, and so this comment. These comments are good, reuse existing elements versus allocating elements. I'll double check that. OK, so same philosophy, but everything is being sort of flipped around, and the overall result is about as long, maybe a little bit. Sure, so four we've already initialized. As long as my first my own container first is not equal to my last. And then as we proceed, we're going to increment my first, so we're looking at every spot in our existing container. As long as we have existing elements, we're going to increment my first look at a new value, and we're going to increment first, which is the thing that we're consuming from the input range, and we want to put a void cast in there to avoid overloaded operator comma. So we know that we have elements in the container, because that's our loop condition. But if we run out of elements from the source range first equals last, then. This is the cauterization step where we have extra elements that container. Potentially we should get rid of them, so we're gonna call erase last end static size type my last, minus my first because we've incremented my first. So my last minus my first is the remaining number of elements, so this is correct. It's still correct. After doing that we should return. But if we have not returned, then we have an element in the container. We have an element in the source range we should assign to it. Do our first, assign that to. Do our my first, then we're going to increment both, so that's good. This is very structured. I like it. And then if we have. Used all the existing elements in the container and we have not yet exhausted the input range. Then we need to allocate new elements for remaining tail of values. This is fine. Allocate new elements. It kind of implies there's an allocation in deck. There generally is every 16 elements or less. This is fine. I don't think it's confusing. If if this function we're concerned with, like memory allocation directly, I would want comments that distinguish when we're allocating versus not, but this is clearly implying an allocation some of the time, so this is fine. So for now we're gonna consume elements from the input range first, Nyquil, last, increment first, then just in place back internal, and we've already orphaned. So this avoids extra orphaning. That's good. OK, so now go to public template. This is the existing ITER need to enable if iterator. This prevents ambiguity with a sign like and copies of VUM so sign for slash, verify the range, unwrap them, good if Jeff split containers ranges endif assign range is constrained call you begin UN no verification. OK, and now. Insert looks like it's getting refactored as well. We now have an enum class is bytyqi backed by a bull. Defaults to no one, yes. No, should be fine now. We used to have a problem with macros, which is why the STL currently says Nope and yes, but that problem was fixed in an unrelated project upstream, so we should be able to say no again. So this is being generalized to handle. Iterator and arbitrary Sentinel. But we also need to be told is by dye. Because we've got if constexpr down here. OK, and we've already seen the requirement in the global wording about needing to swap, so I don't think we need to double check that here, so this is still. Well, let's see, are we still doing private helpers? Yes. OK, so we're in private here. So template is bite. I intercement turn iterator insert range and instead of taking where we're going to say off an offset concise type off and then interfere set last. It is interesting that last is modifiable. Everywhere else last has been consed. Are we modifying? Last comment, use it. Use it. Oh, we decrement OK, so we do actually need to. So that's why it's modifiable. That's good. This is a good consequence of consistently marking value parameters. This constitutes when they're not. That indicates getting modified. Insert inclusive first, last exclusive at begin, plus off OK. Uhm, so the comments has changed. We already have off, UM. We still want that iterator debug global check. Get hot resetting, Umm, comments good. We've calculated off got the ideal check. We don't need a deal verify because we're gonna assume everybody's on ramped. Umm? But we do want to see if we're going to insert nothing if first is last. Then presumably this protects something below that would be wrong. Also we do skip orphaning so first is last you're asking us to do nothing so we can form an iterator return begin plus Statcast difference type off OK because if you insert nothing you haven't invalidated so. That seems fine, so no verification. Early exit old size can now be confused. That's good. Do orphan all. If off is less than old size because we've captured old size, so this is actually just a straight up. Umm, clean up slash improvement. Why call my size again when we have old size close to front push and rotate? Ah, but there's an improvement here. Previously, we would always in place front and then reverse, and now Casey is using our magical powers if constexpr to avoid that. At the end, we'll do the flip. OK, this is good. This is actually improving. Interestingly, it's improving the behavior of existing code, and for a common case, because biday iterator is the most common, because the random access and pointers are also bidding. If constexpr bidi equals is bidi, yes, this is the advantage of having a named enum class consume all the elements in place. Front internal. Dref redeck last, so that's going to look at every actual element prepend in order. Yes, because. By Prepending from last they they end up in order. I'm trying to make sure the comments aren't flipped. Otherwise if you're not by dye, then you just need to in lace front starting from first, but it ends up flipping the order of elements. OK. And then. Here we have at least attached all the elements, so we nod the guard. It is interesting that we decide to do this and then we start reversing. I assume that swapping is required to be. All these swap they don't assign. So these this is actually no throw down here. I was wondering what happens if you successfully in place all the stuff, but then an exception is thrown. I don't think we have to worry about that and certainly the existing code wasn't OK, so. We calculate NUM. Why do we need numb? We need from mid. We definitely always excuse me. We always need that. We're doing insert range OK so. Uh, this is now going to be auto because this could be some arbitrary sort of size type like thing. Consolato NUM is static cast difference type my size minus old size consolato my first is unchecked again because we're not working with iterators anymore. We started with offset. OK so NUM is. The number of elements. My current size minus old size that we just in placed my first is unchecked again. My mid is my first plus NUM. If we are dealing with non bidirectional iterators then we need to reverse stuff so stud reverse from my first to my mid so our current beginning to the end of the new elements we need to flip them. So that's right. And then. Now that we've got the right elements place we need to do a rotate to actually get them to the right position given the offset. So that's the stud rotate, which we were always doing before my first, my mid my mid plus off these are unchecked. So here Casey is using unchecked iterator. So that's also an improvement compared to the oh this is this is the some of the president. I was looking at was like oh there's a bunch of begins. Well, they're actually turning into unchecks, so. There actually is some down here. Hi Michael, Michael back and edit that comment UM. Because it's sort of a semi global thing. This one certainly doesn't need to change. I'll maybe just comment this one, uh, because that's the only other case. I'll look at this in a SEC so stood to rotate from my first to my mid. It needs to go to my Microsoft. OK that's good and then synthesize the return iterator. OK, So what was this? This is if it's close to front, push to front, then rotate. Otherwise this is the opposite. Restore back. For, the iterators aren't checked here, I'm comparing first or before to after OK the rotate. This is just getting horribly reformatted. Began OK, so this code is really not changing at all and then return off. OK, that's good. I was going to check to see how many other begin uses there are. Comment return unchecked. Begin return. This is the one that's gratuitous return. Umm, I'll comment on this. I observe that these could also use. Unchecked begin. As the rest of the function is being. Improved like that. I observed that these could also use unchecked begin as the rest of the function is being improved like that. And here we just don't happen to have unchecked to begin out here. We could actually lift this up. Oh no, we couldn't. We needed to have it after we've been placed otherwise we get invalidated. But we could just call and check again, or case he could lift it out here. OK, so I had a comment. OK. And then simple extraction here go to public template ITER constrain to be an actual iterator. Insert first last at where input iterators. This this comment used to exist when we had tag dispatch. Do we still need that? And we weren't dispatching here. I question whether we need input iterators. That's the only comment in this file that says input iterators. Old code, old code. Yeah, this is the only new one. UM, I'll simply ask, do we still need the. Input iterators comment. Since we're not dispatching on. Iterator. Strength. Here. Car. We're handling. My diness we're handling. High directionality, UM within the upper function, OK. I don't want to say comma. I wanna say comment part because I only want to talk about that. But do we still need the comment input iterators come into part. We're handling bidirectionality within the helper function. OK, so template iterator enable if iterator iterator insert counselor aware it first and last insert inclusive first last exclusive at where input iterators probably don't need that. Verify the range then we should unwrap. On size step off is static cast size type where which is. Regrettably, checked minus begin. Return. Insert range. Static cast. To is bite eye when does ohh I see is Biti interv is our helper to see. Are you Bidi iterator but we need an enum class. So we need a static cast that is byte. This assumes that his bite eye occurs in the order false true, and it does. It starts with no. It says no, and then yes, so false is zero. True is 1, so that's fine. So we can static cast. And then. Off getting wrap first get unwrap last. OK, that's good. If Dev cycle container ranges template on range iterator insert range. Consider aware Ranger for range. Umm? We don't have a parent check here. We don't have a. We have a parent check here. Ah OK, it's happening within the subtraction iterator. Subtraction will check that they belong to the same container, so we don't need an explicit parent to check for where, so that's good. OK, so where range still want to form concise type off? Same way if Constexpr bidirectional range. Then OK, we do need special cases here, because if you're bidirectional you can say insert. Yes, it's bite. I give the off range as you begin and then ranges get final iterator unwrapped. Because if it's bite I we want the so it's what Casey's doing here is if the range is bidirectional then what we want to pass is the actual final iterator to that past the end element that we can decrement even if the Sentinel with some other type. So that's what ranges get final iterator unwrapped, does and why. We're not simply saying you end, but if we're not then we can just pass the Sentinel unchecked. So. That is good. This occurs infrequently enough. I'm wondering should we have a function that just handles this, but this seems to occur infrequently enough that we don't need. A helper function to do that, and then the last change to this file if declic containers ranges, we got a deduction guide template on input range range. Class Alec is allocated for ranges range value T enable. If Alex got to look like an allocator deck from range T range ref ref. Alec is Alec front prend deduce range value T and the Alec Endif CPPIB containers ranges looks good conversation was this? Variable templates ohh yeah, we don't have an allocator VUM OK so that's DAC excellent. So we've got 7 more comments. Uh, let's see. I would want to actually mark that as viewed. Let's minimize everything. I do want to summarize, let me open up my editor because I. Was trying to remember what I had reviewed. Uhm, OK, so let's split this. OK, so. I'm just going to. Record algorithm. We've got deck. Poured list. List map. Sat unordered. Map and set. For unordered meows, I call them U MX hash. Xtree extra utility. 5 Valves Core H. None of the tasks. And the feature just backwards does. I'll just say feature test macros tests. And for my own organization. I will group these that is extreme map set that's X hash. You map you set. OK. Great. And I will submit this review. Another partial video review. Fee and more progress. I've reviewed. Blah. I should have marked down this. I can do this faster in VS code. I love multi multi cursor editing. Uhm, I won't bother, UM. Actually, some of these those underscores might be yeah, fine. I need to tell it that this is marked down. And I want to. I shift click now. Can I control click no? Not doubleclicking? Interesting, I'll just go like this. Tell. That was correct, OK? Review another partial video review and more progress. I've reviewed all these headers and then featured this macros tests comment. OK. Hesitating only because I know if I write a comment here, this cannot be collapsed later, but that's OK. It's not too verbose, I'll comment. OK, So what we found. To summarize, we found some comments or some assertion messages that seem to be completely damaged during copy pasting. This one was the same sort of deal. We found signatures being added that are consistent with our implementation, but we really should update an LWG issue for it. We found that we could be calling unchecked begin in a couple more places. We found a wording defect in the standard itself, saying that elements need to be required to be swappable under certain conditions. Another unchecked begin and then finally a comment. So overall nothing major. If anything, we found more issues in the standard itself. And just some assertion messages. So overall this is looking real good so far we are slowly getting through this PR. We will see if I can finish reviewing this or if we will have an unprecedented Part 3 for video review. So I hope this has been interesting and we'll see you next time, thanks.