Hi and welcome back to another VC libraries Open code review. Today we'll be looking at PR 3322 by our contributor Tyler Brawl and this is implementing another part of the paper HE2321R2 adding another views to the view to the ranges libraries to views zip transform. So previously Tyler contributed the zip view and now we've got zip transform. We just does something a little bit different. He's got a very nice PR message here that's explaining all the stuff that's being implemented. So we've got the our tracking issue 2252. That lists the overall paper. I can open that up and associate LKG issues because this is only implementing, as I recall, one out of four views we've got zip view, zip, transform view adjacent and adjacent transform. So this is basically Part 2 out of four, so we won't be seeing the feature test macker here. We only define those when the feature is fully implemented. But there are some LWG issues which are bug fixes against the standard that are relevant so. Let me open up, please. OK, so we've got the paper as a whole. We've got two LWG issues. Tyler also notes that there is usage of decay Copy language feature that's in C + 23. The compiler doesn't have that. So. So Tyler is implementing this essentially manually, which is a reasonable workaround. So let's take a look at these LWG issues as a quick refresher. This is getting rid of some comparison operators because they can be. Umm generated for us I believe. Let's see. OK. Yeah, yeah, we we only need to provide equal and spaceship. So this is simplifying and then this one. Is changing one of the requirements from copy constructible to move constructible? Umm, it looks like there were simply on. A missed edit from a previous patch paper, so hopefully this wording has been integrated to the leaves working paper. We just got a new working paper 4928. This is now linked from our repos readme thanks to a new contributor who updated our README so I can go over to rain zip transform iterator and look for the wording. If the if this working paper 4928 UM has been updated, then we only need to look at it. We don't need to look at all these LWG issues as well. Hopefully this is the correct spelling. If not, I'll open up the bookmark. There we go. OK, so sorry for jumping around. In the synopsis, we should be seeing only equal and spaceship. For the zip transform view iterator. So this is zip transform view iterator Scroll down. Equal and spaceship OK, so we're only seeing that. That's great. This issues integrated and the other one is in a range of transform overview. Which is. Below now this is the iterator. Scroll up Yep, ranges of transform overview and bullet .211 says if move constructible. Two on one if move constructible. OK, so both of these issues has have been integrated into the latest working paper, which is great. We only need to look at the final fused version. This is the original proposal. So zip transform view. Is. Uh oh, this is a sorry. This is a patch paper. OK, so this is also definitely been fused in. This makes the zip transform view constrained on move constructible. As of transform view. This is, yeah. Is it transform view is constrained to move constructible. So this catch paper has also been integrated. Great. So we don't need to go look at 5 different layered things or whatever. We only need to look at the latest WP. OK. And then other contributors, Frederick SA, Tim Song, CPP have been reviewing this greatly appreciated the PR has already been revised. So I will now start looking at this. So let's go over to files change. Umm. So I think forger lines of product code and 800 lines of tests are there about. Let me split this. Side by side view OK. OK zip transform view, where is the synopsis. Ranges library. Sometime I'm gonna faster quickly scanning through this. I'm like, whoa, ranges. I haven't seen these points before. These are adapters. Zip, transform, view as a lot of adapters. OK, so this is the actual section. Oh, but I wanted the overview. Here we go synopsis. Let's see. It's a little bit annoying that things are sort of split, but this is just how the standard specify stuff. OK, so here we go. On the other thing, of course, we want to look out for is modules. We want to make sure all the standard identifiers are exported. I believe this should just be the classic transform view and the actual views of transform. So I'll look out for that. Maybe I can actually scan for it now. So I don't forget. Umm, this is grinding friendship. Zip transform view itself is exported perfect. The great thing is that that applies to all the Member functions. All the nested classes, so we don't care about any of them for the purposes of modules don't need to, can't in fact can't export deduction guys, they're just automatically attached, and then the actual zip transform is exported. OK, so modules is perfect. OK. Nothing else is going on up here, so we can go directly to the specification of zip transform. That was in adapters zip. OK, welcome back to this. OK, so let's look at the easy files first. Uh, why versus core has a comment on what's being implemented. Use zip transform is being implemented, so we dropped that and we just say missing views of JSON and views JSON transform without a comma. Perfect, no feature, just macro update at this time as I mentioned. A new test is being added so Tyler is updating test dot list. This is great. This makes sure that it will be picked up by the new test harness. It is in sorted order. Clearly the spelling is correct. That's perfect. We've got list of compiler options. This looks like the previous zip one. I this does require strictness. I think this came up with. The Zip view review that it is incompatible with permissive minus. I think I will do a quick refresher and see if we can find that just so we're. Remembering what it is, it's not open anymore. I think Tyler might have liked this from the PR button. I'll just search for it from scratch. OK this one. Is October. October is like a lifetime ago. I can't possibly remember anything that helps. OK, I'm gonna scroll through. I guess it would have. It would have come up in for that list, but UM. OK, we didn't have any actual comments there. Did anybody say strict? Nope, nobody said strict. Maybe this didn't come up. OK, it wasn't actually called out here. But I seem to recall that it also had strictness. It did require struct. OK. Ah, this comment explains it. That that's that's why I was remembering. It says zip. You iterator defines ADL overloads argument dependent lookup for ITER swap and it remove. That's why it requires strict mode. It's not unique to zip. You all view types whose iterators defined overloads. OK so is that true for zip transform view we've got the standard specified zip transform view where is its iterator. Here's iterator. If there's ADL overloads for ITER, swap and move, then that causes the problem. I'm not seeing it yet. Is that out? This is the class, so you wouldn't get ADL overloads here. You would get them at top level. That's interesting. Sorry for scrolling, I know it's hard to keep up on the video. Ah, am I missing anything here? This is the iterator. This is the end of the class definition. I don't see it or swapping move. Here's a Sentinel for zip transform view. Some operator minuses equals. OK, that's interesting. What does zip view look like? Do they differ here? Uh. This one doesn't define its own iterator type. I was, if you does not ohh because it. That I catch that no zip transform vehicle. I know it does, it does. I I was just. I was just scrolling Ohh. through it. But I didn't see an inter swap and move for it, so here's the transform view. It makes sense that there wouldn't be in it or swapping move. Much like for about their regular transform view, because OK. Uh, because you're transforming. the the the result of dereferencing the iterator is result of calling a function. So it remove and ITER swap wouldn't make any sense, right? Right, you're. There's nothing to move or swap. There are ephemeral results. Yeah, you're. Yeah. You're making. Yeah. Phantom. Yeah. Phil is a good word. OK. So that's interesting this so that indicates that maybe this does not need to be stripped. So the question I always have when I see something like this where this came up a while ago. So where we were using the strict matrix, meaning requiring permissive minus on everything a bit more than we absolutely needed to, and we grudgingly permit CPP latest with the permissive mode. So our new convention is to use just the concepts latest matrix whenever we can and only add the strict part if it's absolutely necessary. So it wasn't necessary for zip view as Casey mentioned. And I eventually Yeah. deduced there is an asymmetry here. It should probably not be necessary for zip view. And if it is, we'd like to understand why. Umm so I will link. You can probably click on that resolve comment of mine. Which is asking does this really needs the strict matrix? Ohh. Oh, here. Oh, here we go. OK. There's there's Nicole asking Ohh no it isn't. I can't believe it and so it down. and then talk about this. You did comment, you talked about author, strict Meow crackdown. And. See. Yeah, it is specifically it removing your swap. Yeah. So I I think I think it should not necessarily be. Required here. Yeah. So I want what I want to do is I want to link this thing while it's. I'll just look for views zip. So let me go back to the room, the repo because I don't know how to get to this faster. Got a code test test. Like for views zip. There we go. And list. Get Y for permalink. Copy or shift select this OK. OK, so close this first comment. Is the strict matrix required for. Zip. Transform. Zip needed it. As explained by. This comment I'll say this comment, even though your comment would also be applicable. Blah. However, there is an intentional. Semetary between I'm zip and zip. Transform. And that uh, no. Zip transforms Iterator doesn't have ADL overloads of. Enter move. And it or swap now credit Casey as Casey Carter explained, zip transform produces. He femoral. Results due to the transformation. Umm. I'll just leave it at that. Therefore. Uh, and saying therefore, can we remove the strict requirement and have the tests still pass? Or is something else? Blocking it. OK, phrase it as a question. Let's make sure this is all not typoed. Is the strict matrix required for zip transform? Zip needed it as explained by this comment. Explain ADL overloads. Strict leads matrix. However this is on. However, this is unintentional. Asymmetry between zip and zip transform zip transforms iterator doesn't have a DL overloads of ITER move and ITER swap, as Casey explained zip transform. Wow, that CSS is getting really messed up as case explained zip transform produces ephemeral results due to the transformation. Can we remove the strict requirement? Have the test pass or something else blocking that? OK start review. And then to avoid overloading the compiler, the test is split up into a bunch of different parts. This is copied from the other tests, and I assume it's still necessary here, so I'm not gonna question that defined to Simply put forward bidirectional and random. OK, I'll keep a lookout when we actually review that and I forgot to check, we do have our copyright license banner here. Perfect. Same for the test. I'll quickly look at that. I'll go to the product code next. Copyright license. OK, looks good. OK, let's look at the product code. OK. What are we looking at here? Maybe can I move the splitter a bit? Uh. OK, that kind of helps. It's a little bit small. Yeah. OK, I know that's really small, but I'm mostly focused on the code right now. OK, so what's happening here? We got the classic original zip view. Iterator is now granting friendship. And it is granting Tim highly templated friendship. So unfortunately we do have to say class here. Uh. Granting friendship to this thing. Interesting. OK, so this should all match template move constructible, under score capital, funk import, range, dot under score capital views. I'm not super happy that this has views. Instead of you types. I would prefer for this to be exactly copied. Requires view of views and da, da, da and size dot that thing is greater zero and as object V here I'm just mentally diffing or visually diffing. Yeah, and I'll looks good and can reference. Yep, that's all the same. It is indeed a class. The only thing I have a concern with is views versus view types. Maybe that was done to avoid wrapping. It seems that these are almost exceeding 120 columns and that if it said view type should wrap, my psychic power is is they're telling me that this was the reason. So. Yeah, it's getting pretty close. Uh. Maybe not too much. It's only mentioned once. If they said view futures, yeah, that's the thing. I can't even spell. What's my brain doing? No. Have you tried to totally fit? Yeah, this should. This should be view types. I don't see any reason for them to differ. I'll comment. It's an epic. Let me get this. Nitpick this says. Here I copy paste to avoid typos views instead of view types I. Although. This has no mechanical difference. But I would prefer to see the UM. Friendship exactly match the definition. OK Nitpicked this as views instead of view types. This has no mechanical difference, but I prefer to see the friendship exactly match the definition. The only reason for them to differ would be is. If oh oh, that's right. OK, there is a reason I just had to scroll up. We're not in a top level class here. We're in a nested class. This is iterator is Const, but it's nested within zip view and that is templated on view types. OK, so you can't reuse the identifier view types and in other situations. Usually when granting like shared putter friendship to another type will say like other. So that's why I was momentarily caught off guard when I didn't see other here. Umm. It is reasonable to say, oh oh, there's a data member named views like whatever we choose, we lose. Is this technically shadowing? This is using the identifier. As a template parameter. And there's a data member name views. I don't know if you can necessarily take the decltype, but this is too close to shadowing that I like. OK, so there's a reason for it to be different, but I don't like views here. If it said other views, I would be OK. Yeah, other views is probably the simplest way to handle this. OK, let me rephrase this. Nitpick. I realized the. Let's see. I see that this is avoiding the name. View types. Get back. I see that this is choosing a different name for. View types. Which appears. In the parent class zip view above. But this is slightly confusing shadowing. Because the parent class has a. Views. Data member. I recommend choosing another name. Such as. Under score other. Views. UM. We have a good example. Uh, let me search in the repo real quick. Here we go. I was thinking other ties where we usually see this with friendship. We we have an span. Of this is a converting constructor. I think we might use tire Utah for. I shared putter. I think other views is fine. Which? Well, avoid all shadowing. And make the renames purpose slightly more obvious. OK, perfect. Nitpick, I see that this is choosing a different name for view types, which appears in the parent class view above, but this is slightly confusing shadowing because the parent class has a views data member. I recommend choosing another name such as under score capital. Other views, which will avoid all shadowing and make the renames purpose slightly more obvious. OK. One declaration down, friend. Grant friendship to zip transform view interesting that there's a relationship between the iterators. We'll see. It's interesting that nothing else is ohh if zip transfer of view needs to reach into this, that's why. OK, so we're gonna expect zip transform view to need that iterator. OK does have an interview. OK, it's gonna be why. OK, so onwards. See, I know the standard is a small here. I don't want the code to wrap if I can avoid it. Maybe that's the best I can do. Maybe zoom out a bit. OK. OK, so we've got the export. As previously mentioned, we've got let me switch over to highlight here. OK, we've got a template move constructible, F is move constructible, under score capital funk input range dot under score, capital view types OK. This requires that all those view types be a view and da da da. And that we have more than zero of them size of dot dot views is greater strictly Brian, Zero and F which is funk has got to be an object type and we've gotta satisfy the regular invocable concept funk ref. So it's gotta be an L value function object range reference T views dot Yep. Here I'm making sure that we've got all of the lvalue references and so forth because they are important when asking all of these concept questions and our internal helper concept for can reference the invoke result type of funcraft, which is freff on range reference T. OK, so all that exactly matches perfect class zip transform view. Ohh, I'm looking at the iterator, but it matches the parent as well. Uh. Yeah, this is gonna be exactly the same. So Yep. Classic transform view there is publicly from view interface that transform view function view types. Yep. OK, so private data members and whoops, sorry aliases using under score capital interview is zip view of view types dot. OK, so that is this interview exposition only. And then coming down, unique counteracts, which we'll use someday movable box, our helper machinery templated on funk, this one called under score capital function. OK and then we've got the interview named under score Capital ZIP, OK. And then. We've got these separator and the Sentinel. I think these are actually the same names as in the others. But they're actually in the standard. That's great. OK, so template and we'll const using under score capital zip erator is an iterator, T maybe Const is const interview and then template on bool is Const. Still ugly Sentinel as the Sentinel test of maybe consists const interview. OK good. And then. We've got the template boys Const. Our category base that's going to help with getting piped defs. I guess this is specialized specialized below. Iterator. Sorry, I'm scanning below. Here's a Sentinel. Ah, do we ever specialize? OK. Let's see, where do we specialize? Ohh no, this specialization is immediately below. Yay reading comprehension. I was just like I was expecting something small. And so when I saw this big thing, my eyes just glazed right over it. OK, so we got category base. We'll see what this machine is doing. This is going to be needed for presumably the iterator. Yes, the iterator. OK. So let's start reviewing the iterator. Down here. OK, so template on both Const. Is it transform view iterator? OK. And then iterator category is the thing that's not always present. OK, here we go. The member Typedef name iterator category is defined if and only if it models forward range, so. The specialization. On template Bullis constant requires forward range. Umm, the base scrolling up which is maybe Const interview? Maybe Conn's interview OK. So when that's met, then we have the iterator category, so that's why I'm doing here. OK, let me go down Umm so base models forward range which it does and in that case it or categories defined as follows. OK so we've got this here. Umm using iterator category, so this is. Wow. Uh, that's a big Lambda using iterator categories. The decal type of an immediate invocation of this puppy. Praise print, print. So we're doing a lot of computation here. This looks horrible, but it would have been way, way more horrible without lambdas and decltype, and if constexpr. So this is actually not as bad as it seems. And it's mapping all these bullet points, hopefully pretty straightforwardly. OK, we have a Lambda. The no except here is kind of unnecessary because it's the type computation, but it's not wrong, so that's fine. Let's see if. OK, so invoke T under score cabinet. Invoke T is the invoke result of maybe Const Const F ref. Invoked on a range reference T maybe cons is Conn's view types dot. OK, here's here's one of what I'm checking for is. Is there any obnoxious repetition that could be extracted out? There's a little bit. And this may be const. Ohh no, it's it's not really extractable. This is being pack expanded because there's a whole bunch of you types we need to spam out range reference key of maybe Const is view 0, maybe Const is Const view one blah blah blah over and over. This one is expanding something completely different derived from and dot dot dot so there's no extraction possible with like a type def. That's best we can do. With without like an alias template. OK, so that's good. If that thing is OK, we've got that invoke result. If it is not a reference, not is reference V. Then the iterator category this Lambda is going to return input iterator tag OK if constexpr, else otherwise. So this is the else branch. Umm. We're going to have a context for auto. We've got a nested Lambda here, and then we're going to do a bunch of stuff. Interesting. And we're feeding it an explicit template argument rather than tag dispatch. Yeah, it's it's horrible and syntax, but it's reasonable. OK, so let's seize denote the packet types, iterator traits blah. OK, so this is asking. That's this thing iterator traits of iterator T. Maybe Const is const of U types. OK. So seizes that. Oh, and we need the iterator category, so type name iterator category. So this is the C. Which we can't just extract as at the pack. So this is saying concepts per auto, under score, capital check, tag type closure where Lambda taking template on a tape name tag type. Conventionally we always say class here, but explicit template parameters for lambdas are so novel. I don't you know if we have any of the product code. I personally prefer type name. We just tried to enforce code conventions. Do we have any lambdas? Should this nested landed? Should this nested land to be a variable template instead? It feels like it could OK, we only have one and it's in the, UM, one occurrence of tightening. At least it's in the test. It's a good question whether it could be V elsewhere. We have used class. OK, so I think stylistically asked for class, but you've got the better question rather than my silly syntax level question. Could this be a variable template? The pencil. In which case we wouldn't need this horribleness. Umm, but we left this out. Yeah, that, that's. Yeah. The explicit template argument list for a Lambda is just a Every. horrible. It's. Yeah, it's syntactically horror. I mean, it's a very clever solution. So like this is and it it's definitely it's translating the machinery in the standard well, so no complaints there. But if we could simplify it, that would be even better. What does this depend on in the the usual sense, the word we care about, we've already got the is Const. We've got the view types. Umm. If we made it a variable template? The enclosing Lambda is not generic, so it's not dependent on any template parameters of that Banta. It's the best the class, the class template arguments and Yeah, good point. Yeah. whatever the internal. There is constant. And if you're types out here. Manda template. Yeah, with the. So it could be a static constexpr class memory variable template. Yeah. OK. But rather than completely top level being static, constexpr be good and this is C plus latest so we don't need to worry about Clr pure, which is really really hates variable templates. Umm, so I think that would be good. How then would there be any other robots to simplifying this? It would be you've got your V here templated on the tag type. And it would just be a bull that would be this. It would need to return. And then we would if constexpr Brit. Yeah, yeah, I think it would be strictly simpler, because mainly we'd be getting rid of this bit and the syntax involved invoking it and we wouldn't need to return, it would just be equals blah. We might still need to suppress clang format, but it should generally be good. OK, so let's come on this. OK. Thinking should we have a separate syntax in a PIC and a style in the pick? I'll say syntax nitpick first just on this line syntax nitpick. Umm, this says I'm type name, but we conventionally say. Class in product code. OK. And then the actual much more important semantic nitpick or not really semantic, it's more like implementation style. This. Is correct. And a fairly straightforward transformation of the standard ease. Umm. But passing on. Explicit template argument to a Lambda is. Relatively unusual. And. Verbose. As all of the call sites below need template disambiguator. Umm. I'm eating you, Casey. No, it's uh. There we go at Casey Carter. At Casey, Carter would have said her rific instead of unusual and Observed. ferbus, but your mileage may vary. Or horrific. Yeah. Observed having too much fun here that this could instead be written as a static constexpr variable template within the scope of. Category based is Const. Yeah, because we should just be able to. Put it like right before or no, it's got to be before the iterator category because this is the type def. Umm, within this scope of category based cons, would this Lambda then need to? But you need to capture it. I sure hope not. Because we're within a Lambda invocation here. Capture I'd a variable template, no? If we had a static. OK, because it's not a local variable, OK. Well, yeah, yeah, it's not a functional look. We can't capture anything that's not a function local anyway. OK, OK, I I forget how this language works. There's there's too many things. Yeah. Thank you for explaining. Uh, yeah, I know. It's just You have the silly language. like, you know, 3000 something, pages of standardese all crammed in my brain. OK, so stay at constexpr within the scope scope of category based is Const. I'm then. Let's say static constexpr bool. Umm. Then the definition wouldn't need. Return instead. It would simply provide the value of the bool. As it's initializer. And the usages below. Wouldn't need. Template operator prinn pren. Like this? The rest of the code. Would remain. Basically. Unchanged. OK. Uh has a sound. This is correct and a fairly straightforward transformation of the standard ease. I do want to make clear that this is uh, up at a hard ice cat here. Because I like straightforward transformations otherwise, then my brain has to work figuring out what's going on here. This is correct and a fairly straightforward transformation of the standardized cat, but passing an explicit template argument to a Lambda is relatively unusual and verbose is all the call types below need template disambiguator Casey, who created characterized this as horrific, observed that this could instead be written as a static constexpr bool variable template within the scope of category basis Const. Then the definition would need return. Instead, it would simply provide 9c93b676-e558-4ae6-b8d1-135e090ff3ce/4932-10 the value of the bool as its initializer. And the usages below wouldn't need template operator print print the rest of the code would remain basically unchanged. OK. OK, so derive from blah random access or tag. This is what this is doing 3 different times. I do appreciate that it's all been lifted out. OK so. If Constexpr check for random access iterator tag. Oh, that's just what this is doing, ran it, ran it, bite it, bite it, forward it, forward it, otherwise input so ran it, ran it, bite it, bite it for it, forward it, otherwise import error tag. OK, bunch of braces. OK, good. So that's all this stuff. OK, then we've got. What is this the non constrained one? No, this is the one that's going to use the category base. So category based only provides iterator category conditionally. Everything else is extracted down here. OK, so let's go down here. OK, ranges. This is the zip transform view iterator, so that's what we're looking at here. Template will under score kept is cons class, under score cap iterator drives publicly from category basis, cons to private stuff we grant friendship. To our parents of transform view. We're just correct. Parent needs friendship in order to access. Our data Members and other stuff here, but this can access private members of the parent just fine because it's a member like any other. OK? Then some typedefs using parent tea is maybe Const is const for zip transform view using base T is maybe Const interview. Parents Starr or parent star under score kept parent is null putter. And then. Coming out no unique address because the pointer is always going to occupy memory. Zip erator is Const under score kept inner. OK, that's all good. And then we have a constructor. Constexpr iterator constructor. Taking apparently ref under parent under. And then a zipper rator is const. Inner. OK, we don't have to type for that and that's under inner owner, OK. And then we are conditionally noexcept strengthen because it appears in the standard. Because of this constructor signature appears in the standard. We're no except when and here I'm checking for two noexcept, which there aren't. Good is no throw move constructible V zip reader is const because we're moving that. Said parent to be tested at Arsov. This thing that we passed by reference set inner to be a stood move of under inner honor. OK, public stuff. OK. So we've got the iterator category provided by the base, not always present in the public section. Using iterator concept is type name. Zip erator is Const iterator concept OK. Using value type remove C VFT invoke result T maybe Const is Const. Funk Ref Ranger reference T maybe Const is Const view types dot OK. I'm not even selecting taxes good enough. Using difference type is range difference T based T OK that's good. Iterator prinn pren. OK, this is getting a no except. But the standard just says default. I wonder if this is actually necessary. It feels like it shouldn't. Shouldn't be. I feel like we should just say what the standard says, just default it. There's no reason to like have an error if this thing's wrong, because it's always gonna be right. If we've got it correct. No, except is no third defect extractable V. Zip rater is const. That's the only thing that could fail. Umm, this is verbose enough that I think I'm going to ask for the no except to be removed. It is. I mean it's correct and it's even not strengthening. It does match the standard, but. I think we should just say default. All this is correct. I think that's simply omitting the. No, except. Specification. Would be reasonable. As. It exactly matches what the compiler will generate and the standard simply depicts. Copy paste. Yep, I'm not in selection. Yeah, this thing. OK, how's it look? Back to highlight, while this is correct, I think that simply omitting the no excess specification would be excuse me. While this is correct, I think that simply emitting the no excess specification would be reasonable as it exactly matches what the compiler will generate and the standard simply depicts Iterator Prinn Pren is default. OK. Umm, still public stuff. We have a constexpr constructor iterator from iterator not is Const. I is becoming under score kept RSS. We have a strengthening, so this is no except when is nothrow convertible V. From. Zipper rator of false. To zip rator is const. That's interesting. This is being written in a dependent way, which is probably good so that it's delayed until we actually instantiate this thing. This requires this count, so we know we are Const. Our source is non consumer. Adding constants to it. So convertible from non cons to us and we know where Const OK so that is the correct direction, it's not reversed. Umm. OK. So again we watching the standard requires is const and convertible 2 zip, rater false, zip, rater Const OK. That's why it's written that way. The standard has this zip rater falls, zip raters const and then the no except matches that but changes the concept convertible to to is no throw. Convertible V type track which is good. And then construct. This is not super surprising down here, parent. Uh RHS parent? For storing pointers, so we don't need this address of stuff here and then inner stood move art to center. OK good. OK then. Ah, it's gonna hear. No, that was the that was different. One even looking at here why? Where did this come from? Oh, no. This was the this one. OK. This is the address of. I'm getting confused. This is the address of. Umm, here's the conversion. The conversion simply says parent type parent innertube Venner OK. OK, back In Sync. Now operator dref, that's up here. So we're adding notice card because DRF is always notice card constexpr. Decltype auto offer draft Const no except. See below. Let's check that. Ah Umm. Umm, the exact specification is equivalent to no except horrible thing. But that's just the body. Except invoke. Yeah, it's literally just the body, O contrino, except if no except stood apply, dereference, closure, prinn, pren it. OK, that's fine. I really wish we had no except auto returns to deeply exact same thing. Yeah, for everything there, invoke. I guess that we're going to see what the. He reference closure has is up below. Excuse me. Yeah, it's below. Here's this. Horrible Empire thing, OK? Here and funny. OK, that's good. Let's go back. Umm here. OK, that's looking good. OK, more iterator operations. UM, just looking at the definitions here rather than the. Passed snaps and I'll go back up and highlight that constexpr here not nodiscard constexpr iterator ref operator plus plus strengthening to be no except when no except plus a Sinner OK. Uh also center turned off this. I'm I'm look at my brain is short circuiting cause I'm seeing these braces on their own line. I'm like oh, that should be a slash star rather than slash slash so that the brace can go on the right line. I'm going to grudgingly refrain commenting about that. Plus the Sinner return to your for this. Trying to be a little bit less into picky in the new year. Uh. Constexpr void whoops. Operator plus int. Again strengthening, no, except if no except. Plus plus this is void, so guess expert void operator plus assent. We're no exceptive noexcept, can we say plus plus to deco Val iterator ref, because we can't easily say this here. I vaguely recall this is like subject to some compiler bug or something, but wait, this is weird. Let's even going on here cuz. This says no except plus plus zero for this. So why are these different? I would I would understand if one couldn't say it, but the other that's weird. They should really be identical. Yeah, I'm gonna come about this. They are the same expression, it's just this once constrained. Why? That neither a template, this one is constrained but. Yeah. OK. Comment. See uh copy this inner bit prime prime paren. This says blah, but the next overload says. Law. Could the former? Do the. Or could we use? Or could we avoid? I wanna be unambiguous deco Val for both. OK, this says no except plus plus Taco Bell stuff, but the next overload says no except plus plus dear. If this, could we avoid equal for both? So this one just says plus posterior for this. OK. Next again no, no discard constexpr return iterator by value. I'll plus percent strengthening. We're noexcept when is no throw compostable V iterator because we got a return ourselves and no except plus to your for this strengthened requires support range of base T effects equivalent 2. Auto temp is due for this. Increment. Return temp. There's kind of a spurious new line there. I will refrain. Ah, constexpr or iterator ref. Uh, minus minus. Strengthening, no, except if no except. 3 decater inner OK. Strengthened. Requires bidirectional Orange base predict inner return to your this OK, that's good. OK, I can't resist. I got a comment about this new line. It's driving me nuts. And in fact. Unnecessary new line here occurs. Below popping though I'll highlight this occurs below and. I'll admit it's a Megan epic. Making it pick unnecessary new line here occurs below an operator minus mice and. OK, very, very necessary going back. This is minus min requires by range base the post version this one OK again no nodiscard const expert iterator. At minus minus int. Strengthening noexcept one is no through complex structural V iterator and no except minus minus drew for this strengthened OK bidirectional, Orange base auto under score capital temp is this predict this? Return the temp OK. Now we're up to plus SQL. Still no no discard constexpr iterator, Ralph Upper SQL Const. Good difference. Type off. We're no, except if this is no, except inner plus SQL auth. OK, we're turning reference that is also strengthened requires random access range based T effects equivalent to inner plus equal auth return to you for this. OK, next Council expert iterator ref. Minus equal const. Difference type off. No, except if no except inner minus SQL off strengthened. Still random access range effects equivalent to enter minus SQL auth. Turn dear for this. OK, I don't see any minus or plus getting swapped here. OK, now we're back to the land of notice car because your square bracketing, so notice card, constexpr, decltype, auto, opera square bracket take a const difference type where. Where const. We're strengthening. No accepted. No except stood apply random access. Closure. Where? In her current matching of the body. Good. Requires random access range. Affects equivalent to. We've seen that this random access closure. Is, I guess, going to be similar to the dereference closure thing. It's going to handle this, but we'll come back and when we find that definition, we'll look at it. OK, then we got equals. So friend Nodiscard friend. Umm constexpr bool operator equal cons iterator FLHS considerato FRHS? We are strengthening no exceptive noexcept le Center is our center, OK requires a quality comparable zip erator Const. Interesting. Aren't we in separator? Why are we not using the injected class name here? Ohh no we're. Or iterator here. Zip Arator is the specific type dev of which one? Oh, no zip Raiders. The template here. Look, I'm getting confused. UM. The separators the template here it says get the iterator from the interview ohh the the original iterator, not the zip transform iterator. OK. OK, so there is no injected class name, we're the iterator, but we got a phrased in terms of the quality comparable of the underlying separator. OK, too many iterators going back here. So matches requires a quality comparable zipper reader is constant. OK, so there's no concern of an injected class name. Good. Definition. Yep, X interop winner. OK, that's good. LHHS is equal to Rohs. No swapping or anything. Excuse me, Nodiscard friend comes expert auto opera spaceship considerato FLHS considerato FRHS. No, except if no except strengthening Lehner spaceship Rohner priors. Our anaxes range based T. Turned Ally just in her spaceship. Archer center. OK, good, that's all this. And we got some pluses. Again returning by value, so no discard friend. Uh constexpr iterator operator. Plus consider a refl AHS. Const difference type RHS Reno Exceptive no except match the body construct iterator brace from DFL parent LHS enter pasari just brace strengthened requires random access range. Return iterator deaf parent I enter plus N Yep, that's exactly right. And the next one is the same, except things have been swapped around. So nodiscard friend constexpr iterator operator plus Const difference type lehs, const, iterator ref. Rohs no except if no except swap L&R exactly L to RR to LL quiz random access range iterator. This matches OK good. That's that's this getting close to the end of the iterator. Umm nodiscard friend constexpr iterator operator minus cons iterator ref LHHS cons difference type Rohs. Yep. Noexcept if no except strengthening iterator deaf parent I just enter minus Rohs. Here I make sure we're not copy pasting stuff wrongly requires a random access range. Yep, that's all good. OK. And then read something so horrible clang format needed to be suppressed. Interesting. I wouldn't expect this to need it. Maybe it really didn't like this. That's really surprising. Usually clang format, it's pretty good about this now. I won't comment. I assume there was a reason for this. OK. So notice card friend. Constexpr difference type operator minus. Consider refl us consider refr us. You accept if noexcept elhs inner minus Rohner correct order strengthened requires so I Sentinel 4 ZIP reader is con zip reader is const. OK, does this default? Can you provide just one argument here? And I know it's exactly what the standard says. I thought there was like a default. Or is it? I don't believe so. Where is the definition OK? Maybe I'm maybe I'm misremembering. I guess it would say concept somewhere. Usages. Should be an extra utility. Yeah, there we go. OK, there's no default. It's just. It's an internal. Seeing it OK. OK, so we got to pass them both try and clang format L just enter minus R Just center. OK, that's all the operators. Then we got some helpers. So private helper. We've got a dereference closure and then a random access closure. So let's scroll up to the dereference. So notice scared on the helper. Constexpr auto under score chapter dereference closure. This is excuse me constant and no except. Why is it no except because we're simply capturing at this pointer? OK, so this says return. I'm here return capture this. Take Const auto ref dot iters. And have some noexcept stuff aerodeck type auto the no except to say no except if no except stood invoked your parent function do your filters dot so it matches the body. Umm. And then return invoke dear parent fun. Derek fitters dot. On intercurrent. OK, so dereference closures, good random access closure is on the square bracket. So notice carcass expert auto random access closure take a const difference type where Const noexcept. OK, we are capturing the this pointer. We're capturing where which is just a different types. That's fine. It could be no except template and unclass this time iterator types. Replacing eyes, pick Const iterator types ref dot iters. So no, except strengthening and then aerodeck type auto anodes horribly wrapped on GitHub here. We're no exceptive, no, except the should match. The body stood invoked your current function it or static cast it are difference. Tea if we're OK, that's all good. As this matches dear of parent fan hitters of. OK, uh, Tyler has replaced this interference paren with the static cast. Very much appreciate it. Because we do not like our C style or functional style C semantics casts. OK, that's perfect. OK, that's the end of. The iterator OK, the Sentinel. OK, we've got a comment here that. Sure looks like it's going to need to be become a transition. So there's a Sentinel. Here's a Sentinel. Same template stuff. Here's a Sentinel. OK, template bool under score kept is Conn's class. under score kept Sentinel private stuff. Grant friendship does it transform. View our parent. OK, so this comment says, so here's an interesting MSVC bug we'll come eye is bug. We usually avoid saying bug in our product code if we have signal operator minus return range difference team maybe cons. Iterator const. There's iterator comes coming from. Oh, it's it's templated here. Interview directly as suggested in the CPP standard, ADL does not seem to find the function test suite and the program fails to compile. This does not seem to happen with client. OK, this needs to be reported as a bug. This should be reported. As an MSVC bug. And then this. So should be marked as transition. Citing the bug number we conventionally. Uh, avoid a literally saying bug in the product code. I'm trying to think do we actually have? I'm curious, do we actually have any occurrences where we violated that role at least in ink? Do we ever say bug? We do say compiler bug workaround for the vitar disc stuff. Which is a little bit more direct than we usually do. That that was my fault too. I did that, Victor, this stuff, this PMD, this would be an internal interesting. This should if it's a bug in invoke. This should really be an STL internal static invoke or sorry STL internal static assert. Yeah, I think that probably predates the existence of STL The probably does. internal static is there. Yeah, I'll record it too. I'll clean this up later. Um. Should be. We're finding all these great things to clean up internal static cert and then this is just a comment saying this should work. Otherwise there's a bug. So OK, so we do generally avoid saying bug. OK, let's see. If this works with Clang, what is actually being worked around here? If we have minus return range difference T? OK. So Tyler is introducing an alias template to avoid literally saying range difference T there. So the Sentinel operator minus for claying could do the right thing. Is it worth guarding the workaround with if and deaf? Or should we just always use the workaround? If it seems like could be reasonable always, it's used twice. If we guarded both, that would be annoying. I'm OK with always using the workaround until we got to get rid of it. Umm. Yeah. The little bit annoying when we have something marked as transition without a clear reminder of what to do when it goes away. Umm, but I think it would be fine. We'll we'll be able to backtrack and figure out what happened here. This should be reported as an MSVC bug and then this code should be marked as transition citing the bug number. We conventionally avoid literally saying bug in the product code on actually with only a few exceptions. OK. This is extracted template on bool, under score kept iterator, cons using iterator. Sentinel difference type is range difference, team maybe Const iterator, Const interview. OK, so here's our data Member no unique address which is maybe not super useful when we only have one day to remember. I forget the rules but no unique address. We got. The Sentinel is Const inner. And then we are still in the private section. We have a const expert explicit. Under score capital Sentinel. Construct from a Sentinel is const under inner honor strengthening. We're no acceptive is no through copy constructible. V Sentinels const. Interesting that we don't bother moving it exposition only. Umm, that's what the standard depicts. So OK. Caused the standard holes too. Then oops, I lost my place. There's a converting constructor here. No, sorry. That's why we just reviewed losing my place. This one here template on Bool, under score kept iterator cons where nodiscard helper. We are static, we're constexpr. We return Const auto ref. Or called get iterator zipper orator. We take Const iterator, iterator, concrete ITER. We can't because already static, but we're no except. And we we returned refs. That's fine. Umm, return. Enter, enter. Because we were granted friendship. Is that true? We're reaching into the iterator class. And because we are a member of. The parents have transform view. We have the same access rights as any other member. The iterator granted friendship to the parent and thus the Sentinel can access it. OK, that's good. So we have the minimum amount of friendship needed. OK, so public matching this public Sentinel, again, the same concern about the No, except I'll go back and edit the comment that it also applies to Sentinel. Rather than having to comments or is it here? Oh, I didn't have this one. I hate it when I do that. OK. Occurs below 4 Sentinel. OK, while this is cracked, simply admitting the no access specification will be reasonable occurs below for Sentinel. OK now I'm paranoid and I wonder if I didn't submit anything else. Does anything say add review no perfect OK resuming. Here. OK, so we are hopefully getting close to the end of the product code. Constexpr excuse me, I'm constexpr sentinal taking a Sentinel of not Const. I does now under score kept archs OK. We're strengthened. So no, except strengthened when is no through convertible V zentyal false to Sentinel. Const very much like the Iterator 1 requires Const and convertible tools from Sentinel Falls to Sentinels. Const. Uh construct inner withstood move RHS inner good got all the qualification and then? OK. Wow, I really wonder how Clang format is mangling this. Maybe it doesn't like the noexcept? Template unbook iterator Const OK, that's standing in for other Const here requires Sentinel four. Sentinel is const zipper orator. Other const. OK, let's make sure we didn't get swapped zenel Const is Sentinel is const zip rate or other Const zip, rater iterator cons OK. And if Clang format where Nodiscard friend expert bowl up equal counts iterator of Iterator Const as other cons refl AHS. Constant nor FRS. Or strength that no septic. No. Except can we say get iterator separator lehs is our center OK. Uh and? And. That's this. OK, we need that. This helper function. Uh, we need the helper function because this is a friend and we haven't granted access to the friend, so we've got to do this like chain of helpers to get to the guts. OK, so that's good. Um, same deal here. In fact, it should look very similar. This is for the minus. Wait, where are we? We just did the equal. Now in one of the minuses. OK. So template bool Iterator Const requires High Sentinel 4 xenel is const matching, zenel, Const, zip, rater iterator Const which zip rater other Const notice card friend Constexpr. Uh, here's that work round. Iterator Sentinel difference type iterator constant standing in for range difference T. Maybe consider constant review. OK yeah. Clang format off operator minus tank considerate or of iterator cons reflexus concentr chess or strengthened no, except if no except same body with the minus clang format on return. Yep, that's this. And then we've got it reversed. OK, so should be exactly the same except stuff as reversed. Yep, that's good iterator Const off on. Operator minus. OK, so we have consentual, Raph. That's not LHS. Const, iterator, iterator. Const graph. That's rohs. No exceptive. No except. LHHS inner minus get iterator, zip, writer of Rohs and this matches good. OK. That is the Sentinel. Umm, now popping back up to the transform transform view. So we've got all this. Yeah, we got the sun all. We've got this for sure. Uh, all the iterators stuff. OK. And uh, yeah, these were all the declarations of the stuff we reviewed. In the iterator. Can we get these? Sorry, my brain is wondering if we got those pluses. I don't remember the pluses. If I already forgotten. Yeah, we we got them all. We have the plus, we got the plus all the we got the minus. OK, I totally. I totally forgot that. Yep, all these friends. Yep, looks good. OK, so we're here. At the end of the Sentinel looking at. Is a no except. And we have that probably because it's used for strengthening, OK. And so this is actually a variable template, so that's nice expressed as a Lambda template bool. under score kept is Const, static constexpr bool, under score kept is and no except is a Lambda. That is itself noexcept. Which I think we. Do no, no, we don't need. We don't technically need it here. But again, it's fine if constexpr per. OK. That's interesting. We should look at the definition of end. That's this. Sorry for screwing around so fast and here. Umm so if constexpr. We want to know common range of interview which is maybe conscious Const interview. Then return noexcept. Can we make an iterator? Is const. OK, so this is handling both simultaneously. That's interesting. This and this. And we're saying. OK, so that's so I'm backing up template is Const. Is then noexcept Lambda if constexpr. OK so common range. Of either interview or constant interview, and that's handled by maybe constant is const interview OK then return. No. Except can we make an iterator false or true? That is iterator is const from this and zip and that's the same so. The this drew for this is stood decal Val of maybe Cons is Khan zip transform view ref. OK, it's got to be a null value and then zip end is stood equivale. Maybe Constance interview RAF. .net. OK. Otherwise, we're not coming range. So that's these two. Return. And if concepts were else OK, return noexcept of you can make a Sentinel of false or true. That's his const from zip end. That's decadal maybe consist const interview ref. Yep. So a little bit of duplication here. Maybe this could be extracted out, but this is fine. Yeah, well, my heuristic is something's repeated three times. This should probably be extracted, but twice is fine. OK, so that handles the noexcept for end and then static constexpr bool which is not templated at all. under score capital enable Const begin end is. Looks like the this. Yeah, this is. This is exactly matching. So if we have a range of constant or view and regular invocable Const FFRF range reference T Const view types dot then we can enable Const begin it. OK. OK, so we've got the iterator. We got the Sentinel. We are now doing public stuff. Uh, zip, transform, view, print, run. Again, we've got a default here that has an explicit noexcept. This is just saying movable box and interview I I'm gonna extend the comment cause I think that should be applied here too. That's got a. Here we go. Chris Bluffer signal and the transform view. But no excessive vestigation. OK. I sat long. We looked at this. Ah, the transform view. OK defaulted. Defaulted. OK. We're at a constructor. Uh, constexpr, explicit, zip transform view construct from F fun that's funk under function under views dot views. View types dot views. OK, does this shadow anything? I thought we had to view somewhere. Scroll way way way up. That's the iterator. OK, we only have function in zip. It was the zip view that had the views. Yeah. So we only have function in zip, so no ambiguity here. We're good. OK, down down. Down to Nope, not far enough. Here we go. Umm view types views OK. Uh, strengthening. We're no except if. We need. Constructing the function with an in place so is no throw move constructible V movable box funk. This is asking is the entire movable box move constructible, but we're constructing one of them from move function. Is this necessary? Could we simply say is no term move constructible V funk? I gotta look at what the types are. That's the iterator. Function is a movable box of funk. OK. I think I'm gonna need to look at the definition. I wouldn't be concerned if this matched what we're doing, what we're calling the in place constructor of of the movable box. So. Let's go look at what the move blocks does. Move a bowl box. We're go. Simplified optional. So if you are a in place constructor from a bunch of types, we're strengthened to be is nothrow constructible on that type from types, because we're just going to construct the thing. If you try to move it. Uh, do we have that strengthened? We ask it if it's trivially moved. Ohh, we ask if it's trivially move constructible. That's a different question than an initial construction. Oh, no, sorry, this is overloaded. Oh oh, it's not no, except if it's nontrivial. We always do work and we don't strengthen this. It's interesting that this was not strengthened. OK, so I think I think I've actually found a a minor bug in the the noexcept strengthening here. Because asking is the movable that is the movable box no to our move constructible. We'll say true if it's trivially move constructible, but straight up false if it's not trivially moved constructible, even if it's no except. And we're not actually moving the thing at all here, OK, so. This is boats. Minor bogus like 2 out of 10 bogus. Where was I looking? I was looking at this. We're in ranges, movable box, OK time to quote. STL Inc. Ranges. The biggest challenge I would say one of the biggest challenges in Marian code is sitting through, you know, 400 lines of incredibly repetitive and every character counts, review and then keeping enough attention so that you actually notice the one bit always near the end, usually where something is a little bit questionable. OK, where's that movable box? There are other skills needed, but this is an underappreciated one I think. OK, hit why to get permalink movable box. I'll probably wanna quote both. Yeah. So let me duplicate the first one or the one of them. I'm gonna want to quote is this because this is what we're actually doing. And then then oops, movable box. Come on. Here. Got. Here we go. It's the move. See door. That's this thing. I'll drop the clay from it off, move seed, or is trivially nontrivial here. OK, so this. OK, going back to zip transform view, here we go. So this is constructing function from in place move function. This one I think is fine. The the zip part because that's saying. I want to make sure if I come in about a bug in one member that I'm not missing another bug lurking in the second member construct. The zip so is no hero constructible. The interview? That's the zip from Studmire views. That is, take the view types. Remove reference key from them and then add ref ref OK that's right. So it's this part that is not right. OK, I wanna comment on. Maybe just this now I wanna get that. No, except in there. Otherwise it'll look weird. OK. Ah, I specifically think this is wrong. This says. In the stirring, thinned new accept specification, but we aren't. Move constructing a. Movable box. Here. Instead. Where using its. In. Place. Constructor. Are actually want this one quoted, I'll quote them in order. Oh, I think that was the one that I had. Umm. Which directly constructs the stored type. I'll say that. Which? Directly directory directly constructs. Be stored type. And. Is accordingly. Strengthened. Umm, I think. It would. Miller, both both options then mention which one I prefer. I either the. Exception specification here should exactly match the. Mem. Initializer list by saying. Is it's actually just this. Uh, double checking before I copy paste is no through constructible V. From and then make sure we copy the right one movable box funk. From and then when we move function. That would be. Funk is an object type, right? And I hope it's not a reference type. I think we can just say funk here. Do we have any constraints on this thing? Sorry for scrolling. Ohh template move constructible funk. I forget if that. Oh, no, here we go. Is object VC fund. So it's an object type. There's no sneaky references. Great. Because if I say. Funk. And if it could be a reference that has interesting effects for type traits, but if lunch is an guaranteed object type then just saying funk means that it's an R value. Boy, I wanna make this bigger, OK. Ah, there we go. So is no throw constructible V the thing we're constructing is the function. That is a. That confusingly, actually function is a movable box, but under function under is a funk. It's not wrong I think. Yeah, correct. Move a box funk function. OK, so the types are different even though they only different under score. Going back down is another constructiv movable box to funk from funk. That. Umm. Or it should? Take a shortcut. And. Match or say. Shortcut and depict the ultimate construction, the ultimate construction being performed. And that is, that's just a move construction of the object type is no throw move constructible funk. So that would be this, which was in Ridgely intended. Of the funk. OK. Is that right? I'll, I'll provide it. All is not move start funk. I prefer this. And then I'll mention that this is actually correctness such issue. This is actually a minor. Correctness issue. Are. This is actually, I'll just say minor issue. Not purely cosmetic as movable. Boxes move constructor is not. Always strengthened according to what it does. OK, complicated comment. Let's make sure I didn't script anything here. Uh, OK, so. This says and checking this one. Is no through move constructible V movable box funk in the strengthen Noexcept specification, but we aren't move constructing a movable box here. Move constructible with constructing with box. Yes. Instead we're using its in place constructor which directly constructs the store type and is accordingly strengthened quoting movable box and place T constructor strengthened OK, either the exception specification here should exactly match the list by saying. Is no through Constructable V our movable box funk. From the funk R value. Actually, that doesn't even exactly match. Whoo, yeah, really doesn't know I screwed that up. It's really is no structural be moving box funk. And then the in place thing. And then this, I guess we would need to stay in place. T technically this is an lvalue, but we can kind of take a shortcut and say in place TR value. I'll simplify this. I'll I'll make it, say, depict the ultimate construction. This is actually a minor issue, not purely cosmetic. Is movable walks, is move. Constructor is not always strengthened according to what it does. Here's the move constructors. This one is clearly not strengthened. OK, so let's go fix this bit about the ultimate construction. Umm. Which would be somewhat annoying as we'd need to mention the thing in place T as well. OK, let's just gloss over the annoying thing that I don't actually want to suggest here. Go either the accession specification here should exactly match the initializer list, which would be somewhat annoying as we need to mention in place T2 or it should take a shortcut and pick the ultimate construction being performed. Is no throw move constructible V funk, because we're ultimately moving the function which is funk. I prefer this. OK good. OK, getting close to the end. We made the comment on the zip transform view constructor. Then we got some beginning size and maybe a deduction guide. OK. OK. And this is fairly simple because stuff has already been lifted out. We have got missing notice cards. All they should be notice, card begin and size. Yeah. Begin outsize. All of the overloads of begin. And. And size. Should be marked no discard. All the overloads of begin and inside should be marked notice card OK. O missing notice card constexpr auto begin strengthening. We are no exceptive. No except. Matching the body construct iterator falls from deer for this zip. Again, strengthened return iterator false dear. If this tip again. And constexpr emitting those car because we already commented it constexpr auto begin Const strengthening. No except no except could read or true dear if this zip again strengthened requires enable costs begin end because it's the same. Return iterator true. Do you have this again perfect. Uh context. Perado end. Noexcept, when is and noexcept false because we're not the constant one strengthened. If Constexpr commentary interview return iterator false deaf this end. Otherwise return Sentinel false to depend. Cam. And then Cortex Broudo end, we are const. No, except when IS and noexcept true strengthened OK acquires naval const, begin, end nothing. If constexpr common range constant review return iterator true. Do you have this spend? Otherwise return Sentinel true zip end. Cat. It's esperado size. And then strengthen, no, except if no. Except we can say zip size. OK, strengthened require size range interview returns of size. Sex burrito size. We are const. Noexcept if no except zip size OK still strengthened. Require size range of Const interview returns zip size OK and a class definition. Uh deduction guide. Template on class F which is the funk. Class dot ranges is it transform view from function ranges ref to do zip transform view of funk and views. Alt ranges dot OK. Uh, yeah, that's the constructor. Yep, we saw that. Now, is it transform fund? This is all specified by the expression of equivalent stuff in the standard, so that's why it doesn't appear here. There's nothing else missing here. OK, so I think I can actually minimize this. The last bit. Why are we going public again? Ohh I lost my place. We closed up transform view deduction guide. Opening up views now we have this transform struct so. Struct under score capital ZIP transform fund, private stuff, public stuff. OK, so. Here we have a static constexpr bool. Template on class under score kept a fun class. dot under score kept types starter, classroom bool, under score kept is invocation noexcept. Uh, we're Lambda, we're mark. No, except if constexpr size of dot our types is zero, we have nothing. This says equivalent to. Using decayed funk is decayed T funk return. Wow. What? What? What? Even is the syntax? My brain is refusing to parse this. Return. OK, there's too many parentheses here. One moment. OK, then I I can't even realize parenthesis. OK, so tell this that this is C++ KMC. As pass some nice parenthesis highlighting. OK, so we've got some why are there? There's a comma operator in here. OK, this start to look better. What does this auto? This is that language feature that Tyler called out. That's why my brain can't process it cuz it's future technology. My brain is not upgraded yet. OK, so returned no except of this expression. We have. A comma operator. Hence this extra layer of parentheses. We are avoiding hijacking by void casting. Interestingly, the first one is being void cast even though conventionally we do the 2nd. But this is just a comment so fine. Why are we checking the decal VALIS? No, except. But then why do we? Yeah, that doesn't make any sense. We can always do this and then. What is the invoke result T? Decay that type. I don't know what empty does and then is that of view. And then can we copy that? But I don't know what this is doing. What is the standard he say? OK, clearly we're saving the the hardest question for last here. Oh, that's up here. OK, I guess back to split view. Oregon draft OK? I've used the transform. That's this thing. Oh yeah, OK, so this is what I was trying to be. Copied here that the no except of the whole expression is expression equivalent to whatever F was. But that's kind of weird because once you give it to zip transform like it's there like, who cares whether true or not. I I guess it I guess expression expression equivalent has to Ah there. handle that. Expression equivalent means that if you're evaluate F, it has to But we don't. be evaluated in the equivalent expression. Since there's no way to avoid that right for an implementation, we can't make that expression disappear in the library somehow. Right. But that said that. But in the. Doesn't need to be reflected in implementation code. That's And then yeah, in the no except. super weird. OK, so this should probably go away. And. Well, we'll see about the actual code here, but yeah, this is super weird. Do we even like the things? Do we even need this comment? Like, I know Tyler is trying to explain, and I appreciate it. Yeah, I don't like the comment at all. That there's a transformation happening I I think I think merely citing. Umm, the standards that it's implementing would be sufficient. Rather than trying to explain what we're trying to explain, what it's doing when studying the standard should be sufficient. OK, let's ask for removal of the comment. OK, let's see. Hi. Thanks for including a yeah, I don't know. It's not freeze like that. I'll I'll blame Casey, Casey and IUM. I think that it would be simpler to. That's what I'm here for. You to. Leave me. It's all Casey. Well, it's it's ranges. So ultimately it is all your fault. Because you started it or you were critically involved in the the standardization of it and 4928 range zip transform view. Should we just say 2? Or two one. If ease is an empty pack. But by all formed otherwise this. I say just maybe 2. Um. Because that covers all the expression equivalent. Umm. Maybe. Maybe we should explain. Whoops, we should explain a little bit why we're nervous about this, the. This thing here. In the current comment. Is extremely strange. Umm. This is always no except so there is no reason to mention. It. Here. Came back should mentioned. We saw that it's trying to match. Umm. The void aff here. Whoops. Whenever I magnify, it's where, Umm, we saw that. It was trying to match law and the standard ease, but simply citing the relevant paragraph is easier and less confusing. OK, how's it sound? Casey and I think that it would be simpler to cite N 4928 range ZIP transform overview two in the current comment voids to decadal funk ref is extremely strange. This is always no except so there's no reason to mention it here. We saw that it was trying to match it void. F in the standardese, but simply sign the relevant paragraph is easier and less confusing. OK. Go back to preview and then and then change the split. OK, slightly overtime, but I think we can finish this very soon. OK, is invocation, no, except if there's no types then. Is it true that it's always true? UM. Yeah, we don't have to do anything. Yes, it returns an empty view. As the transformation. Yeah. And everything to do with MTV is no except. Otherwise return. OK. Otherwise, let me split this a bit more. Otherwise return no. Except can we make a zip transform view with parentheses? Because that's what we do for views out of stood decal funk. And that is matching the F and then stood decl types dot and that's matching the ease. OK. Because. Otherwise it would attempt to construct. The transform view from just the funk and that would be weird, is that the theory? Or try to figure out like why do we need the special case here at all? Because you cannot instantiate zip transform view with zero ranges. It's statically forbidden by the constraints on the class Ah. template so that we don't have to make it make sense or have a Ah. specialization just for 0. OK, but the the the zip transform view. This thing the object, this is the one that. Views colon, colon zip transform will accept 0 ranges, sure, and Yeah. Zero and expect something to be piped to it. it yeah. I think right. No. No, OK, that's not how. OK, but OK, it'll accept nothing then, OK. Ohh does it take a count? It probably doesn't. It's hard to do that piping thing with things that take arbitrary numbers of branches, likes of view and sip transform. Ah OK Ohh, because it because it needs to take two things. So I suspect that they are not rigid after objects. Yeah, right Ah OK, got it. there CPO's, but not range adaptor objects in the in the wording, so they don't need to do the piping. OK. OK, I think I've mostly followed what's happening here. Man, this stuff is complicated. OK, so now enable CPO. Template class under score kept perfect class dot under score kept type static. Expert Bowl enables CPO. Also ugly no except if constexpr precise dot types is zero. OK so more special casing. I'm guessing that's this using under score capital. Decayed funk is deck T funk. That's this FD. OK, so this is matching the path standard ease which Tyler sighted. If Constexpr move constructible FD which is decayed funk and regular invocable FD ref which is decayed funk RAF. OK, this says if it's false. Or if the Katie blah is not an object type. OK, so hold on. If I think we're organizing this. If this thing is true and if blah is an object type. Are we not checking the object type bit here? Why is there? OK, I'm a little concerned that we're not checking this bit. OK, but let's skip that for now. If law and blah is false, then itself harmed. So let's test if constexpr move constructible, decayed funk and regular invocable decayed func ref. One is true. Do cool thing. If it's false then itself formed. OK. Ah. OK. So then if it's true. Or they're using not void instead of is object. Yeah, I think I think that's what it's being decayed. So it Is that is that the problem? might end up being the same. That's an interesting shortcut, so let's see if this is correct. Invoke result TFD ref. And then. The Standardese says The thing is, well, The thing is well formed when the decay of that is an object type. Umm. Decay transforms well, first the strips off references and CVS and it transforms functions to function pointers and arrays to object pointers. So that's like all the stuff that you could possibly return from a function. A function either returns like an object or reference or void. We've already decayed away references, so you're gonna get an object type, possibly a function pointer or array element object pointer, unless it's void. So I think this is a correct simplification. What do you think? Umm that instead of checking decay and object type this just says hey you invoke result. Are you any kind of void? If you are then this is bogus. I think so. I'm agreeing for now. OK. I'm gonna go look at the primary type categories, but I agree. Do you think it's worth? I do you think it's do you think it's worth comment? It's an interesting transformation. I don't necessarily think it's worth coming, but are you usual rules? If you do anything super clever, then you should come in it to a record. How clever you were and B avoid having other maintainers wonder what you were doing. I think it deserves Yes. comment. OK, I will complete. This OK, unless like you look into it. I do now completely agree that it's correct. OK. Well, yeah, certainly if you don't think it's possibly correct, then it definitely deserves a comment. But if you can find that it's incorrect then then we should also fix it. This appears to be correct. Casey Carter is going to verify. No, I did. Umm. Ohh you you. Oh, you did. OK, so you think it is correct but. I did I I went and looked at all the primary type type categories and yes, void is the only thing that a function can return. That's not an object type. CPP Boyd to be precise. Do you think it merits a comment? I don't know we we both were concerned that it was wrong initially, but we figured out in however many minutes that it was right. Does that close enough? Yeah, but those minutes were powered by years and years of suffering. Through looking at type traits. So maybe to save other contributors from similarly brain exponent. Yeah, Alright, fair enough. Fair enough. Let's throw a comment. I'm trying to think of. Yeah. Or in order to save us some time, 5-10 years down the road, once we've forgotten all of these things, which is more likely. OK, I think here we should probably again just simply cite range of transform overview, but here we can cite bullet .211. UM. Ah, the KT. So two on one. Umm. But. A, C and I. Had to think for a moment. To. Understand what was happening. It would be good to comment. This. By sighting. Blah. Come with this by. Saying that it implements, should we say implements more efficiently? Or just implements blah. Maybe more efficiently. OK, this is a correct transformation that standardese. But Casey and I had to think for a moment to understand what was happening. It would be good to comment this by saying that implements range, zip transform Overview 211 more efficiently. Oh, and I forgot the standard. We should always cite the WP. When we say paragraph numbers. OK, great. Did I make that mistake elsewhere when we cite paragraphs? Umm, no, I got it right there. OK, good. OK, otherwise return false. And I was wondering, can we just simply smash this together with like and and? But I think the if constexpr person needed to needed to delay evaluation of this invoke result T. No, we're already incisive dot types. It seems like this whole thing could be simplified to if constexpr blah and blah and blah. Rather than the return false, what do you think? Move constructible. Ohh, we don't know regular invocable Maybe. until we get here. Yeah, I think this is the the way it has to be phrased, because if you don't know that decayed funk ref is regular and vocable, then you can't say invoke result T it would scene. But in this context would be hard error. So I think this is necessary unfortunately. Umm, OK, so what's going on here? Wow clang format. What are you even doing? I was like, I can't even parse this, but it's like. Yeah, I'm very disturbed. I commented about this in chat. OK, Shi had a comment here that suppress clang format. Yes, I think so. OK. At the very least, for those lines in the else clause. Umm. Hey. Yeah, Clang format has really. Mess this up. We think it merits. A suppression here. OK. Umm, otherwise, uh, I guess that's this thing. Return requires given a funk rough ref under function types ref dot under args can we make zip transform view out of stood forward functions stood four types args dot OK good. And the last bit public template class, under score capital fund, class dot under score kept types requires enable CPO funk types. There should be no discard. Because why would you invoke the thing unless you want to use it? Constexpr auto operator Prinn Pren take a funk. Refer a function typestuff.org Const strengthening no except when is invocation noexcept. Given funk and types. If constexpr size types is 0 then using. Decayed funk is decayed. T of the decal type of function. Wrapped in parens. Interesting. Do we need to wrap it in parens? If we don't, we will get funk riff Raff, but we're decaying anyways. If we do wrap in parens, we always get an L value. But then we decayed anyways. It's not harmful. It's a little weird. I'll accept it. They're trying to reflect something in the specification with that and. Ohh. They're probably wrong to do so, so it they're really questionable. Why we're doing that? OK. You think the punch should be emitted here? Because we just immediately decay. Ohh no, here it is. Let FDB decay T decltype double parent F. OK. It's what the standard says, so deviating from that is weirder, so I'm I'm happy with this. So decltype double printf is bunk refresh. Right. And then we go to K that away. So probably the standard is doing something unnecessary. Decltype printer in function is funk ref. So they're using it. They're using a different type than what Uncraft. Ohh. Because we have a name. the spec says. Yeah. But at the end of the day, they want to. They should just be using decay T funk. Oh, good point. Like? Yeah, why bother with the ref we already have? We're already in the type domain. I'd like that. OK. Yeah. It's very confused by using decl type of this thing that we know that decl type of because we just declared it. And yeah, it would be much clearer if this was just Ducati Yeah. OK. funk done. So the standard says, UM, law. Umm, because it's phrased in terms of on expression. Let FBA what is sub expression of a subexpression. Russian F who's type it doesn't already know. Umm here we have. Like rough rough function, so we already know the type. And notably. Friend function. Is always on. L value that that that is a difference, right? Brent functions always null value cause functions got a name, whereas Brent F could be paren of some PR value or whatever expression. So it's not always an L value. Is that right? Yeah, give or take. OK, close enough. Unlike Dev, so there's all ready a semantic difference. Umm. Ultimately we're passing the result to. Decay team, so it doesn't really matter but. And again, I'll blame you, case, Carter. And I think it would be simpler to say decade funk. And better for throughput. Yes. OK, the standards has let FDB, to KT decltype double printf because it's phrased in terms of a sub expression F whose type it doesn't already know. Here we have funk ref function, so we already know the type. Notably paren function is always null value, unlike printf, so there's already a semantic difference. Ultimately, we're passing the result OK T so it doesn't really matter, but Casey and I think would be simpler to say to KT funk and better for throughput. OK, so close. Uh equivalent, two OK is this this is the same thing here. It's more directly matching. I'm less concerned about this comma because it doesn't have that we're decl, Val. The comments technically wrong, again because. Yeah, it's it's wrong again. And function in effort different things, right? We we don't know OK. Yeah, yeah. what the type of the argument expression F is. We can't really tell we we can tell what it's decayed type is but we can't tell if it was a PR value or an X value by the time it gets here because we had to bind a forwarding reference to it. Right. And that's that's always an L value. OK, so should we cite 212 here? Should we say site two and two for this one as well because this is really the problem. I honestly don't know that I would say anything for either of This F. these. OK, just drop it. Bridge is certainly simpler. Yeah. I mean, we know we can see where this is useful though. OK. So we know that it's supposed to be implementing the exceptions specification. Or views block and therefore we never go look at the spec of Yeah. views block to figure out why this succession specification is And. so particularly complicated. Yeah, I agree. Unlike the transformation here we we know what to look at so we can see, oh, this implements that and it's not super mysterious what's going on. OK, so let's update this. Umm. Drop this comment entirely. But. Readers of this. Commentation. Should. Already know to be looking at the standard's side by side. OK, how does this look, Casey? And I think they would be simply to drop this common entirely in the current comment. Void is extremely strange. As always. No, except I was trying to match void and Standardese, but readers, readers of this implementation, she already know to be looking at the standard subside. OK, so that applies to the whole comment and then below I will also mention that this comment. Umm. Similarly. Or. Similarly to the comment somewhat above. We think that. This comment. Should. I'm simply be dropped. OK, see notes that. Umm. This comment is subtly. Uh, wrong because void function. Is not quite the same as. Void F. In the standard ease. Better to avoid the headache and tart. OK. Similarly to the comment somewhere above, we think that this comment should simply be dropped to Casey notes that this comment is subtly wrong because void function is not quite the same as void F in the standard is better to avoid the headache entirely. OK. Otherwise, we're going to return an empty view of decay T. The invoke result T of decayed funk Raff OK, that that's good. Otherwise return a zip transform view. Straightforward functions strip four types, arcs export stood in line, cuts expert zip transform fund zip transformer experience, close namespace views. And let's make sure that we're actually in C + 23, which I think we are because we are. Going to do ranges as container let me scroll up before right after zip. We're good, which I think we are. I forgot to check this originally. Yeah, we just defined zip zip transform is right alongside. There's no jumping out of 23 mode or anything, so we're still in 23 mode. OK, that is the product code. Wow, that was very enlightening. And it's viewed. I have to come back and review the test later. Umm, so I will request some changes. Thanks. This. Looks great. We were all this time. I'll blame myself. I was able to review all of the product code during our video code review this week. I still need to look at Test CPP. OK, thanks. This looks great. I was able to review all the product code during our video code review this week. I still need to look at Test CPP request changes OK and I do think I submitted everything and nothing is pending. OK, reviewed. Excellent. We did it and we only ran like 30% over time. OK. And I, yeah, I think we we learned a lot which is always It wasn't terrible. good. I don't see any questions in the comments, only some Nope. commentary from Casey. I I give an explanation of why Sentinel for incidental 4 don't have default arguments. Ah, OK, I guess I can repeat that here. It took me a minute to remember it. It's historical information. Uh, because it's it's it's a type constraint because we say Yeah, we often use it as a type constraint, yeah. Sentinel 4I S. Yeah. OK, so the default argument would be too confusing that that makes sense. Yeah, I remember seeing that type and strength thing and get confused about where the type goes. So adding more confusion there would be way too confusing. Make it even worse. Yeah. LLVM. You hated it. And. Yeah. Yeah, we got rid of that quick. OK. So thanks for sticking through this long code review. Thanks to Tyler Brawl for submitting this awesome PR and getting us closer to having a complete implementation of C is supposed 23 view zip the paper we will see you next time.