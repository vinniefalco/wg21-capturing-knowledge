WEBVTT Hi everyone and welcome back to another VC libraries Open code review. Today we'll be looking at another PR implementing C + 23 features. This is Part 2 of the stood expected review. This is adding a whole new header to the standard library. The PR is 2643 by our contributor Misco. Previously on the Open court reviews and I've gotten partially through this up to I believe the class expected. In the header itself and the new test and the new testing would be I had submitted a bunch of comments. Miss Go has addressed those and reply to the comments that I had. Now I'm looking at the the commit history here. There has been a force push which sometimes makes it difficult to see what happened, although GitHub is surprisingly good at showing the differences between force pushing. So I'll see if I can do that. And then OK, then we mentioned there are some questions in the the discussion history about. OK, we're adding a new standard proposal. Should we add other standard proposals? And our answer is respectively have been yes and no. There's one actually mentioned early on in the review. It's it's. There's a specific comment for it. I could find it. It's actually my first comment. Here it is. There's one paper that has not been officially accepted by the committee, but it has been looked at by the library Evolution Working Group. They had a strong consensus to proceed with it, and it's currently being polled by them right now, and this is a fairly small change. It just renames the member function so as maintainers. We've given you know approval to say, OK, it's OK to implement this paper even though it hasn't been technically voted into the working paper yet. But then there's another one. That Musk was asking about. Monadic functions for state expected that paper. Although many people are very interested in it, has not yet been reviewed by the library Evolution Working Group. So currently we've decided to not add that paper as part of this PR. Just because so many times in the past, we have tried to implement things in advance of them being voted into the working paper, and if they get changed, or in the worst case rejected. And they don't appear in the working paper. Then we've just shipped something nonstandard and we have to go unwind what we've done. Most notably, we were burned when we expected to change to happen to still futures blocking destructor. That did not happen, and so since then we've been very careful about trying to implement only what is actually in the working paper. Plus, really obvious fixes, like if the wording in the standard is what I refer to as unimplementable. Vague or self contradictory? Then we have to choose something and in cases like that we can implement things like library Working group resolutions that have not been technically accepted yet. But in this case this does an extra feature and is however good that might be before it gets voted in implementing it as part of this paper is, I think, too early. It's also separate. Yeah, and that means that implementing it separately. Uh, it's just much easier in terms of. Getting code reviewed. Yeah, yeah, rather than as a large I think this is multi thousand line. Yeah this is like three 2980 lines so that smaller is generally better. If it had already been accepted then having it be part of this paper would be reasonable. We would just be a single integrated feature. We usually get catch papers once they've been voted in. Just get them all at once that we don't need to worry about. Like a intermediate point in the implementation. But in this case it has not yet yet landed in the working paper. OK, so with that, if it's all the same part of the working paper, then yes, there yeah this joint then yeah, if it was like a separate header that just works with then yeah, having it is a separate very simple. OK, I will minimize Casey here so I can see more of the screen. OK, so let's see what's changed. I'm going to Alt Click to minimize. We've got a change to the Navis, that's new. We've got expected itself. We've got the test and being added to the include each header load matrix, I think I'd asked for this because it was a missing change last time, so expected as being added there and sorted order, that's good. OK. Let's take a look at the debugger visualizer, so this is used by the IDE to display complicated types in the watch window. So if you have something like a stood vector, a representation of vector is very complicated. It's got 3 pointers. It has maybe some debug data members understanding what they point to is not obvious. Classes like list and map or even worse, so this XML file the native. Come out, which is documented on Microsoft Docs and helps the debugger understand the representations of STL types. So we ship it alongside the STL and then it gets incorporated into the IDE. So this here I'm assuming that Misco is already actually tested this. I'm just going to look at the XML and see if this looks reasonable. The format is you mentioned the type you have the HTML escape. Things like angle brackets, so anything matching student expected. Let me see what type that is. Yeah, unexpected, let me zoom in a bit here. Yeah, so unexpected of star. OK, intrinsic. This is a way I think to refer to. Member functions. He's calling it unex, and this calls the function under score capital unexpected. OK, so at an exposition only data member. It's Val and I don't want to highlight Val in the paper itself. OK. And he here he displays it as unax. That's interesting, does that come from? Yeah, I don't think that's a standard identifier. Umm, so the the Convention that we've used, and admittedly it has been something like five or seven years since I've directly worked on the visualizers myself. I think Casey and Andrew have worked on these much more recently. The convention that I followed back in the day was if you're displaying a data member, or yeah, it's going to get a lot of results. If you're displaying a data member and you want to depict an imaginary name for it that doesn't actually exist in the standard, I would put it in square. Brackets, why can't we just use unexpected? That's the name of the type. The thing that it stores is in the standard. It's called Val, or that the accessor is going to be called error. Right now it's called value. The Accessor is going to be called error, then depicting it as like square bracket error. Error could be more reasonable. It's very interesting, let me let me actually look at the representation of the type real quick. It's not like. OK, so uh miscues naming the data member unexpected. But if the accessor is error then displaying the member as error Prem Prem would be in terms of something the user would directly see. I think that would be a better name but the error type is is error. Yeah but this is not referring to the type but to the data member. Yeah, so I think that this area I think. OK so we've got to come. Let's see dislay. It's really the. This doesn't matter. This is just like the internal name. It's the item name here. OK, this name or displays. The data member's name I cannot type on this thing as an ex but that identifier. Doesn't appear in the standard. Would it be better? To. Display error here. Since that's the name. Of the. Accessor number function. Or possibly. Huh? Like OK, this displays the data member name as unex, but that identifier doesn't appear in. The standard. Would be better to display error prime prime here since that's the name of the ACCESSOR member function or possibly error. Perfect. Then we've got a stood bad expected access, which is the. Exception type. What does that have? This ohh here we go. This is templated on T and we've got some by no this is what am I looking at. This is expected bad expected access void device from exception. OK, here's the templating 1. This an also has error. And not anything else. OK, so same. Same same question. Garden name add. For. Assess Next up stood. Expected itself. OK, so here I'm just looking at the class definition. Seeing what Stata provides and you can access as value and highlight again as value value and error. OK, and then there's like value or things like that so. Let's go find some helper intrinsics has a value value and unexpected. OK, so we've got some conditions. If you have a value show value. If you don't unax. OK, and then again same name here. Aside from this, this seems reasonable. If you have a value, you show the value. If you don't, you show the error. Yes, every single one. So in fact I will. Say just occurs below. And X activated access and expected itself. Trying to avoid too many comments for the same thing. OK, other than that this looks good. This nicely switches between the two, which is very good. OK. And then for expected a void. Because you can't really have a value void. He just displays void. That seems reasonable. And if you put a. A literal string. You just say void here, but that's interesting. That's extremely interesting so. Oh no, hold on the display string. You need to wrap and braces if you want something like an intrinsic to be evaluated, but for the item you dumped, you just. With the thing directly there, display string embraces item direct embraces direct. OK, so the display string if you just say void by itself. And that's a literal string. Is here and this actually gets OK, so this is all? And then only if you don't have value, do you show the error. If you do have a value, you should avoid, but no children. That's what the items are. The data members are displayed as children. OK, this all looks correct, just that name. OK, that all seems fine. We don't need any sort of. Conditional logic from the version of library or anything. Because essentially if the type exists, this is how the visualized. Otherwise the type doesn't exist. Uhm, it has never been revised. OK, so that's good. OK, let's look at. This stood expected now. OK, that's my existing comment about updating our list of extensions, headers and so forth. I oh, I guess I could look at what has changed. Just a quick check that any other comments were addressed before I get to expected and the test setup. That's one thing is we try to make sure is that when changes are made in response to code of your comments that we actually go look at what was changed and that the changes were correct and not you know that they. Or address 100% of what was actually commented and that nothing was dropped on the floor. I'm not currently, I'm not exhaustively checking each comment I had mentioned against the changes, but I think just looking at what has changed will be good. So of course the whole Davis is new. We saw that the included Trader loan matrix change is new. We've got a test change this test deduction guide. OK, that's good. Umm? This is this uses the idiom that I am not a fan of. This could be. I will comment that the the full changes like yeah, yeah, essentially I'm not a fan of the almost always almost always auto idiom because I consider it to be an unnecessarily verbose in this case saying student unexpected deduced paren test error says exactly the same thing, except we don't need the auto there and it's reasonable when you already have something that already has a type. But saying auto thing equals temporary even without. But even if you kept the sign in form. Just the auto and some parentheses correct you. Yeah, you don't need. You could use the assignment form as well. The copy in that form. OK, that's a good point. Stack asserts name is Decltype, deduce unexpected. OK and we'll comment on that. That's purely stylistic, I think I also need to comment that stood is probably not needed. It looks like this test is already using the space stood. OK, so I will eventually note that and then we got a bunch of changes to expected itself. These are quite extensive. OK, before I look at those, let me actually submit that comment against all the changes. Quite trust what happens if I tried to submit it on just the delta. So in the testing would be 2000 lines. The test is indeed already using a space stood. My favorite comment and was around 1:30. OK. This test is already. Using the space stud. Additionally we. Eventually died. The. Almost romance model. Umm? Production I. And we tested. Never directly or copy that. Demonstrate like this. Yeah I do. Why don't I first really stood? And the variable name is deduced. This. Equal technically not an assignment, it just uses assignments and tags. I wish the suggestions interface would let you just edit the thing. Yeah, you're here. We just want to give Mr the choice. So yeah, this test is already using. Using this test is already using ASP stood. Additionally we can eventually the almost always AutoCAD or the deduction guy who can be tested with either direction or copying it like this unexpected to do spring test error direct in it or unexpected to reduce equals test error. Copy it. Yeah, that looks good. It's like oh, and it clearly better. Is this one character less? Uh, second one is 1 character more. No one editor character. If you put spaces around the equal, yes, it's as longer. It must be longer. It's more meaningful. 1 token less. Yeah, there's a very slight stylistic difference. Not that I would ever comment in a PR about it. Usually I sort of mixed both forms directly and copy it because I'm familiar with the difference. I I certainly don't blame anybody who tries to rely like only on direct edit, because copying its merit, or I suppose vice versa, although vice versa doesn't work with explicit constructors or clear that you're using. The constructor. Yeah, but those that have instead of an assignment operator, yeah, yeah avoids that sort of ambiguity. My personal sort of criterion for when do I use one or the other is if the types are essentially the same. I like I'm OK with equal, but if I'm doing like a conversion I'll use the parenthesis. So like with a stood string I feel comfortable saying string stir 2 equals stir one just to copy it. But if I'm constructing from like a conscious. Are that's enough of a tight transformation that I'd like to use parens? I'm not 100% disciplined about it, and it's not even consistent enough about it that it's sort of reliable to read my code that way, but it's on things I tried to think about. OK, so that was what was changed in the test. I'm glance over were changed in expected because otherwise I'm going to jump past all that stuff and just go to class expected. OK, so here's the expected header. OK, so we've got a fair number of changes. Looks like some claim format stuff. Oh yes, I remember the stable name was incorrect. OK, I'm just calling down. OK, the changes here are actually not too invasive. OK, I'll just quickly read through this. OK, so we're no longer suppressing cling format here, because that constraint is going away. I remember asking to not constrain anymore, so that's why we're just unconstrained on error. OK, then we got some static asserts that enforce this. It's gotta be is object. VE must be an object type. Not Israel VE must not be an array type. Not volatile and not consed. He must not be seen by qualified. And then our specialization that all sounds good. Friendship needs to be not with the concept, it's good. We don't need to wrap this here because we're already cleaning format off tier. Yes, the off honor being removed in pairs. Stable name is fixed. This has to be auto. Oh yes, I remember this was a stealth build break because the MSVC does not currently define this. And we're mentioning the deducing this paper, in addition to the renaming paper. So this auto rifraff wait. Why was that a stealth build break? Isn't that the whole reason we use this stuff instead of? Ohh, it's because the if that was added OK yeah, the the the well the if was there already, but MSVC currently does not activate this and the stuff in here would not compile. I think it's because. And then the stuff in there shouldn't have been even been seen by you see, right? Yeah, MSVC wasn't Even so, that's why I'm saying was stealth. As soon as the compiler turned on that macro, this code would be exposed, and then we would fail to compile. I think the error was that. This was not deducing, it was always taking a ref ref to unexpected. But here we actually want perfect forwarding and then since the the value category also. Ohh yeah, because unexpected to not not gonna be a template parameter yeah cause yeah here here we're trying to replace these four overloads with one so this really does need to be templating perfect forwarding. So we really do need auto here and not unexpected shouldn't. Observe the return type. Here could be our ref ref also. Instead of Decltype auto and then we wouldn't need the. Thematically, meaningful parentheses around the return expression, which is one of the things I hate. In C++ we can strain. That's an interesting question. Go ahead should we constrain self to actually be unexpected? I do not believe that is necessary because when we have the this keyboard there it is the self. It's got to be our class. That's how PA47R7 works. You could not just call this on some other random type as a free function or something like that. Really quite confusing syntax. I'm sure nobody else will get better wrong. Regarding auto ref ref that is interesting, I was about to think about the parentheses and you're right that that without that. Does it activate special rules? Because this is not naming. What's naming it data member? Is that why it would directly look at the type? Because it looks like theses need to be there to make this be an L value. Yeah yeah, that's good. That's instead of the declared type of that member. Yes, yeah. So what we're referring to here? For those who are blessedly unaware of the standard is the behavior of decltype, which does not behave as people would always expect it. It's been designed to try to do the right thing almost all the time, but in rare situations things like parentheses can matter. And this is actually one of them. Uh, let's see if I can remember exactly where without. Isn't that behavior explicitly opted into a decal type auto? It's when you say Deco type, so because we've said Decltype auto, it's going to use the Deco type rule. Could we not say that? Yeah, yeah and so that's what Casey suggests is to use auto ref and I think that's a good suggestion. I was going to look up the deck type rule which I'm trying to remember without searching. I know it's in my brain somewhere. Member, it's really, really hidden where the rules for decal type are. Don't tell me. I know it's here. It's not. It's simple type specifiers, even though it's not really what one would call simple. So under that here we go. Declaration specifiers, type specifiers, yeah, OK, and now they actually now in the latest standard. They actually break it out to a separate section for long time. This is hiding under simple type specifiers, which was somewhat confusing. OK, I got you with that searching achievement unlocked. So when you say deco type, either directly or with decltype auto, it runs these rules and this is very interesting. Because it does two things in one. Essentially, if you directly name the type of a variable or a data member, so that's this split here. If E is an unpretentious sized ID expression like X deco type X or an unpractised class member access like Deco Type M under score meow, then deco type is the type of the entity named by E. So basically, if you've got an integer. And you say that? What's the declarer type of this integer? Or you've got a data member? It will just give you the type of that thing. It would be very confusing if it put a reference there when you didn't make that variable a reference to begin with, so decltype does that, and often that's what you want. In other situations, Deco type will variously return an lvalue, reference, an R value reference, or the type itself depending on its value category, and this is desirable because you often. These decal type when forming things like return types of a function. If you have a function that. We're returns the result of another function. Then if that other function returns something like an L value, you want that to be reflected in your wrapper function, and the way to do that is to return an lvalue reference. Or. Similarly, if whatever you've called is returning our value reference, you yourself want to return an R value reference, or if whatever you've called is returning a temporary like string one plus string two, you want to return that temporary. So that's that's what these ballpoints are doing. The tension between these is, what if you form an expression that mentions a variable like a parenthesized expression. Then Decltype will use these rules that return like an lvalue reference, or an R value reference for L values and X values rather than just return the type of the thing. This is one of the cases where, like return RET is different than return parentheses rent. And the compiler will warn if you do something like try to return a reference to a local variable that's about to be destroyed. So in practice it doesn't cause a lot of headaches. But in this case it results in sort of weird looking code where we really do want the. Give me the type of this expression rather than give me the type of this class member, but to activate that, yeah perfect. Anti. And perfect anti forward and I guess is there a turn type? Yeah yeah it's yeah it's yeah perfect returning essentially and based on the value category itself. But we don't want it to give us the declared type of unexpected because we know what that is. So the parentheses here activate that, but that's really weird. Can we just say auto refresh auto refi think is a reasonable here? And if we can't say auto refresh, let's have a comment as to why we can't. Just none of us can figure it out. Although this is correct, the. The necessary parentheses are unusual, and what's the wording in the standard? Uh, the wording is what I was just planning to. It's this, no, no. Of of the function that's being implemented here here. It's depicted currently as this, with the four categories, but we're sort of applying as if logic and saying, oh, if we have C + 23 explicit this parameter, we can make this fancier, and eventually the standard. Stuff might be changed to collapse these into one the way that it has been changed for explicit rule, and in some cases if constexpr I don't know if I. Like doing this conditionally, but yeah. Well the alternative is to just say, well, we wouldn't do this at all like we could drop this. It would be totally conformant. The question is like. AM. Would we once we can assume C + 23 everywhere and in the center we can once compiler support for this exists, should we just unconditionally collapse it to this one? Would that be better for throughput? It would be easier for users to look at or essentially what we're using. Too much high powered template machinery for something that's actually not that for those like explicit bool saves a ton of headache and I want to use unconditionally as much as possible, but here. I don't know it's I I'd love to use this unconditionally, but that's not what we're doing. Well, we're we're we're working there once I'm playing and MSVC both support this, so it's it's imminent. It's not gonna be OK, correct? Yeah, it's definitely a temporary thing right now. MSVC supports it, except in modules claim does not yet support it, but I believe it's coming soon, hopefully. Hi, it's gonna be. It's gonna be backwards support like you want it's gonna be supported in all standards modes no it will be. It will be specific to C + 23 but that doesn't matter because it's a 23 hour. Yeah great yeah OK and this suggests. Returning auto ref ref. Let's case we don't. Interestingly, there is a difference between returning auto ref ref and decltype auto or there was in certain cases when we're turning like PR values where I think Decltype auto does not attempt to construction and auto refresh did it may have been become moot after the. Serious for 17 deferred temporary materialization so I don't actually know if that is an actual difference, but that's not a concern here, cause unexpected is an actual data member that we have. Although this is correct, the necessary parentheses are unusual and potentially confusing. C Carter suggests returning auto refresh, in which case we don't need the parentheses. And. Since you're here. Our char char char Cras kind of stuff. Correct? I think Nicole was on the call. If she supports this, feel free to speak up and I'll add your name to the list of signatories. Yeah yeah I support it. OK she support uses the template type deduction with reference collapsing roles so do it. If there's some reason that we have not realized why. You can't do that. Then there should be a comment because none of us really able to figure out what that was. Yeah, that that would be real, surprising, and it could be like I just I never know I I like to joke, I used to know how the standard worked and then I lost. That's not completely accurate. I kind of know how this student works when they Add all these new core language features. He knows OK, what's going on here? OK, we're getting rid of constraints instead, they're becoming static, assert is swappable VA nice, human readable message. You must be swappable, that's great, this is just. Wrapping constrained swappable VE must be swappable, Yep. Making sure that we're not adding no throw, there shouldn't be OK. That's all good. Removing the constraint about equality comparable. That's all good. Love the node discard friend. And the deduction guide. Yes, I remember I noticed that this was missed and then that first line test coverage. Moving down there has exceptions. Adding in the protected. Oh yeah, I think this was this was depicted in the standard, wasn't it? Let's go back. Out of the Scary Court language into the library world, expected objects to 15 separate sections here. That expected access. Why are these protected? Are we looking at the void mean? Hmm. The void one is supposed to have default copy. It's supposed to have all of them and the ddor. So. Uh. We're adding these. Do we have a secret constructor? We're making them protected. This is on the Void 1. Oh, here's the protected. The void one is supposed to have protected all of these things. And. They didn't exist at all before, so they were public. That was the issue that was the observable difference, and now miss is making them all protected and defaulted excellent. And then moving down that non standard has exceptional stuff. OK, that's all good. I'm bad. Expect to access this constructor is header only and does not need to be clear this call. That's correct. We comment that it's strengthened. Uhm? We need an occurs below for the yeah. Well, this only twice right? Yeah, it's probably only the twice. And then Yep auto removing constructs because nothing here is constexpr or otherwise. The change is saying. OK, that all looks good. Change this to set occurs below. And. Uh, is that address, parentheses? And all these accessors don't need constexpr. OK, expected itself and this is getting to the point where I need to start reviewing this anyways. Unconstrained and the same with the friendship, then a bunch of stuff happening, so we'll get down there. Anything else of notes? Stable name there. This keeps recurring. Some new lines. OK, again removing the constraints. OK so just in in line with everything that we've seen elsewhere. OK, this is all looking good. OK, so now let's look at the changes as a whole. So we've caught. You make my test changes. Probably not. I did look at the test delta, but the only the only test delta was the the guide. Nothing else has changed in the test, so if you had requested changes the test they have not happened. That is complained about the enum class thing, but nobody agrees with me on that so. There's a resolution Charlie is weird. OK, so you know, Clarksburg. I guess we can take a look at where was it? It's in the test, it's it's in the template with a bunch of non type template parameter like you know class like all these. So a bunch of a bunch of enum classes that are actually bools. And I'm just like. Making them normal enums. And having the NTP's be actual pools would be easier. Umm? Honestly, I disagree like I like, even though it's highly verbose, this avoids confusion. The problem with if everybody's a bool then your confusion is very easily as I know, yeah, but this way it can't be confused. And it's consistent with the pattern used in, like the ranges test, where there's like is common range whatever, right? Yeah, here's a case where like, like the lazy thing is absolutely to use bowls and we actually have been lazy elsewhere. This is like the more disciplined thing to do. Yeah, it's so, so I think it. Doing it with rules makes the task easier to read, and it makes them it. Adds a way to screw operating them. Hmm, but would your concern be addressed if there were shorter names for this? Not really, no. It's yeah, it's like. And also, that's kind of weird to have these kind of. School you know class thing? They're just sort of like strongly typed bulls, but yeah, I mean, you know it is a sort of personal preference like you're entitled to your opinion. Others are entitled to disagree. And in test code I will say I care less to care much more about. Not getting confused about what things are fine. I'm fine for everybody taking orange. OK, sounds good, expected maybe I should this this screen that I'm presenting on is not quite big enough to do side by side. The last time I tried it was very very narrow. Yeah, it's a little annoying. I'll just flip through as necessary. OK, so for expected, we've got some type defs. And it doesn't even offer like 2/3 and 1/3 OK. We get down here. So here's my highlighter, so we've got template on class tie and class air class expected. We can declare friendship without an access specifier, because access doesn't matter there. We grant friendship to ourselves, so every expected can access every other expected. That seems reasonable. Probably need that for like the conversion. And then in the public region, we've got using value type as T using error type as east using unexpected type as unexpected error. We've got a rebind template on Utah using rebind as expected. You error type. That's all good. And we've got some constructors. OK, I'm gonna check those stable lines because we had issues with them before. Expected object ctor, yes? So we've got a constexpr expected. That is being strengthened is no throw, default constructible tie cause this one does have. System does have a value OK. And then this one actually does have a standard constraint, so requires this correct to see here is default constructible. Vt must be true. We value initialize Val. We said has value to be true and we can throw, but we've strengthened the exception specification correctly, so that's all good. Now we're going to suppress claim form it off because Clang format does not handle the complicated requires costs very nicely, yet I really hope that that will improve. Which one is this? Looks like a copy constructor. OK, there's a copy, sometimes explicit. It's very interesting to see conditional explicit on a copy. What is going on here? I especially it's differently constrained. Yeah, just how far something going on. OK so. You're OK, here we go. Is defined as deleted. The constructors trivial. These are the conditionally explicit converting constructors. What about the copy constructor? That's weird. OK, so the standard depicts this explicitly below for expecting account expected UG RAF. But none of that cflow stuff were just the plain copy and move. Is this just a mistake in the synopsis, the class definition? That must be a mistake from the Ingress Paper. Yeah, I would swear I remember telling Jonathan to fix this during one of the code reviews, and I'm guessing he fixed the details but not the. Synopsis declarations yeah, these should be submitted as an editorial issue? Yeah, I'll submit it and add fix for this. OK, you are awesome Casey. Thank you. Uh, OK, so that's good because copy constructors in the standard are not supposed to be explicit. So let's ignore that. Let's just look at the definition. OK, yeah, the difference there. There was actually a since this. I saw it come up on a forum thread. An explicit copy constructor seems real tempting to a lot of people for some reason to be OK, let's be clear about like when we're accidentally going to copy values or not. The problem is that the standard if you give types to the standard library when it expects them to be copy constructible, it expects them to be implicitly copy constructible. Meaning that expressions like T. Equal B where you use copy list in it that needs to work and if it doesn't, then the standard is free to maybe reject your code. Maybe maybe it won't, maybe maybe it will accept your code. It's possible, and apparently it does happen, but you shouldn't. You know violate the requirements of the standard for no reason, so types really should not have explicit copy constructors. The vast majority of the time, and that's why we originally confused to see the explicit there. And I'm glad to see it is not actually in the standard. So we've got. There is a second overload here that's for this triviality stuff. So. Let's get all this check so expected cost expected ref other we don't need to name the parameter when we were defaulting requires. So when is trivially copy constructible V tie and is trivially copy constructible of error when they're both true, then the constructor can be trivial, and we default all thing. So this is good, except that the parameter need not be named. Maybe I'll comment on both lines so you can actually see the equals default. When? Equals default ING. Umm? We conventionally don't bother naming. The function parameter. The idea behind here is that default says hey, just go generate with the compiler generate, so that assumes that you have an understanding of what the compiler would generate, and so naming the template parameter is not really useful. That applies to, like the constructor, A defaulted spaceship comparison operator like. We know they're going to take left and right, so there's really no point in naming the function parameter. OK. Ohh, let's see. So let's that's the trivial bit. This one then needs to be constrained the other way. So, so here's an interesting case where you can see. The library is doing something that is verbose and a lot of people will look at it and with some justification they'll say ohh, look at how complicated C Plus has become like. Look, look at all these requires that you gotta add and there's there's some error to that claim like this is complicated, but you can also view it as the library is trying to express something that is actually quite convenient and intuitive to users. Like saying this constructor exists only if you can actually copy both the type and the error type, and that it's trivial. I think it doesn't generate you know interesting code Gen. If the type in the error are just trivially copy constructible, like they're just integers or something. So saying that the constructor is sort of transparent in some way that you get what it would generate without extra library machinery on top. That would make it non trivial or always present or something, so these constraints are all good. This makes the type behave in predictable ways, but currently we don't have a super direct way to express this in the core language. So we manually construct it using the system of two constructors, one of which is defaulted, one of which is implemented, and they're constrained in mostly opposite ways. But this one also requires copy constructibility. Because if it's not trivially copy constructible, maybe it's not copy constructible at all. And. There's currently no better way to do this. Maybe there will be in the future. We've seen time and time again over the long history of the standard that when the libraries do very mechanically repetitive things, we're trying to express something really elegant. Actually, a lot of this stuff is stuff where if you deleted all the constraints, there is also be kind of the same, except that you get a failure from kind of deep within the library. Yes, that's actually good point. You're just sort of pulling that up into the constructors, so the IT happens immediately. Yes, this is essentially what happened for like a pair. If you had just like a pair of T&amp;E, you would get this triviality. You would get the. I'm not copyable if my data members aren't copyable, it's just you wouldn't get the functionality of looking at as value, which we obviously need. Also, the the thing that would generate code like that would like. Trigger some template that instantiation was bogus was like in one of the base classes of. You know, like in some base class of hair or something that you had no idea about. Yeah, yeah, so yeah, you do need control over all your base classes and stuff. In this case we're not patching over weirdness in the base classes, but we are trying to restore what the compiler would do while preserving this extra logic that we need because having this means that the constructor is not trivial and will always exist. So we sort of have to repair what the compiler would have done in the absence of this in the future, there may be a more convenient way to do this, like I was saying there was a we seen with like variadic templates and in fact. Bring back to default default constructors. Things like explicit operator bool every single or an explicit bool like the conditional explicit every single one of these things. The library imitated for years because we were trying to reach into the future and do cool advanced things with a more primitive core language then the core language finally caught up. I sort of get the sense here with these constraints that this might be a case where the core language will make things more convenient in the future, maybe not. Maybe this is too obscure, but possible. So this is not as horrible as it might look at first glance. I mean, we could write the constraints as as as a concept and and just use that in the abbreviated syntax if we really wanted to. Yeah, and this is actually just occur often enough that we might factor it out. Currently it doesn't occur quite often for us to. Factored out like tuple needs very similar stuff to this, but it needs to work with like arbitrarily many, so we ended up cancelling a lot of stuff right? This one's a little bit different from people, but there is the potential as being more peer like types, not to mention if it's not factored out inside the standard then. The reason why argument for not factoring out? Yeah here either yeah. Then the standard usually does factor things out if it gets real repetitive. Well, that's interesting. This might be where that Unex came from. Why? Why is the the standard he's talking about next year? When I thought it was Val, is that the first here is unex interesting. On X is the data member of the E data member of the expected OOH. Notice that does that mean? I think that means one of my visualizer comments was wrong. It's only the expected that has on X Now it's fine, but it's the bad expected access and the unexpected that is just Val. Oh, but those might. Those might get editorially changed on X. And actually, it's Val as far as the as far as the unexpected is concerned, but it's it's unax as far as the expected is concerned. Yeah, arguably, if that one paper that has been. Preliminarily blessed by the library evolution? Uh, working group. If that renames value to error, there's an argument for changing this veil to unx or error or something bad expected X is already has an accessory and error. Calling them all on X is actually not wrong. It's a. It was a little unexpected for me. Yeah joke but you know I'm gonna go get rid of that comment. I think it's fine. Users can always file a bug if they think it's weird. Yeah, this is fine, but do you wanna say that, UM? Because I'm about to get off the bus and therefore will not be on the meeting in a bit, but. And what's that? Requirements on. Yeah, I think you broke up. I didn't quite catch what you were saying. I did yeah, sorry the requirements on the non trivial copy constructor. Yes. What about them? I'm not hearing anything. If you're talking UM. The requirements on the non trivial copy constructor. That's this thing. If you're not trivial, that's these two. OK, I'll take a close look at that if you could connectivity again, please let us know. OK so I was going to. I just switched to a different network OK and the requirements on the non trivial copy constructor are incorrect because what it says is. Not trivial copy, constructible T and not trivially copy constructible air. And what we want is good .1 or like either. Yeah, the the the they need to be Morgan. Ohh I didn't even look at that. Yeah, let's take a look. OK. It's uh. Requires not that and not that, yeah, that that is not. That's that's wrong. Excellent catch it doesn't. Yeah, this is. This is fine, but this is not right OK? OK yeah, well what I what I mentioned there was am a demogorgon's law which is the Boolean logic law about negating conditions that I think is possibly one of the few things I would say that every programmer needs to know because it comes up so often more than negate the conditions for requires causes. I mean, it's it's a general thing like nobody can change. It's like not A and the change the partial order I think. What partial order? The the the one used for subsumption rules? Ohh, you mean for concepts not Morgan. Ohh that's interesting. I think I would have to defer to Casey there. I don't know how though. Those assumption rules work. I don't think that matters here because. You don't have multiple overloads. OK, yeah, we've just got. We've just got the two. It's the OK. Let's see credit call because she noticed this noticed that. The. He is truly comparable constructible V. Requirements here are incorrectly. I'm not. I was forget exactly how to spell the Morgan's name is lowercase D. Is it a capital DI? Think that's right. I think it's not camelcase. The trivial ones French, we can just we can just make something up because it's not. I forget his nationality. Now let's see X is true and Y is true, yes. Trivial A and let me say T trivial T and. Trivial E, so the implication of that should be. Not. Or not trivial. And the. Additional. Constraints. Excellent catch and that is this is excellent. This is an excellent example of how code review can catch bugs. Because this bug is very subtle, you'll only find it in certain cases where the types don't quite don't produce the same results and. Even in the case where like, yeah, it depends. Like exactly you know which constructors are viable. It's possible there could be ambiguity. It's possible we could get a constructor that compiles, just happens to be nontrivial, which is very difficult to detect. It has observable effects, which is why we do this, but that's a good example of like how code review can find bugs. So thank you, Nicole Nicole noticed that the is trivially constructible. View requirements here are incorrectly to Morgan, the trivial 1 requires triviality and trivially E. So the negation of that should be, not. Triviality or not trivial ease, and then the additional constraint should be added to that OK. OK, uh, this also occurs on line 205. Added to that comment. Good point. Yeah, the move, yeah. You're also, you know that's that, that's for sure there's task. Trivial, oh, we can detect triviality with this trivially copy constructible. We don't need to like carefully look at the code media asked the type traits test coverage, just asked 40 days. Just. Is generally. Let's start with all etcetera to inspect the existence and triviality. Reality for all, and we do have similar. We do similar test coverage for this, where I think pair, pair and tuple. I remember having a non trivial, trivial or implicitly constructible, at least for the implicity constructible. Sure we have that we have for all the new functions here that have kind of. No no. Non trivial if you will. This is such a rich source of funds. Uh, OK. Casey also knows the next. Ohh go ahead this has he checked how this interacts with the cling bug with conditionally trial constructors? That one about the order dependency coding doesn't actually implement conditionally trivial constructors, and it just picks the first one. You knows, it just picks the first one when it's disabled by the constraints or not. Or what happens. My my reaction to that is wolf. Yeah what what? What header did that affect I can find once I know which header it was still not fixed. It's still not fixed last week just of them were in ranges I think was it ranges OK. Because there was like destructor order is intentional or something like that. Yeah. Yeah, cleaning is ignoring constraints on when there's multiple destructors, it just takes the first one. So yeah, we have. The destructor order is significant comment. He he does have the ordering correct, but these are. But this case is slightly different because the non trivial destructor is also disabled by constraints which wasn't the case for our other occurrences. OK, I will add a separate comment for that because that is so much fun. It's gonna be really hard to describe. Yeah yeah, I come with the destructor of the copy constructor. I assume it affects the copy constructor and the move constructor the same as it does the destructor. OK, since they're all special member functions, that might be mistaken. And did ask about the planning bug, where the order of special member functions is significant. When they are constrained and. Sometimes trivial, is that a good well description I could see it being just destructor, yes, but it might be just destructors because beforehand like you could always have multiple constructors. That was always fine. Yeah, multiple constructors is a very new thing. Yeah, this does say this does have them in the right order, so the destructor won't be affected. OK, so basically if he's got client coverage of the copy constructor and the move constructor and the test and I assume. That's present then we probably don't need to worry about this. It does seem to be specific to destructor. I'm so glad that you can get help now. Coming on the destructor. At a minimum we should have test coverage and maybe this comment too. Even if he's got the right order right now. If it's doing the same sort of thing, yeah, yeah. I would like to have the comment on the disruptor. OK, that's just a reminder, but he's reading ahead. Uh. No special member functions. OK, here we go. I am. Should I comment on the whole thing? We were just the first one. OK, Casey reminded us of the. Complicate the clean bug. Where the order of constrained structures is, CF Kent. The order you have here here is to be correct, but one I believe we should have the same comment here as this. Is equally affected. Should we ask for test coverage too or? This coverage for is trivially destructible. Should get this right. Yes. 3rd we have is trivially destructible. Bridge. OK. Casey reminded us of the Clean bug where the order constraint destructors is significant. Transition elvian block destructor order significant the order you have here appears to be correct, but one I believe we should have the same common here as this code pattern is equally affected and two, we should ensure that we have is trivially destructible test coverage. OK in our never ending quest to provide a more conformant experience than the compilers are capable of currently providing. OK, Where was I? I was at these constructors. OK so we got through the default constructor. Now the copy constructor. We've commented on the morning. I did not quite look at the no except condition, so we have a constexpr copy constructor that is no except when is no throw copy construct will be high and is no throw copy construct with the error that is indeed strengthened. Requires that were correctly to Morgan, that would be good. And. Move to these have to be copy constructible and copy constructible T and copy constructible East. OK, that's correct. So that's the this bit. Here and then, if it's true, direct non list initializes Val with DFR tests. Otherwise direct non list initializes unexpected error. OK, so copy over our has value restore claim format. If has value stood construct at the address of value with other value otherwise unexpected with other unexpected. OK. And I was mentally thinking does construct that achieve the direct non list initializes? Yes, it does. So that is good. OK then, here's the trivial one. This one was right. Yes, OK then the move is going to be pretty similar. Umm? Interesting that the move. I guess move is a little bit different constraints. Both of them got to be movable, OK, trivial, OK, same sort of deal. Here's the 205 Casey mentioned move seed or conditional accept here I'm checking for copy paste errors because it's very tempting to copy and paste the copy constructor to the move constructor. But then if anything was not updated, that's a bug. So is no throwing move constructible T and is no throw move constructable. E OK strengthened again. Got it correctly to Morgan. And his move constructible T and is move constructible? OK, that's good copy of the load step required. Is the notebook required? It is, yes, it is good point. Good catch. It is not strengthen. This one is required because no except on move constructors is more important than on constructors, so. OK, let's see. That's an excellent catch and I missed it I. Just look right past it. So I'm very glad you caught. Easy Carter noticed that this exception specification is mandated by the standard and therefore should not be commented as strengthened. I'm like man, I'm I'm clearly slipping if I'm not noticing. Like you know, the one incorrect comment in a sea of repetitive code. What's happening to me? Thank you. OK, so you don't make one pass through this and instantly see every single thing wrong. OK, so if it's true, direct non initialized with stud move, otherwise did move and then post conditions. The write has value is unchanged so we do not clear out the right value. We just move from its guts. So copying has value is correct and then we stood construct that stood address the value or unexpected stood move other value or other unexpected. OK that's all good. We've got a semi colon there though and that is not. Correct or not necessary and is not correct elsewhere, so I will get the single character typo before anybody else notices it. This semi colon is unnecessary. I still got it. OK, hopefully I can find more significant bugs. Yeah, that unnecessary select. Then the move seed or turning off cling format. It's interesting, I'm OK with that, not naming it, which is good. We've got the requires trivially move T and trivially move error defaulted, that's fine. Yes, and that's going to copy over the value, move all that it's not going to try to zero out the value or anything, so that's so good. OK, wow, then we got a big set of conversions or tasks. That's all this, so it's just mirroring what the standard says. This is fun. OK, so this is the conditionally explicit converting copy and converting move constructor. Let's see if we can read the standards and see what it's trying to do. I think it's going to be a little more natural than it appears. So if you are converting from an unexpected of different value type different error type. Then for the first overload, let you off because you ref or just you let GF be constant GF or just G. OK so you got these things exist when my value is constructible from the value of the right as viewed through either the consciousness or the move Ness. That's what this is doing and. The thing itself had better not be an expected. Why is that? Because expected is constructible from at directly yeah here, so we don't want this to ever compete with. Is this handling like expected of expected? Tea had better not be or no can't be conversions. T had better not be constructible from expected, because if it were we don't want to convert the whole thing. We want to redirect essentially to this one. OK, so this is essentially preventing ambiguity. Honestly, as complicated as the set of constraints seems to be, I am so happy that WG 21 is paying attention to the constraints needed for highly templated constructors. Because stood tuple which has. Very complicated overload set had tremendously ambiguous. Constructor is back in the TR1 era and it took many years of cleanup before they became completely unambiguous. I think even now there's a couple LW issues that are still being resolved. I'm very happy to see that expected. It is getting all this right as of the first version, so it had better not be constructible from expected either. L value R value counts or modifiable. It had better not be implicitly. Convertible, OK. The ref ref here on the left I think is unnecessary. Look like an expect. Yeah, I don't wanna see you at all if you're on unexpended, expect. And then similarly here. Unexpected of E had better not be constructible from expected of you and G. Why is this? Don't we control these classes? That is strange. Where are these? Is that for like, an unexpected, unexpected and then yeah, yeah it might be because yeah, I don't see. There's no like direct conversions, but I think that is what it's defending against unexpected of expected, which would be very confusing. OK yeah, but I think it might actually be able to come up right? Hmm? Because you have. Well, it's kind of an error success situation, isn't it? And this is where you want to initialize with the unexpected. OK, in any event, the the standard list these requirements, we just need to implement them. I'm convinced that they were trying. Like library evolution will talk extensively and actually library classic would have talked extensively about this. So if all of these conditions are met then. Forward the value otherwise forward the error. UM, aren't just as unchanged. There was expressions and then the expression site explicit is equivalent to not convertible or not convertible. OK, so if either of these are not implicitly convertible, then the whole thing needs to be explicit. OK, this is really nice. This is an example of why conditional explicit just dramatically minimizes the amount of code and standards we need. Otherwise we would need to replicate all this nonsense twice. For both explicit and non explicit, and have additional constraints, which would be awful. OK, so Misco is extracting all of this lovely standard ease into a long set of requirements. He's calling. It is not convertible. But this is a static constexpr ruled within expected itself, so I'm OK with having a fairly terse name. If this were top level, I would really want that name to be longer because it sounds. Doesn't sound like it has anything to do with expected itself, but because it is specific to expect it. I think I'm OK with this. OK, so it's templated on Utah and new error, which are the you and G. Instead, constable equals and then we expect all this to match. Let's see if this is cracked. Here's an highlighting. OK, so we start off with. I am. T&amp;UF no those UF ones must be specific to the constructors because it varies between the copy of the move, so it's just the common stuff. Here OK here we go. So all these things need to be let me erase this garbage. All these need to be false. Every single one's gotta be false, so that's why all these need to be not and OK. So we're looking for. Use constructible V for the first set of four. The T from either expected of you and G, which is UD&amp;U error ref or the non ref version. Or the constraints or the constar value? And then the next set is is convertible, which confusingly reverses the parameters. So the sense is different, so that's why the time now appears on the right. So you get expected L Ruff. RF there, this exactly matches the standard, even though I claim that this RF should not appear in the standard, I'm OK with mirroring what the standard says in this case. We we have asked previously to omit the RIFRAFF in other cases, but these set of constraints is so complicated I'm inclined to say let's just do what the standard says. OK. If we were simpler, I'd be like, yeah, let's be a little inventive there. The rationale there is when type traits are specified in terms of Deco Val. Ref ref. Is not necessary because Deco Val will implicitly add it. And here we know decals added on the right and on the left right of constructible and left of convertible. But if the standard did it work? Again, UU error. This is all good and then finally unexpected of E. That's our error versus expected of UD&amp;U error. Either ref or not constant ref or not. OK exactly mirrors the standard wonderful. OK, this is depicted. The one thing I noticed. This is depicted in terms of a long chain of variable templates. We could in theory convert this to a conjunction of negation of is constructible, which would be more verbose. Admittedly, it could potentially allow the compiler to short circuit. However, I don't know if that would really buy a lot of throughput compiler speed, because if it doesn't short circuit the sort of ultimate time is the same. The short circuiting only happens when considering. This thing which looks like it converting constructor and wanting it to defer to another constructor. Which seems uncommon. When Ty is actually constructible from expected and so forth. Like all these conditions are possible, but they're pretty whacky coda, I think, has to be pretty pathological for any of these to be relevant, which argues in favor of just directly writing it, like Misco has, rather than writing the more convoluted but potentially faster throughput version with conjunction. I'm OK with this. I strongly prefer this. OK, if it ever turns out to be through problem, we can revisit with conjunction. Otherwise sounds good. OK, thanks Charlie. OK, so with that, let's take a look here. OK, so now we're going to see the remaining constraints. It's a little narrow. OK, so we've got template on Utah and new error requires. So here's these first constraints that we want to see. Our time needs to be constructible from Conce Utah ref because this is the copy. Yeah you ref. And error needs to be constructible from constitute error ref OK. And, uh, we should not be convertible from Utah and new error. OK, that's very nice then. Context for conditional, explicit and then the conditional explicit is. We should see not convertible UFT or not convertible GFE's OK. Not convertible from Consulte RAF to Thai correct or not. Convertible consume erft error correct. OK this is the copy constructor converting copy from other or conditionally no except when is no throw constructible V tie from construed ref and is no throw constructible error from consu ref. The copy is strengthened and so will the move, cause it's not an actual move constructor. OK, copy over the has value. If has value then do the construct add. Otherwise do the unexpected construct add OK, that's good. OK, going a little faster now. Your error OK here we want to see not the counts draff but just the plain type Utah. And constructible error you error and not convertible Utah you error good constexpr simplicit not convertible from. Let's see where that tier. OK yeah, we get the UU first so U Thai Thai or not convertible ur error. OK, that's correct. Converting move constructor conditional no, except that strengthened time needs to be nothrow constructible from Utah. No construct and no throw constructible error from you error correct copy that has value, but then. Forward, not move forward. That's this year. Utai and you error excellent. OK, that's the converting copy move. Now we have the Utah reference struct. OK, just a little simpler. Can we back up for a second? Ohh sure you should forward instead of move here. Yeah, that's uhm to these be reference types. That's a good question. The standard uses for when they could be reference types has expected forbidden reference types. I think it required object types, didn't it? I thought so, yeah, but I'm not seeing it. There there were all the the static assertions unexpected. I thought they would be here year ago. My program that instantiates the definition of template expected TE for a reference type or blah blah blah is bad, so we've already enforced that. It's good, that's a good point if we don't worry about reference types, then forward buys us nothing. It should be moved in the standard. There's yeah, only lvalue references and rvalue references could make that a problem, but. It's not a problem here. And that buying that's binding on both the type and the error. So unless they were trying to like reserve space for the future, that's not necessary. I'm OK with doing what the standard says here, but it does seem that there should be an editorial issue about. In this case, because it is within expected, it's not some arbitrary here. These could just be moved. If we switch them ohh I see I see right to doing. It's the specification shortcut. Here, they're specifying both the copy and the converting move by condensing them in terms of UF. So if you're going to do this, you do need forward to add the cost you roughness. Otherwise just get you, but if they split this out and said just access RHS dot Val or move stood move from RHS dot Val then you wouldn't need to see the forward, but because they've specified things in terms of UF, forward is the correct way to handle it. In the implementation, it could be a move. That's interesting. Should we ask for a move there? This more closely mirrors the standardise, and it's not wrong. It's not doing exactly what the standard is doing so. You know that mirroring the standards is a great argument. Yeah, I think I think move is reasonable here. I I would kind of like a move here, OK? Just to make it clear that this is always a move always, effectively move. OK, let's see. If you want to replace all of them with static casts. The difference between moving forward is very important. Notes that although this technically mirrors the standard ease, the standard is taking a shortcut by specifying the converting copy and converting move ctors together with whatever they called UF&amp;GF. Command chief. Umm? The. It's packed. Has already forbidden reference type reference types. So when you know. We're implementing the converting. I'm trying to be careful here because the converting move sedor is not an actual move constructor as far as the core language is concerned. So when we know we're implementing the converting move seed, or we can simply say stood move. The. Reserve on all, say congratulations conventionally. Reserve stood forward in the implementation only for perfect forwarding. Or situations like hair. Where? Handling reference types is. Necessary OK, how does that sound? Casey notes that although this technically mirrors the standard, is the standard is taking a shortcut by specifying the converting copy and converting Moors together with Ugf expected has already forbidden reference types, so when we know we're implementing the converting moved or we can simply say stood move. We conventionally reserve stood forward in the implementation only for perfect forwarding or situations like pair. We're handling reference types as necessary. Cool, if somebody wanted to use the mirroring. The standard wording argument. I would point out that they didn't mirror the standard wording. Empty constructor above the copy converting. Yeah, they're hard. So good point. I like it. OK, let's see. I think we have time to look at one more constructor, which is this ulefone. OK so. Claim form it off on because we've got the requires there template on class U = T and then we got the constraints. So these constraints here are a little involved so if I can get them on the same page. This has to be false, not the same V. Remove CVF tuty in place T better not be an in place T and not the same V. OK, he's swapping the sides here, but that's OK. Uhm, expected of us, so that's just expected. The injected class name as remove CV ref to fu. OK, that's good and. Uh, because we know, is Sandia symmetric. Remove CVT of you is not a specialization of unexpected. This really should be a standard trait and is constructable. Vtu is true. OK that's good and the requires is good. Is that an empty comment that's wrapping it is that is not necessary in a claim form and off block. Umm the? Empty comment is unnecessary. In fact, I once failed the spelling because I couldn't spell necessary is unnecessary in this playing format all block. OK. And continuing. OK, constexpr explicit. Yet we are explicit when not is convertible V. You to T OK expected construct from UDF other and then we're strengthening. He is no through constructiv tie. That's our tie from Udy. OK, that's good. So then we direct non initialize Val the value. And we always have a value, so we can just mention it in the list with stood forward to you. OK, so it has value. True, that looks good. Uh, is that the correct order? I'm gonna check, I know we've got compiler warnings now about the order. I'm surprised that has value would occur last. Where is the data member? Oht is it is last we've got the Union and then the has value. OK, that's good. And we were. Here. OK, and then we've got. Constructors for unexpected OK and pull up. OK so I will copy this to remind myself where I am. OK, it looks like we have gotten through maybe about 100 lines of class expected. I will have to continue reviewing this offline, but we saw a lot of great stuff today. Great catches from everyone. Thank you for finding all of this stuff. I will go ahead and submit these comments. I guess I am requesting changes so I will say request changes. And I'll submit a comment so I can collapse it later. GitHub does not let you collapse things that are submitted within the review itself. OK. I thought I deleted this. Did I not delete this comment? I think it might not have deleted it oopsie. Umm? I'll comment on this. This is the Annex 1. Never mind here, on X is displayed as a data member of. Expected and although it's not the name of the. Exposition only numbers or what was that? Unexpected. And bad. Expected access that seems clear enough. OK think about ax, yeah, never mind here on X is latest date member of expected and that's not the name of the expedition. Only members for unexpecting bad expect access. It seems clear. OK. We've got the easiness pistol, the auto, the can we use auto rifraf. I don't name the parameter. The Morgan and extra currents and test and comment about the destructive order. This one is standard and this semi colon forwarding empty comment OK. Note to self. Partially previewed. I keep typing expected. It's gonna keep happening. To including this. So let me see review this. Progress is monotonically nondecreasing. OK, partially you had expected up to and including expected you to refer further. Still need to review test mention that it's a video review. OK, there we go. Comments are submitted. Let's see, have there been any questions in the chat? I will stop sharing my screen. And check. OK, Cameron jokes. I think it's fair to say that this review has taken longer than expected. Nice one. Uh, OK Casey's got some comments about traveling Meow concepts that would be nice because concepts have that subsumption thing, where if you constrain with a concept that the compiler can see is stricter in some sense than another, it's considered to subsume the smaller concept, and overload resolution recognizes that, which is awesome. That's something that's fine, does not get sphene, is just like, oh, you're throwing a bunch of tools at the compiler and you need to very carefully construct your overload set so that. Exactly one of those overloads lights up and the rest are disabled by the Phoenix with concepts you just constrain them all, and then as long as the concepts are arranged properly, the compiler can see in a process that is either partial ordering or very similar to partial ordering. That, oh, this one is the most specific because it wants is trivially fancy constructible now rather than just Disney now, so it'll select the better one. Much like having a more template. Or if you've got a bunch of overloads like pair of TU pair of T, star T star pair of in Star double star, the compiler will select the most specific one that's always been baked into overload resolution. Having that in concepts is very nice. So yeah, I agree that having concepts. That sort of supersede the type traits that would be good. And then Cameron hypothesizes having a concept of capture if all teams are trivial would be a good abstraction. Yeah, seems reasonable. OK, looking through the comments, some comment about the exception specifications and the auto ref ref which we all talked about. OK, I think that's everything that was brought up. Let me know if I'm missing anything. OK, I think that's it so we can call this a code review. Thanks for watching Part 2 of this. There may be a part three depending on how quickly we get through the rest of expected. In any event, we'll see you next time.