WEBVTT

>> Stephan: Hi and welcome back to another VC libraries Open code review. Today we'll be looking at a PR from Nicole called Re-enable ASan string annotations. This is PR #3164, so the background here is that MSVC is working hard on adding support for the address sanitizer that was originally implemented in clang LLVM. So we're taking their open source code base and applying that to MSVC, and then, additionally, our containers, in particular the most popular contiguous containers, std::string and std::vector do something that is a little bit unusual compared to how users directly allocate memory. With a string or a vector, the container will allocate a big block of memory all at once, and then construct within it either characters or elements, and as more elements are pushed back or emplaced into the container, um, the originally allocated but not yet consumed memory is used to store those elements, and it's only when the container runs out of unused capacity that it needs to reallocate. And both string and vector use what's known as a geometric reallocation policy. Well, they'll, where they'll allocate some multiple of their capacity whenever they need to grow. This is somewhat counterintuitive, but it means that pushing back into them results in amortized constant time, which you would not get if you had a naive policy of: "oh, let's just allocate like plus 10 elements or something", which other libraries have had, but the STL has never suffered from. So the fact that for string and vector the allocated memory is different from the memory that actually holds elements, or that the capacity in general can be larger than the size, um, poses challenges for ASan. For address sanitizer, we would like out of bounds accesses to be detected if pointers or whatever are being dereferenced into memory that does not actually hold elements. So just because it's been allocated, if it's in that unused capacity between the end of the container size and the end of the container's actual allocated capacity, we would like that range to be considered invalid. Merely looking at what allocations the program is performing would not be sufficient to do that. So that's where these annotations come into play. There are special commands that you can give to the address sanitizer machinery – and Nicole, please jump in to correct me if I'm characterizing this incorrectly – there are these commands that you can give to ASan that say: "OK, I have allocated some memory, but even though that memory has been allocated, I would like you to consider it bogus for the time being". And these are… these are what are referred to as annotations. So we've applied those to both string and vector, but then we discovered problems with the string annotation. String is an unusual container because – unlike vector – it has Small String Optimization where strings that are below um 16 narrow characters can be stored directly within the string itself, that never happens for a vector. And additionally string has interesting alignment properties compared to vector. It does some unusual math there. So we discovered some pretty severe problems with the ASan string annotations and had to disable them before shipping so that it wouldn't go break users who were enabling address sanitizer. So that has been the status quo for a while. Nicole has now done the intensive investigation needed to restore these annotations and get them correct. So that's what we'll be reviewing today. So that is the background. Let me take a look at the files that are being changed here. And Alt Click to minimize everything. OK, so we have got changes to the ASan tests, the existing tests, we're not adding any new tests. And then we've got product code changes and we've got a new header being added, an internal header <stl/inc/__msvc_sanitizer_annotate_container.hpp> So the presence of a new header means that we need to follow a checklist. In the STL we are very fond of using checklists for any complicated processes that we have to do so that we don't forget important steps. Um, if it's useful when flying a plane, it's useful when making changes in the STL. So here is our wiki page. I fondly refer to this as "hack these files" because that was the name of our internal SharePoint document before we made this public. Now it's called, less excitingly, files to edit when adding or removing files. Ideally this would all be automated. In practice we just need to make manual edits to a bunch of different places. The most annoying part is actually automated. That's the part that Amy took care of in the MSVC internal repo, this LKG thing. So there's just a script you need to run there, but for everything else it needs to be essentially manual. So many possible things to forget there. I will be comparing against those. Let me split these. Um. Wow, that split is not great. Can I make that flow into a single line? Yes, I can. OK. So, new header. I'll take a look at the new header. Um, let's first go through. This is divided into 3 sections, edits in the GitHub repository, MSVC internal, and then VS. The VS IDE needs to be told when we're adding new extensionless headers, like the upcoming <print> header. This is not an extensionless header because it's internal and nonstandard. It ends with hpp, so that's not applicable. So on the GitHub side, new header means we should edit CMakeLists, because we need to tell the build system to copy these things. So here it is. Uh, we've got. I'm virtually certain this will work because if this were misspelled, it would not work at all. Here we go. Amy has commented that yes, there is a needed setup change. Yep, that is absolutely correct. That's called out in the document here. It's below. So we've got the new header being added here. It's in sorted order. sa comes before sy, perfect, and that's the only edit. There's a few files where we need to make two edits. This is not one of them, so that's good. Um, Next up, there's a file in our legacy MSBuild directory, and this is not a source file. It's not separately compiled, so this isn't applicable. Um, so next is if you add a public header that is intended to be directly consumed by users, we need to put it in this test helper. But this is an internal header, it's not intended for users. Onward header-units.json. This is used for the C++20 header units feature. When adding headers, regardless of their whether they're public or private, they should be eligible to be automatically translated with a compiler option from includes to header unit imports. So we do need to edit header-units.json, and here it's being listed again, it is in sorted order. That search is not picking it up because I expanded that. Yep, that's great. OK, there will also be needed edits, internal needed edits internally because there is a compiler test for header units. OK then, that's in the section below. Here we're only reviewing the changes for the GitHub repo. OK, this is not a standard public header, so no impact on the named module. It's not a public header, so we don't need to test whether it can be included alone, and not a standard public header. OK, so checklist is good for the GitHub repo. We will have to do additional validation for the MSVC internal repo when we mirror this over. OK, so I'm gonna go ahead and close that. Uh, let's take a look briefly at what code is being extracted. Nicole mentioned that to avoid duplication between vector and string, she's lifting code out into this new internal header. That's why we've got it here. So I'm going to briefly scan to see OK, some of this /alternatename stuff and then actual changes to string. OK, and then vector. Again, the stuff that turns on the annotation, more of that /alternatename stuff. Yeah, that code is either, it's, I think, not quite identical, but it's extremely similar, just sort of exchanging vector and string or swapping, swapping them out, replacing them. So OK, I believe that's what's being unified. So now let's take a look at the new header. OK, so when adding a new header, I like to look at an existing header for precedent, because here we don't exactly have a checklist, but there is a certain dance that we need to follow of special macros to defend against and so forth. So vector is a good one, it's a great header. OK, so here's vector. Let's split this side by side. Nope, that's not what I want. There we go. OK, these uh, 120 length lines are a little bit too long for this window. That's OK. How come I don't get a horizontal scroll bar here? That's quite annoying. Uh, OK, so let's review this. Um, first, let's make sure that the header name is spelled properly. It is. OK, so we begin with a comment saying whether it's standard or internal. The idea is that tools could pick this up to distinguish between standard internal headers. I don't actually know if they ended up doing that, but that's just our convention. This is one of the rare cases where we allow anything to occur before our banner. So this is indeed an internal header. We've got the banner for a new file, which is good. Uh, we've got the #pragma once. We do not have a classic include guard. This is not conventional. Um, even though pragma once does supersede the include guard and can be used by itself, and we do do that for like internal test headers for all of our public headers we define an include guard. The theory being that we can use this to detect when headers are included. It seems like a good system to follow. Interestingly, this is also not doing the usual dance of pushing and popping packing, or disabling warnings, this is purely macros? We've got some declarations.

>> Nicole: There is exactly 1 declaration of container, er, __sanitizer_annotate_contiguous_container.

>> Stephan: Yeah. Alright,

>> Nicole: sorry, I, I don't know if that if that requires pushing and popping. Yeah, there's also a couple declarations. OK, um, there there are a couple of declarations of variables. Mostly I think that we, I think we should have the, the macros, the macro defenses, the warning defenses. Mostly because headers grow over time. Today we're adding stuff for sanitizing vector and string. Tomorrow it will be small vector or super string or, or who knows what they add. In C++, you know, 37 or or whatever. Um, uh. And if we don't have those defenses, it would be very hard to notice later on that they're missing. Additionally, we should defend against things like non compiler tools like Qt's mock dragging this in, unless there were an extremely good reason not to. I think we should have the usual incantations, so I will add a comment here. We should have the usual incantations for a… a header, um, including preprocessor – let's call them classic – um, preprocessor guards, uh (which we conventionally have in addition to #pragma once). Let's see. Uh, what else? The – this is not an exhaustive list, it's just a quick summary – the _STL_COMPILER_PREPROCESSOR defense, the packing/warning defenses, and the `new` macroization defense. Even if they aren't needed now, this could be useful if code is added/moved in the future, and it also serves as a good precedent for anyone copying or imitating this header. OK, got all my escapes there. Start a review. OK, so #pragma once, we are going to imagine the usual defenses being present, OK? Then I don't think I need to look at vector anymore, because that's really just a reference for the defenses. OK, let's look at just the code here. So we are extracting some stuff, but first it is guarded. For my nemesis /clr:pure, which we do not activate any ASan for. Um, we, we need to ensure that /clr:pure continues to compile, but it does not participate in any of our new features. So guarding here is entirely appropriate, if not defined _M_CEE_PURE. That's the macro predefined macros documented that indicates /clr:pure. So for not pure. And the other thing that I'm checking for is I'm currently working on changes to extend /clr, the plain one, not pure, to more headers. So we're trying to avoid as much as possible any special code for plain /clr. And this is not caring about plain /clr, so that is good. So if we're not pure and grouped together, we are not simultaneously disabling vector and the string annotations. So if either are enabled, we want all this stuff. It's only if they are simultaneously disabled that we would not want this. Does this make sense, I think so. So what would De Morgan do? If defined pure and… Uh, either not defined vector… Yeah, it doesn't read better De Morgan'd, it reads good. Uh, it reads, um, comprehensibly the way that Nicole has written it. OK, so for not pure and we have not simultaneously disabled both. Then let's define the support machinery. I think I want to quickly check that these are the right control macros. I'm assuming that they are. The old ones were _DISABLE_VECTOR_ANNOTAION, singular, and Same for string, _DISABLE_STRING_ANNOTAION, singular. OK, not too worried about typos there. We do mention vector before string, there's no real argument for sorted order. OK, that's fine. And the nice thing is that the rest of it is at least consistent vector before string, so OK. OK, so if we're not pure and we haven't simultaneously disabled both, then declare cool stuff. At the end We have matching comment #endif not _M_CEE_PURE, and ASan has not been disabled. OK, that's the reasonable summary. Uh, we have those #endif comments so that we don't forget which #endif pairs with, but especially because clang-format insists on indenting everything at 0. Then, if defined, __SANITIZE_ADDRESS__, which I believe is a compiler macro indicating that /fsanitize=address has been passed on the command line, I see Nicole nodding, so I've guessed that correctly and that's matched with insert ASan annotations. OK. Um, so if we are compiling with ASan enabled, then do stuff, otherwise do nothing. OK. Does it make sense to have these are separate tests? Yes, otherwise, if we fuse them into a single test that get real confusing. It seems reasonable to have multiple layers.

>> Nicole: So, uh, yeah, this that is actually not the end of that #if it's not, there's a, there's a big block at the front.

>> Stephan: Oh. Right. Yeah. I see. OK.

>> Nicole: And then, all of the other things. >&gt: Stephan: OK, then other stuff. OK. Thanks for pointing it out. >&gt Nicole: Because clang and MSVC do this differently where MSVC defines __SANITIZE_ADDRESS__, clang defines, you know. __has_feature(sanitize) or something like that.

>> Stephan: Ah, OK. I see that here. OK, yeah, line 19.

>> Nicole: oh yeah, address_sanitizer. Um, and then finally there's. Doesn't have any address, doesn't have ASan turned on, but we're building like an internal CPP file and therefore we need to at least make sure that the string annotations are correct.

>> Stephan: OK, that makes sense. So it's not a whole file thing. OK, thanks for pointing that out. OK, very useful. OK, so it actually matches up here. OK, good. That is the right macro, OK. So if we are defining __SANITIZE_ADDRESS__ then… OK, these look like macros that are either: if they're defined, they're active; if they're not defined, they're inactive. OK, so we're going to activate and insert vector annotations. Same for string. Otherwise, OK, here's the __has_feature that Nicole mentioned, if defined __clang__, and defined __has_feature above __SANITIZE_ADDRESS__ below __clang__. This is not 100% matching the condition, but it is OK um, this is already pretty lengthy. I think that's reasonable. I won't complain about that. Then if we can use __has_feature on address_sanitizer, then define these four macros, insert vector and activate vector and so forth, and then have a #pragma comment(linker, …) for ASan libs. I think this __clang__ does not imply this the way that MSVC does because of __SANITIZE_ADDRESS__ OK. Otherwise, OK, I like the spacing here or the new lines because this helps me keep track of what's going on with all the preprocessor stuff above __clang__ below. If we're not __clang__ and we're not __SANITIZE_ADDRESS__, OK, then our fallbacks are: if we're supposed to annotate vector, insert the vector annotations, but do not try to activate. So basically, like Nicole mentioned, mark the regions of vector that are valid or invalid, but don't actually try to terminate the program or anything if invalid accesses happen. Um. OK, the comments here are messed up. Um, this #endif should be commented _ANNOTATE_VECTOR. This #endif matches with _ANNOTATE_STRING. OK. There… the… #endif comments here are… Uh, need to be fixed. The #endif comments here need to be fixed. OK. So _ANNOTATE_INSERT…, _ANNOTATE_INSERT_VECTOR, …VECTOR, …STRING, …STRING. OK, so once the #endif comments are fixed it's good. And then #endif. The whole region began with __SANITIZE_ADDRESS__ OK. And then… OK, these are also missing #endif comments. I am going to be a stickler about the #endif comments here just because of the preprocessor stuff is so packed together and it's not just like a single #if/#endif in a stream of mostly normal code, um, needs. There the rationale and we are, we are a little bit flexible these days on omitting the #endif comments, but I'm, I'm generally a fan of having them because this code is added to preprocessor stuff. It really helps keep in track. We've seen other code bases, we work with other code bases where they do not have the same #endif discipline and it can get quite hard to figure out "hey you know what, what region are we in here" as I just got confused. Needs #endif comments. OK, so. #if _DISABLE_VECTOR_ANNOTAION has been defined, then #undef the _ACTIVATE… and _INSERT… OK, so it's a full escape hatch. Same with string. OK here I'm just making sure that there's no vector string swaps. If I was extremely paranoid or GitHub made it easier, I would be like in VS code. If I double click one, it'll highlight lightly all occurrences of the thing. I can do that manually by searching. This is what I do if I'm very concerned about typos. Here the macro name is short enough that I can notice typos, I believe, or like double underscores, or anything like that, so I think that's good. It's a with the preprocessor Because of something like not defined, preprocessor statements will happily run with that. Typos are much more common than with ordinary identifiers where you typo, well, you're going to get a compiler error, so you don't have to be constantly worried. OK, so next up. Now, after determining the values or the defined… definedness of _INSERT… and _ACTIVATE…, we're going to emit some detect mismatches. Mismatches. This helps us make sure that everything being linked into a single binary is going to use consistent definitions of these macros. I'm very happy to see that this is being used for ASan. This is actually a feature that I requested from the compiler back in 2010 when we were struggling with _ITERATOR_DEBUG_LEVEL mismatch and it was just not diagnosed at all by the toolset. I asked the compiler team, hey could we have like a #pragma? And we invented the scheme that was originally only for the STL _ITERATOR_DEBUG_LEVEL but was specified in a generic way that it can be extended here, where if you send a #pragma detect_mismatch to the compiler front end, it emits a linker directive which is /failifmismatch and it just works on a pretty simple key value system with strings. detect_mismatch takes a key and a value. These failifmismatch directives then tell the linker, "hey, if you ever see a source file or an object file with the directives that set the same key to different values than some setting is really incompatible, you should fail the link". The linker doesn't actually know anything about ASan or _ITERATOR_DEBUG_LEVEL, it just knows about these keys and values. So this is a sort of generic way, extensible way for us to ensure that inconsistent things are not linked into a single binary. OK, so if not defined… Oh, and the other thing about detect_mismatch is the linker will only complain if it sees two of the same keys with different values. It will never complain if it sees one TU you with a key value and another TU you with nothing. So if you want detect_mismatches, you've got to have them from the beginning. So for example we can't detect mixing like VS 2008 code with 2022 because that totally predated. Of course it will fail to link for other reasons, just not detect_mismatch. OK, so vector, vector, vector, string, string, string. Good. If we haven't defined _INSERT_VECTOR_ANNOTATION then "annotate_vector" is off. OK same for string. OK, "0" mean off, "0" means off and then activating. Um. Oh interesting. So these are being done separately. So if these are ever like really set inconsistently, we'll end up getting a detect mismatch "0" and "1" in the same TU, which is super horrible and will totally fail the link. OK, so if you haven't turned on even just _INSERT_VECTOR_ANNOTATION, then you clearly want it off, if you're actually activating the vector annotations, meaning do the checks and terminate the program, If you see badness then _ANNOTATE_VECTOR is definitely on. And in the middle case, if you are inserting vector annotations, but you have not activated them, then you don't have any detect_mismatch. I believe this is intentional. That allows our separately compiled libs to, I see Nicole nodding so I'm on the right track. Emits the annotations um to update ASan about what regions of the vector are valid or not, but we're not actually performing any checking, so it's OK to mix that with something that will perform checking. That seems correct and this…

>> Nicole: and to be clear here, the reason that we can do this is because of the /alternatename comments below, or the alternate name um, annotation below? I don't know what.

>> Stephan: They are linker directives I think.

>> Nicole: Thank you, directive. Because of people [silence]

>> Stephan: Um, your your audio is completely broken up and your video is frozen, if you can still hear me.

>> Nicole: Nooo, can you hear me now?

>> Stephan: I can hear you now.

>> Nicole: OK, cool. So uh. Basically, if you don't link with the address sanitizer libs. Then you get the default behavior of calling into that alternatename function. If you don't get those, if you don't have that, uh, if if you do, sorry, you do link with the Address Sanitizer libs, then you get the actual behavior of doing something. I hope that made sense.

>> Stephan: I yeah, I think that makes sense. I think, um, there may be one case here that we're not detecting that. Actually, no. Maybe it's… Maybe it's not too bad. Yeah, yeah, I think this is actually… this is correct in all situations. I was wondering what about the case where you have one TU, translation unit, that is inserting the annotations but not activating them, and that's linked with another TU that is not even inserting the annotations. Wouldn't that lead to inconsistent annotations? But that's safe because the one that's not even inserting annotations has a detect_mismatch of "annotate_vector" "0" and it's OK if some but not all TUs are inserting the annotations. But we have forbidden anything from trying to activate them because the one that didn't bother to insert the annotations turned on the detect_mismatch. So and no point can you ever mix this setting and this setting. But if you have setting in the middle that will link freely with one or the other, it just can't be used to chain them together and end you with a bad situation where some but not all TUs are annotating and then somebody's trying to activate them. So OK, this makes sense. And I assume you're simply extracting the existing scheme that we had in string and vector, but sort of just mentally double checking it now and this makes sense. OK, so for _ACTIVATE… we got a vector, vector, vector, string, string, string. That looks good. Everybody says activate. And either one will insert a #pragma comment(lib, …) for "stl_asan". We use the same support lib for either vector string. If they're both being activated, we'll get 2 #pragma comment(lib, …)s. That's OK, the linker will survive. It would be more work to try to avoid that. We could have a separate preprocessor preprocessor conditional that says #if defined(_ACTIVATE_VECTOR_ANNOTATION) || defined(_ACTIVATE_STRING_ANNOTATION), then have the single #pragma comment(lib, …). But. There shouldn't be harmful to make two of them, um. Then the detect_mismatches are different. OK good. Next. Nice comment explaining what's going on here. Only _INSERT_*_ANNOTATIONS should be used from here on. So for the rest of the files we will #undef …STRING… and …VECTOR…. As a nitpick, I notice that this is not using the same order. This is saying string and then vector in sorted order. It doesn't really matter and I guess it is the opposite of the definition order. My brain notes that, but it's not really harmful, OK. And we have expanded.

>> Nicole: That's why I put that in that order because it was opposite, so the declaration order.

>> Stephan: OK. Push, push, pop, pop. Makes sense, yeah. OK, next we have extern "C" blocks. We have not included anything. We haven't even included <yvals_core.h>, which the central with the which "usual incantations" would probably end up doing because we want at least _STL_COMPILER_PREPROCESSOR. We might want to use the _EXTERN_C macro here. It always expands to extern "C". It's not absolutely necessary. Let me, let me check the precedent. Um, do we use? Plain extern "C" blocks in stl/inc. Let's turn off this. We do. We have a macro _EXTERN_C, but we do not consistently use it. Um, we've plenty of uses of plain extern "C". OK. That the existence of that macro, I believe dates back to when yvals_core.h could actually survive as a C header, which we no longer support. I do wonder whether we should comment at the close here of that extern "C" block. Usually I feel that we do. If it's big. I don't know if we have a lot of examples of big ones, it's not actually that big here. That's about the upper limit of what I would, uh, find reasonable. Yeah, everything else is so small it doesn't get a comment, and if clang-format doesn't add one, it's fine. These `#endif`s are at least I know I'm nitpicking, these are at least only controlling one line and they're separated from everything else. I don't feel that they absolutely need comments. OK, so #ifdef _INSERT_VECTOR_ANNOTATION, we have an extern const bool _Asan_vector_should_annotate similarly for string and string. That's good. Here I'm mentally checking do we need anything for modules? We do not because it's extern "C". And I'm sure that was capturing the original code as well. Um, OK, Next up we do have a combined #ifdef check if either defined( _INSERT_VECTOR_ANNOTATION) or defined(_INSERT_STRING_ANNOTATION), then have all this common support machinery. OK. And this is the #endif. I believe that's paired with that #ifdef _INSERT_VECTOR_ANNOTATION OK, so then we're gonna have an extern "C" declaration of a function. OK, so going through my mental list. Um. It's not template, it's not static, not inline, explicits procedures only, it's not virtual. We return void, so no reason for like [[nodiscard]]. Always needs a calling convention __cdecl __sanitizer_annotate_contiguous_container has some names of parameters, _First, _End, _Old_last, _New_last, all ugly, all ugly. It is not marked noexcept. But we might need to survive, OK? >gt; Nicole: It's not marked, noexcept in the address sanitizer header and so, if you included both the standard header and the actual sanitizer header, you would get noexcept mismatches.

>> Stephan: Ah, OK. OK. And extern "C" will, at least under /EHc, assume that it will not throw exceptions, so that seems reasonable. OK, and then a dense forest of #pragmas. This is, I'm assuming, just extracting what we already had. Um. This is the sort of stuff that is needed for it to work, so I'm not too worried about typos here. I'm just going to check the architecture conditions. We have so many architectures, it's fun. #if defined(_M_ARM64EC) [EC – emulation compatible], then they've got these real special mangled names #elif defined(_M_HYBRID) for the CHPE older architecture. OK. #elif defined(_M_IX86) for x86 otherwise for the normalish architectures …X64, …ARM, …ARM64. OK, so we have to intercept …ARM64EC, and …HYBRID before anything else because these are overlapping otherwise. The classic ones …X86/…X64/…ARM/…ARM64, these are all mutually exclusive so the order here doesn't matter, and this is reasonable, we do this elsewhere. And then if none of those have been activated, well, you're compiling on, you know, something from the far future, so we say "unknown architecture". OK, that seems reasonable. OK. Yep, uh, the …X64 and so forth mangling does not add anything, and we just say use the defaults. …X86 adds an extra under score for extern "C" …HYBRID adds some of these pound signs. OK, that'll looks good. OK, and our validation ensures that the header ends with a new line. OK, this looks like a good header. OK, now let's look at um, maybe <vector> first before we get to the actual <string> stuff. This is essentially should be

>> Nicole: I recommend <xmemory> first. OK, first because it has a very large comment. That's exactly what's going on, and our annotations for vector were wrong in very specific weird cases.

>> Stephan: Ohh, interesting. OK, well let's review that then. Thank you. Um. OK, <xmemory>, which is one of our centralish internal headers. Although not the most central, this is one is included by, like, all of the containers. We have a struct. This camel case naming is not quite conventional for us, but it's OK-ish. Umm. Though that's new, we didn't used to have that. Uh, we should probably follow the convention. Yeah, I'll comment on that because if we want to change it later, um, it would be possible to change, but we should have followed the convention now. OK, let's see. We conventionally use _Ugly_snake_case for types and functions in the STL. _UglyCamelCase is used for template parameters like _RanIt. It's a good example of an internal type. I think, _Vector_val is the one that comes to mind. Like _Vector_val. OK. Naming. We conventionally use _Ugly_snake_case for types and functions in the STL (like _Vector_val). _UglyCamelCase used for template parameters (like _RanIt). OK, so we've got a struct _AsanAlignedPointers. It's internal so I'm mentally checking against modules. No modules impact. That's good that none of this PR should be affecting public names, so we shouldn't expect to see any changes to export. It has a couple `const void*`s, _First and _End. They are not initialized to anything, so this is an aggregate, there's no constructors. How do we use this? Do we use it in this header or no? It looks like we use that elsewhere. Let me look at some uses so I get an idea of how it's used. There's a very big explaining comment. Uh, there's one use. Oh, there's a function that returns it. _Get_asan_aligned_first_end in <xmemory>. OK, returns it with braces. OK. It seems fine this in aggregate. I don't see a need for nonstatic data member initializers because we never use them. If we said initialize them to nullptr, that would just be dead code. It wouldn't be wrong, but there's no strong motivation, it's internal only. If this was intended for wider use, I think it might be nice to have NSDMIs, but mixing, like, non-null and null would be bad too. So sort of better to just not have anything there. OK, then we have a helper function or a function. Um, this is a pure observer? So it should definitely be [[nodiscard]]. It is constexpr returns a const void*. It's called _Clamp_to_end. Takes const void* _Mid. It's const, it's noexcept, that looks good. We have an _STL_ASSERT that activates only in debug mode. That the _Mid being passed in must be greater than equal to _First. Um. Why is there an empty string here? Does _STL_ASSERT even take a…? Yeah, it takes a string. We should have a message here. Yeah. At least a minimal one. Yeah,

>> Nicole: it's a debug function or. Sorry, no, it's an internal function like, Does it really need it? [unintelligible]

>> Stephan: Um, the, actually, the question that comes to mind is, we usually use _STL_ASSERT and its uh companion _STL_VERIFY, when user submitted arguments could violate preconditions of the standard. If it's something that we expect users to never activate through their own misadventures, but would only happen if the library code has logic errors, then we usually use an STL-internal assert which is only active for our code base. We I know we have one for static_assert &gt> Nicole: Do we have one? Yeah. >&gt Stephan: I thought we had one It's always _STL_INTERNAL… It looks like _STL_INTERNAL_CHECK is the name um for the runtime, one. Yeah.

>> Nicole: Oh that's why I couldn't find it. >&gt Stephan: It's like STL_INTERNAL…-something-other. We got a lot of uses of it. Um. Yeah, I think that's what this should be. No, hold on. What is? What's going on here? Ohh we use _ENABLE_STL_INTERNAL_CHECK to activate The _STL_INTERNAL_STATIC_ASSERT but where do we use it? Oh yvals.h uses it to activate OK becomes an _STL_VERIFY. OK, so external check will always run this, but only in the test harness. There's no reason for _STL_ASSERT. OK, I will add a comment saying that that's what we want and that one I believe, does not take a message. It does not take a message, OK. Um. If this is checking for logic errors in the library implementation (such that user code passing, say, or can't. Er… such that user code violating preconditions. No let's not get into that. Umm. This is checking for logic errors in the library implementation, we should use _STL_INTERNAL_CHECK which doesn't take a message. OK. This is checking for logic errors in library implementation, we should use _STL_INTERNAL_CHECK (which doesn't take a message). Umm, excuse me. OK. And then this is doing the clamping. If the provided _Mid pointer is strictly greater than our stored _End pointer, then clamp to _End. Otherwise it is less than or equal to _End. And. We are… We've already asserted that it's got to be at least _First, maybe bigger, so we can just return _Mid. OK. That seems reasonable. OK, so now the big comment. Um, here we go. Uh, the way that ASan shadow memory works. Each eight byte block of memory (shadow memory section) has a single byte to mark it as either poison or valid. Each section has zero to 8 valid bytes followed by poison bytes, so. And then here's some examples for how many bytes there are. Three valid, followed by 5 poison. Or. 8 valid are OK, but poisons followed by valid is not OK, that makes sense. This function, which is being defined way below, exists to fix up first and end pointers so that one can call __sanitizer_annotate_contiguous_container and __sanitizer_annotate_contiguous_container checks that `first` is aligned to an 8 byte boundary if `end` is not aligned to an 8 byte. __sanitizer_annotate_contiguous_container still poisons the remaining bytes in the shadow memory section. OK, so we're going to check that the first one snaps to 8 bytes and if `end` is jagged. If it doesn't align to an 8 byte boundary, we're still at least going to poison the remaining bytes, OK. Because of the second property, we can only mark poison up to the final aligned address before the true last. OK, otherwise we'd poison the memory after last as well, and that doesn't belong to us. OK. OK, I think I understand what's going on here. For the first property we can assume that everything before `first` in the shadow memory section is valid, since otherwise we couldn't mark first valid and so we just return back the first address in `first`. Shadow memory section OK, and I very much like that every mention of `first` in its meaning of parameter is escaped by backtick, so we can use the plain word first without confusion. OK, so here's an example. cpp code. Uh, you've got a struct with alignment of eight cat, which has an int meow spanning bytes 0 through 4. OK, non inclusive we have a char buffer[16] with no alignment requirement and that extends through bytes 4 up through 20 not inclusive and then an int purr occupying the end bytes 20 through 24 not inclusive. OK that looks good. It is aligned as 8; 24 is divisible by 8. OK, as an aside, we have an undocumented compiler option /d1reportSingleClassLayout which is quite useful to view this. I'm going to take a little detour and show this on Compiler Explorer. Can't remember if I've mentioned it before in code reviews, but if this is ever necessary. Uh, let's use MSVC. We want um. Compiler output. OK, so x64 MSVC, latest. OK, so if we compile with /d1reportSingleClassLayout and then this takes a substring of the classes you want to look at. This one is cat, so I'm going to say lowercase cat here. It prints out an ASCII art diagram here. It's picked up a couple of other things like. atl::implements_categoryAttribute, which is like predefined or something, but here we get class cat. It's a 24 byte class and it begins. It offsets 04 and 20 from your buffer and per just like Nicole's comments demonstrate, and no padding. So if you're ever confused or uncertain about the layout of a class, try using /d1ReportSingleClassLayout and then name of class. It's undocumented and unsupported, but we've supported well, we've implemented it for many years and it's probably not going away anytime soon. OK, so first meow and purr are just regular data members, not container buffers, so they must be valid. OK, then assume we want to poison all of buffer. This would mean that in a perfect world, we want something like… OK, here's a very nice diagram. Um, with bars showing where bytes begin and end, and the bars begin on these spaces. Very nice. OK, so meow is all valid the buffer? OK, these SMs are the shadow memory segments because ASan thinks about things in eight byte granularity. OK, so the entire buffer is poisoned. OK, and then however note that by the rules above sm3 the shadow memory is not a valid shadow memory section. We always need the valid bytes to come before the poison bytes. Thus, the closest we can actually get to it is… I see the cat noises have attracted well, Hi Kitty. Now we can mark all of SM3 as valid. OK, so we're sort of losing out on some checking, but this is unavoidable where dereferencing near the end of the buffer has to be accepted because it's so close to the valid memory purr. This example is extremely enlightening! Thank you for writing this up! This was obviously a ton of effort to draft, but the pictures demonstrate the complicated concepts here much better than the words can. OK, very useful. >&gt Nicole: There was an incredible amount of trial and error that went into figuring this out by the way. This is all not documented unfortunately. >&gt Stephan: Yeah, and yeah, the result is oh, just crashes with some horrible, you know, inexplicable reason rather than a nice compiler error or anything so. OK, so we call aligned = _Get_asan_aligned_first_end with cat.buffer, cat.buffer + 16, and we get back aligned with members _First is address of cat.meow. OK, that's a plain pointer, not any sort of pointer to data member, and _End is the cat.buffer + 12, which is here. OK. Um. Then we poison as much of buffer as we can via __sanitizer_annotate_contiguous_container( aligned._First, aligned._End, OK, uh, cat.buffer here, and then aligned._Clamp_to_end( cat.buffer + 16)) OK. So the… OK that… that finds this boundary. Here we are allowed to assume that &cat.meow is valid since otherwise cat.buffer plus anywhere between zero and four could not be valid. We cannot poison up to cat.buffer + 16 since then the &purr could not be valid. Thus, this results in the shadow memory state from the second example. OK. And, that would be this example here. Yeah, because this is clearly not the first example. OK, this comment makes sense. Thank you. OK, so now we've got plain inline function, so it is _NODISCARD because it's only returning stuff. It's got to be inline because it's not a template. We return an _AsanAlignedPointer struct, _Get_asan_aligned_first_end. Because it returns a _First and an _End. Those are the names of the members. We take _First which is a const pointer to const void. Same with _Last. It's noexcept OK, We have a… constexpr uintptr_t; `static` here is not necessary but not wrong, so that's fine. static constexpr uintptr_t _Mask is take the _Asan_granularity. Which is a power 2 minus 1, flip the bits so it turns off all the bits. For the power of two, OK, and that's why we can mask it. We reinterpret _First and _Last to uintptr_t, apply the mask, and then go back to const void*. OK, that's great. Amy, who is the tech lead on ASan, says: "for the _Last pointer, I think this goes back to the beginning of the current longest of advancing to the beginning of the next chunk?" "Correct. We can't advance the beginning of next chunk; see the example in the comment". OK, so we're only ever stepping things back, because of the nature of the mask. OK, good, that's going to result in nice codegen. Then we have a couple of variable templates. This code goes down to C++14, so we need the _INLINE_VAR macro. We are… partially specializing, but not explicitly specializing. So that's good. We've got this headache where if we ever explicitly specialize a variable template, that's actually bogus without actual inline variables, but partial specializations are OK. So template<class _Container, class = void>, because we're going to do void_t SFINAE. _INLINE_VAR constexpr size_t _Container_allocation_minimum_alignment is… so by default we get the alignof the element type, the typename _Container::value_type OK, but if something is valid. If we can form a smash to void_t, the decltype of the _Container::allocator_type::_Minimum_allocation_alignment. So if you have…, if the allocator has this value, this thing does not need typename anywhere, because we eventually end a new value. Then we call std::max, and here we're in <xmemory>, so we have that available wrapped in parentheses to defend against macros. Um, and what are we taking the maximum of? Either the thing that we would usually use, alignof(typename _Container::value_type). But if that's tiny, like if it's just a char or something, then we're guaranteed that the allocator will at least be returning stuff aligned to 8 byte or 16 byte or whatever boundary it says. But if the element type has a huge alignment requirement, well, of course then that is the alignment requirement we're going to use. So, maximum is correct. OK, that looks good. That's all the changes to <xmemory>. OK. See. So now we've got changes to <string> and <vector> and then the test. OK, let's see. Got a little bit of time. Let me go through <vector>. OK, so we're now going to include the support header with angle brackets. Uh, we're going to do that. Within the compiler processor guard, but it's not conditional on language mode and it's outside our push pack. This is the right location. OK, so then we're lifting out all this, uh, duplicated slash unified code. Yep, so this is activating the stuff, the #pragma comment(lib …), the declarations, the alternate names. This is great. This was detecting the minimum allocation alignment. We've just reviewed this. Um, this has been generalized too. Previously it took a vector and asked what its value type is. And now the stuff that's in the <xmemory> um, works with arbitrary containers, not specifically _Vec, and it's doing std::max. This is… This is returning a bool: "Do you have a minimum allocation alignment?" The other one just returned what the minimum allocation alignment was. OK. And then the detect_mismatch. OK, _Get_aligned_first This is being removed. Looks like some of the masking work is being moved to that helper function, so we're going to see something that. Replaces this, but it's not just a code extraction. OK, so here we go.

>> Nicole: So that thing right there was wrong. Basically, If you have a pointer pointing at first. Uh. This is like up in memory towards end and this is back in memory towards begin. It would push the pointer forward. So that you couldn't poison like, let's say, the first four bytes of the buffer. But it turns out. That's not true. We can just push the pointer backwards, because we know that this must be valid in order for this to ever possibly be valid, and so we can actually poison the 1st 4 bytes of the buffer.

>> Stephan: OK. Through the masking.

>> Nicole: Yeah, that _Get_aligned_first_end I think is what it's called. Uh does that? That's the correct masking, so this is the OK. And. Pretty complex.

>> Stephan: OK, so this is actually a correctness fix. OK, that's good. OK, so goodbye, _Get_aligned_first. Um, now we are _Unfancy'ing pointers because we support fancy pointers, which are things that we obtained from an allocator that look like pointers but are actually user defined classes or something. So whenever you see _Unfancy or _Refancy, that's what we're dealing with. So we are taking… Are we doing here… applying annotation which works with fancy pointers in a vector. We have to _Unfancy them all to raw pointers, they're just losing their trailing underscores. They're all double const. OK, and then uh, extra parentheses here to make clang format do the right thing. If constexpr the _Container_allocation_minimum alignment for our vector is strictly greater than _Asan_granularity then… We can call __sanitizer_annotate_contiguous_container without adjustments. Otherwise we need to adjust. OK and here.

>> Nicole: That should be greater than or equal.

>> Stephan: Ohh greater than or equal. OK. Looks like this comment doesn't mention that, so I will add that. Let's see. As you mentioned that this should be a greater equal check. OK, great. Thank you. I didn't. I actually wasn't. Even though I'm a fan of uh checking for uh strict versus um except equal, I didn't think to question it there, so I'm glad you did. So if the allocation minimum alignment is greater than or equal to _Asan_granularity, then this adjustment is not necessary. OK, um, there's some comment here about. Possibly removing an optimization because it's making things more complex. I'll let you decide whether that's necessary. OK, so the old state,

>> Nicole: This is actually not an optimization. That's what I meant to say, 'cus when you know about the allocator. We can push it forward. We can push the end pointer forward, instead of back. So this is actually fixed in my local branch and I apparently forgot to push before I left for home. So OK. Sorry.

>> Stephan: OK, let's uh, let's see if I'm catching this correctly. OK, how does this sound? And Nicole mentioned that this is needed for correctness and is not purely an optimization. OK. Okay, old state: include _First exclude _Old_last is valid, and then from _Old_last excluding _End is poison. New state: _First to _New_last is valid and then _New_last to _end, so there simply _Old_last was the boundary between valid and poison. We're moving that to wherever _New_last is, so _CSTD qualified, which just means global scope __sanitizer_annotate_contiguous_container( _First, _End, _Old_last, _New_last) OK. Otherwise, so, call the new thing um const auto _Aligned is _STD _Get_asan_aligned_first_end give it _First and _End. If the struct that we're given says if _Aligned._First is equal to _Aligned._End, well then there's nothing the buffer does not end… The buffer does not end at least one shadow memory section. Nothing to do. Am I misparsing this? What does end mean here? Does it mean contain?

>> Nicole: No. Basically, in order to mark part of a shadow memory section as poison, we need to know that we own the final byte in that shadow memory section.

>> Stephan: OK, so for like, if you're purely within a shadow memory section, you don't contain the end of one of them. OK, so that's what this means. >&gt Nicole: Right, so, yeah, so we can actually be in the middle to another middle, and we can poison at least like the first 4 bytes. Right.

>> Stephan: Yeah. But you can't be purely within a shadow memory. OK. I think that makes sense >&gt Nicole: I need to go get the charger for my phone. >&gt Stephan: OK [laugh], um, then early return. _Old_fixed and _New_fixed, _Clamp_to_end, _Old_last, and _New_last. OK, so now some comments of the old state and new state and these are all inclusive-exclusive. They're all properly uglified, OK. Ah, that makes sense. _Old_fixed, _Old_fixed and _Aligned._End were the old boundaries and now _New_fixed and _Aligned._End. OK. So we're just moving _Old_fixed to _New_fixed, OK. Call __sanitizer_annotate_contiguous_container OK, more discussion here. Clamped end handling the concern. OK. It looks like this is resolved. That's good. OK, that's all the changes to <vector>! OK, I think I've worked at my confidence and I can now review <string>. OK. <string> includes the support header not guarded by compiler version or standard version. OK, that's in the right place. We are extracting out the string annotations and we are now activating them, so we'll need to go resolve this bug, which is great. OK. Extract out the allocation stuff, OK. Now #ifdef _INSERT_STRING_ANNOTATION, we have a helper function. We look like we're within a class here indeed we are within within basic_string itself. Yeah, this looks like basic_string itself. OK, um, so and are we in? We're in the private section. OK, #ifdef because this is a defined or not macro _INSERT_STRING_ANNOTATION, then we're going to have a helper function here. This is a function so we can get the alignment of the class while defining it. Because of the fun fact that a class is only complete within its member function definitions. If you're simply looking at like variables, like static data members, then it's not actually complete yet. It would be circularity if you try to check the alignment and size of the class. So it actually has to be a function. So that makes sense. Um, that's subtle enough that it is worth a comment. I like that. So we have _NODISCARD because it's a pure observer. This is a static contexpr bool _Small_string_always_asan_aligned. Can't be const because you're static. It's no except OK, so the small string is always ASan aligned. When a bunch of conditions are true, the align of ourselves, basic_string must be strictly… Sorry, must be greater than or equal to _Asan_granularity. So this check is good. And the _Memcpy_val_offset modulo the _Asan_granularity must be zero. OK, so our boundaries at the right place. And… Uh, let's see… This whole condition must be true, the sizeof value_type of _BUF_SIZE. Oh, this is an array. I was like index into a value type. No. This is the size of an array of, um, _BUF_SIZE elements of value_type. OK. Which I guess could have been expressed as sizeof(value_type) * _BUF_SIZE because we don't expect any padding. But that seems reasonable. So the size of essentially our small string buffer modulo _Asan_granularity. Must be 0, so you've got to be evenly divisible. Um. Or if it's not um? Then. If they align of this size_type… The align of our size_type… Ohh this is looking at the x86 or x64.

>> Nicole: Basically the reason for all of this is because I am trying to check one whether it's always aligned to the like the beginning of the buffer is always aligned on the boundary. That's true. The first two things are true. The second thing is checking if size doesn't get put in the shadow memory section of the buffer. So having in between If the buffer and a shadow memory buffer, that's fine. Or if padding like pads the size, type out to the… the next shadow memory buffer shadow memory section, that's fine. Yeah, this is a. This is a lot. It is kind of terrible, but that that's basically the idea. Is is so that you don't poison size_type, You're _Mysize accidentally.

>> Stephan: OK, Umm, I'm going to add a comment here. Um. If it would be possible to add additional comments, um, explaining what you just explained, that would be helpful, because there are a lot of conditions here and the intention of them is less than completely obvious. So comments explaining what is the meaning of this, the meaning of each sub-condition here would be very helpful. OK, great. OK, so now _Modify_annotation is changing signature. Uh, _CONSTEXPR20 cause string and vector have to be constexpr in C++20 mode. But now instead of just taking a count, we take a const size_type _Old_size, const size_type _New_size, const noexcept. OK, Umm, this no longer just says "Extends/ shrinks the annotator range by count". You have, You have to explicitly tell it what we're… what was the old size and the new size. That's nice. That avoids confusion. If they were the same, "hey, nothing to do, return". Otherwise they're different. We gotta do stuff. So _Apply_annotation( _My_data._Myptr(), _My_data._Myres, _Old_size, _New_size). OK, simple as can be. Um, and then. We now have a new function. _CONSTEXPR20 static void _Remove_sso_annotation (const _Scary_val& _My_data) noexcept. OK. This thing is um, I think we mentioned in other code reviews, but uh, basic_string and vector and all the other containers have base classes to help limit the impact of their allocator. So allocator, iterator or iterators for containers only depend on important attributes of the container, and not on different allocator types. Um, so, removes annotation of this small string optimization buffer with shadow memory. This results in the ability to copy into the SSO buffer without worrying. OK #if _HAS_CXX20 / #endif _HAS_CXX20, OK, so if we are constant evaluated, which we do with our runtime check runtime, then return. Because we're not going to do any ASan stuff, of course. in, um, constexpr land. OK. Um. Otherwise we're either not 20 mode so we don't have to worry about constexpr string, or um, we are in 20 but we've determined we're at runtime. OK, so we can proceed. So we have a couple const void* const _My_buf = _My_data._Bx._Buf; _End = … _Buf + _BUF_SIZE, ok? Repeating them has no cost and aligning them nicely, so that's fine. if constexpr( _Small_string_always_asan_aligned()). Then nice before after comments, old state, new state, from _My_buf to _End is unknown and now _My_buf to _End is valid. _My_buf, _End, _My_buf, _End, OK. Otherwise const auto _Aligned = _Get_asan_aligned_first_end. OK. The old state we had valid some unknown stuff in the middle and then valid again, and now everything's going to be valid because… What's going on here? We are removing the SSO annotation. The small string isn't always ASan aligned, so we want to just remove that annotation to say: "hey, everybody's valid", OK. OK, that looks good. Another function _CONSTEXPR20 static void _Annotate_switch_to_large, (_Scary_val& _My_data) noexcept. annotates exactly the pointers as valid because we're switching to large mode. And we're going to be storing a pointer in that union. Again, if we're in CXX20 mode, if we're constant evaluated, early return. Remove any SSO annotation. And then capture _My_buf, _Ptr_last is… OK, this is a repeating. Oh no, this is not repeating. This says _My_buf is _Bx._Buf _Ptr_last is _Bx._Ptr + 1. And then _End is using _My_buf + _BUF_SIZE. Uh, that's… that's correct. Um, I'm wondering if it makes sense to group _My_buf/_End just so that puts the bufs together and then the _Ptr one is separate. It's probably not strictly necessary. >&gt Nicole: The idea is that, _My_buf comes before _Ptr_last comes before _End OK. The locations? >&gt Stephan: Ah, OK. And this is doing pointer arithmetic. It's not plus one byte, it's plus one pointer worth, OK. if constexpr _Small_string_always_asan_aligned, then the old state _My_buf to _End is valid from _Remove_sso_annotation which we just called, new state from _My_buf to _Ptr_last is valid, but from _Ptr_last to _End is poison. OK, otherwise const auto _Aligned = _Get_asan_aligned_first_end The old state again. _Aligned._First, which we just got here and, is valid for _Remove_sso_annotation, and then we're going to mark the middle as poison. OK, because we are switching to large, so the buffer in general is poison. Um. OK, but the pointer, of course is fine. OK. _Aligned._First, _Aligned._End, _Aligned._End, _Ptr_last. Yeah. [unintelligible]. Kind of think um. This is an extra pointer. Does this make sense? I'm worrying about exactly where this boundary is because I'm wondering, is there a distinction between arithmetic in the byte domain and arithmetic in the pointer domain um. I think I may need a, to look at. Whoops, where's string itself? I want to go to <xstring>. OK, so we've got a _Buf, I think _Bx. No, we don't say union that often. OK, there's one occurence union here we go, um, so we've got the array of _BUF_SIZE `value_type`s. For a narrow string, this is 16 narrow chars. Followed by a pointer. And then followed by this alias thing that, um, it's a union of all these things, and this one we can basically ignore. So it's a union of them both. Interesting. And then we've got the _Mysize and Myres after that, OK. So want to split this. Here and here OK. OK, so we've got. _My_buf is the beginning of the string. Because that the _Bxty union is the first element um _Ptr_last is the address of. The _Ptr which is also the beginning of the string. Plus one so. OK, so _Ptr_last points to the byte immediately after the pointer. So if a pointer is 8 bytes, this will the pointer exists in the 1st 8 bytes, 0 through 7 index and then blah plus one is pointing to the 8th byte, the byte at index 8, the 9th Byte actually. OK. So and then _End is _Bx._Buf + _BUF_SIZE which is the end of _Bxty or an end of _Bx OK. OK, so _Ptr_last does indeed point right beyond the _Ptr. It doesn't point at the end of the second pointer, and there is no second pointer, it points at. The end of that reach. OK, so _Ptr_last. That is the right name for it too, because it's exclusive. OK, so. Did this make I think I'm convincing myself this is correct. New state _Aligned._First, up to _Ptr_last is valid but excluding it. OK, so this is saying. The ptr is valid. Everything from _Ptr_last to _Aligned._End is poison. So the part of the union that we're not using is poison. OK, this is correct. I was worried that we're like consuming 2 pointers worth, but we're only consuming one. That's all good. I had to mentally create the diagram in my head. OK, we're now done with _Annotate_switch_to_large. _Apply_annotation. Parameter used to be called _Ptr, now it's called _First and gains top level const. Uh. This code goes away. We have new code here. This is not helping things GitHub. I want to switch to side by side. What I really want is the thing that we have in our internal review tool, where I can switch entirely to new code but see only what's changed. Rather than just looking at the file as a whole, I dislike split mode, but I'll use it if I need to. OK, too far down, here we go. We just finished _Annotate_switch_to_large. OK, _Apply_annotation comes first. OK, so old code goes away. Now we have: Note that capacity, _Old_size and _New_size do not include the null terminator. So const void* const _End = _First + _Capacity + 1; OK. _Old_last = _First + _Old_size + 1; These are… what are these `value_type`s? Why are they plus one? Oh, because of the the null terminator. The null terminator is a factor for the size. So I could imagine that, but why would we be doing this for capacity here?

>> Nicole: Because our capacity is. Our actual capacity minus one.

>> Stephan: Ah, OK, that's why I forgot. [unintelligible] Done. Yeah, yeah. It's an old representation choice before my time, so. OK. Thanks for mentioning that. OK, so that's all correct. Yeah. So whenever I see a null terminator, I'm like: "whoa, sirens, you know, something could be wrong here", um. constexpr bool _Large_string_asan_always_aligned

>> Nicole: Oh yeah, is null spelled wrong there?

>> Stephan: oh yeah, n-u-l-l, so n-u-l is the ASCII name for the null character. But if you spell it out as a word, it's reasonable spelled out like this. The thing that would be wrong, Would be all capital NULL, because that's the macro for the null pointer constant. Null terminator like this I think, is conventional. I don't think that's wrong. I… I… I guess you could have, um, different stylistic convention, I suppose. Um, the the one I'm allergic to is referring to a null terminator is all capital NULL, which it's not. OK, uh, _Large_string_asan_always_aligned. It's constexpr bool when the _Container_allocation_minimum_alignment for our basic_string is greater than or equal to _Asan_granularity. OK, if constexpr _Large_string_asan_always_aligned and _Small_string_always_asan_aligned, then "hey, the stars have aligned!" old state: _First valid ends at _Old_last and then the rest is poison. We're moving that to _New_last. OK, good. _First, _End, _Old_last _New_last, otherwise, OK, this is just getting indented. Why is this not? No, it's not getting it. It's getting significantly changed. It's just not doing interline differing. OK, otherwise const auto _Aligned is _STD _Get_asan_aligned_first_end(_First, _End). the buffer must always have size greater than or equal to 9 bytes, so we'll always end at least one shadow memory section. OK, so you have that guarantee that we talked about. Last must be less than or equal to, than _End. So fix up when _Aligned._End is strictly less than _*_Last OK um. _Old_fixed._Clamp_to_end, _Old_last, _New_fixed._Clamp_to_end, _New_last, OK. Old state. Here these are actually contiguous lines, just the narrow screen is messing things up. The valid boundary was at _Old_fixed _Aligned._End poison, new state. These old state / new states are very nice to explain what the intention is. Um. OK, that's good. Now we have some helper macros. Everything after this is a lot easier and once all the support machinery is defined and I think we can actually go back to intra diffing. Reload. OK, scroll, scroll, scroll. OK, the macro helper macros. No more _ASAN_STRING_MODIFY is taking one arg. Now we take 3 args, _Str, _Old_size, _New_size. Calls (_Str)._Modify_annotation (_Old_size, _New_size) We now have other macro …_SWITCH_TO_LARGE Which will take our _Scary_val base class call _Annotate_switch_to_large, or _Remove_sso_annotation, OK. These match the names that seems reasonable. Otherwise expands to nothing. We still have remove and create, but none of this modify or the single arg modify. OK. So Um. Is this merge damage? This looks like… this is a change that Casey recently made, I thought.

>> Nicole: Yeah, that must be merge damage.

>> Stephan: OK, I'll add a comment. I think a merge was incorrectly resolved here. Um, I also, I'm not sure if you've merged with main. Um. Please double check that you have merged with main and picked up… Let's annotate for the records what PR we're talking about. This was like a whole seven days ago, so I've completely forgotten. That's not actually useful. Let me look at <xstring> My memory is sort of timeless. I'm like, oh, we changed something there. And it could be, you know, 12 years ago, it could be seven days ago, and I'll remember it the same, but I don't remember exactly what changed. OK, So what is the history? Ah, it was Casey's miscellaneous cleanups. We… we created PRs almost simultaneously. Mine was various cleanups. His was miscellaneous cleanups and finding some good stuff to clean up, but small enough that it didn't make sense to accept for PRs. Yeah, so here Casey said: "OK, we're going to take _Al, we're going to use to construct the allocator in our compressed pair, but then we don't need to redundantly provide it to _Move_construct_from_substr". That one can just use our allocator. We have a whole function for that, so this function doesn't take _Al at all. So if you've merged with main, that should not be showing up as an edit. Um, yeah, something's gone wrong. Interesting with the merge there. As an aside, I can. Uh, use this opportunity to mention a tool which I really like and I think I've mentioned another code reviews. I know you're aware, but for our audience. If you're looking at our repo, or any repo if you've got git installed, you can use gitk and that will launch… Let me drag it over here… A graphical viewer of history, and this lets you to see what branch you're on, um, what commits you're looking at. Our main branch always has completely linear history, but it's possible to see merges and stuff. And there's other ways to get this info. There's other graphical viewers. You can do this on the command line with some graph arguments, but I like gitk and it can be helpful to understand what you've merged recently. OK. So we want to pick up 3178, um. OK. Double check that, sorry citation it is. OK, straight damage. Um, let's see what's going on here. So we're moving the assignment of count down, that's fine. And then _ASAN_STRING_CREATE with this. OK. I don't know if it's necessary to move the _Mysize down. Was there a rationale for moving this assignment? >&gt Nicole: So everywhere else, we have, I think everywhere else we have _Myres assigned first, _Count assigned second, _Mysize assigned second, _ASAN_STRING_CREATE third.

>> Stephan: Ah, so that that's what that the idea was, then. OK, big fan of following um, uh conventions within a single file, so thanks. And then we're moving up the _ASAN_STRING_CREATE before we start actually assigning to the stuff. That seems entirely reasonable. OK. Um, here. What are we doing? Are we still within the same function? Nope. We're in _Construct_from_iter. So _ASAN_STRING_REMOVE(*this), remove any special annotations. Switch to large. Miscco, who worked extensively on string, says: "something's fishy here. At the end of the function, we call _ASAN_STRING_CREATE…" Nicole's reply, _ASAN_STRING_SWITCH_TO_LARGE creates a valid region inside the SSO buffer for the pointer because we're switching to large mode, and then _ASAN_STRING_CREATE creates a valid ASan region in the large buffer. OK. Yeah, trying to communicate complicated concepts and like 3 and one words is difficult but, and this seems reasonable. Um. I wonder, I wonder if comments like we've generally moved away from redundant comments and functions, but maybe explaining this in the actual functions would be useful. Did we have that? Umm. Where? Where are they? This is a plain annotation. Switch to large annotates exactly the pointer is valid. OK, that summarizes what you said. Then what was the other one create? We'll just create call macro. Sorry for scrolling. Create calls the existing create annotation, OK, I think, I think we've already got comments there. So this doesn't demand an extra comment. OK. And then changing the arguments because modify is no longer taking a delta of size. You take the _Left_size, _New_size, or you pass the _Left_size and _New_size. OK, let's make sure all these are actually correct. Interesting that _Right_size was asked as a delta before, it's always because we're concatenating. Yeah, we're concatenating. OK, got it. I was also checking to see if some variables had become no longer necessary, but of course we're going to still need the _Right_size. Um. OK. So we are concatenating it _Fits_in_left take _Left's buffer. So old was left, new was new size. If. And here I'm assuming we're fitting _Fits_in_right. Yeah, _Fits_in_right. You have allocators equal in _Fits_in_right. Then we're starting with _Right_size and becoming _New_size.

>> Nicole: And I need to go so OK, thanks for the review. Awesome. Thank you, Nicole. And I should probably um finish up uh myself because we are at 5:26. It looks like the rest of the changes here to string are pretty minimal. So I will go ahead and submit partial comments. I'll come back and our review the test code later, but I'll capture these comments here. This is looking very solid. So thank you for working on this extremely difficult problem and enabling. String ASan annotations which will be a great feature. Bye, Nicole, and thank you for watching another VC libraries Open code review. We'll see you next time.