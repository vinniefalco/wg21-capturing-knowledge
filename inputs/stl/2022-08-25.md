>> Stephan: Hi and welcome back to another VC libraries open code review. Today we'll be looking at the STL's favoritest attribute in the whole world, [[nodiscard]]. We have a PR, umm, from our contributor Alex Guteniev, #2211. [[nodiscard]] messages. So we've been looking at this, umm, which addresses a couple of, uh, enhancement issues that we had filed a while ago. Umm, but first I wanted to give some background on what is this attribute, what does the STL use it for, and what do we want to do in this PR? Umm, so if you haven't heard of [[nodiscard]] or attributes in general, umm they're a way to mark things like functions or data members, but in this case it's applicable to functions. Umm, in ways that, don't necessarily carry required semantic meaning for the compiler, meaning that in theory the attribute should be ignorable and you should still get the same behavior you would otherwise. But sometimes it can help the compiler emit better codegen, it can help the compiler emit better diagnostics, things like that. This rule isn't strictly followed by the standard, there's things like [[no_unique_address]] that do have a bit more of an effect than others. [[nodiscard]] is very much a classic attribute where you could ignore every single [[nodiscard]] in the program. And aside from compiler warnings, it should have no effect. But the effect that it does have is quite useful. So I can open up. Let me open up the STL here locally and if I do a search, a global search for every occurrence of _NODISCARD, we use a macro in our product code that is internal to us. It should not be used by users. Discard if I can type correctly. Here we go. There are 5541 occurrences of this _NODISCARD annotation. In the STL. We use this everywhere, and in fact we use it much more than suggested by the standard. All of this is quality of implementation. Implementations of the STL are not required to use [[nodiscard]], but we love it so much we've put 3000, 4000, 5000 in counting occurrences. So why do we do this? Why is it so important to not discard the results of function? So some I've seen when talking to people reactions, to [[nodiscard]] are sort of split. Some people are like, you know, as soon as they see it, they're like, oh cool, I should go use this. And other people are very skeptical, and it's reasonable to be skeptical of a new technology, especially if it increases verbosity. If you've got a function like say [[nodiscard]] int square(int), and that returns a couple N's here, I can print out the use of square. And it should print. There we go once I get the syntax right. Yeah, so that works fine. So what [[nodiscard]] does is it diagnoses incorrect uses like this where you call a function, it drops the return value on the floor, which is valid, but here the compiler will warn because we marked it as [[nodiscard]] warning C4834 discarding return value function with [[nodiscard]] attribute. Which is a reminder to the programmer that hey, did you mean to do something with square 5? Here this function is an example of what we call a pure observer. It exists only to take some arguments, compute some stuff and return it. So if you drop the return value on the floor, why did you call the function in the first place that had no side effects? So this is the most common reason we mark things as [[nodiscard]] in the STL. So one of the reasons why we can use over 5000 occurrences is that as long as your programs operating properly, you know you're actually using all the return thing/return values that we've marked, You get no warnings. Um, as long as we're very careful to apply [[nodiscard]] only when we're highly confident that warnings will indicate actual bugs or, you know, actual forgotten code, then we avoid the false positives. Because users hate false positive warnings. They're noisy, they cause people to just turn off the warning with a warning disable switch, that would significantly degrade the utility of the feature. So with [[nodiscard]], we try to strictly apply it to cases where we're highly confident that it's going to find actual problems, and only in a couple of places have we been a little bit too overeager with [[nodiscard]], and we've have had to pull it back. It does mean that there are some cases like unique_ptr::release(), where 90% of discards are a bug but 10% are maybe valid and because that 10% that we don't want to emit noise, we don't mark the thing as [[nodiscard]] even though it would find bugs, the cost of false positives is too great. So maybe this is compelling. You know seeing this [[nodiscard]] saying oh wow you caught a bug but maybe you're thinking, OK, how often am I gonna just call a function, drop its value on the floor and I wanted it anyways. You know, how bad could that be? So let me present the most compelling reason that I've seen for [[nodiscard]]. It has found a few bugs in production code bases, so let's change this. Let's have a couple containers. Let's have the be 10, 20, 30. vector<int> v2 = {40, 50, 60}. Let's iterate over both of these containers simultaneously. So for auto i = v1.begin(), auto j = v2.begin(); the condition, as long as i != v1.end() comma j != v2.end(); and then we want to increment i, comma increment j and then we're going to say cout. We'd like to dereference the iterator. Nope, can't do that. *i. And then a comma. I see Casey and Nicole are smiling because they know it's coming. *j. And then maybe print a new line. OK, and let me warning disable 4834. So we pretend what happens if the STL does not have [[nodiscard]] warnings. What happens here? OK, so maybe I'll put a space here to make it pretty. So hey, this program compiled, it, ran, it, worked, everything's good, right? I mean, I got 10 and 40, 20 and 50, 30 and 60 printed. Well, there is a bug here. Let's see what the bug is by enabling the [[nodiscard]] warning as it is enabled by default. And I think, think, think. Why am I not getting the [[nodiscard]] warning? We're under latest, did the thing actually recompile for us? We totally should have gotten the warning here. Yeah. Sometimes I've seen Compiler Explorer doesn't always recompile. OK, now I have a mystery because this really, really should have emitted the [[nodiscard]] warning. Uh, let's see, we've got iterators. We are totally ohh. Ohh, I think I found a compiler limitation here. It's a good thing we've got a compiler dev on the call. OK, so this is interesting. Let me downgrade us to C++17 because I really want this example. Then we'll talk about what I think I just discovered. OK, everybody's learning something today, including me. So it's compiling under 17 mode. Here we go. OK, so this is the warning I expected to see. And then in a bit we'll get to why we didn't see the warning. So we get a squiggle on line 11, warning, discarding return value function with [[nodiscard]] attribute. Oh, that's interesting. I said i != v1.end(). comma, and I put that comma in there intentionally. j != v2.end(). This comma is wrong. The comma here is necessary because you got to define two variables here. The comma here is necessary; it's a comma operator. We're going to increment both i and j. Here you do not want a comma because if you put a comma there, we ignore the left hand side because we compare 2 iterators. We got a bool, then we drop it on the floor, and the result of this is only j. So what we really wanted was operator&&. This is a bug and the reason why I say this is my favorite example is we have seen like at least two or three occurrences in real production code bases. I will avoid naming names, where people ship this to users and the code was behaving incorrectly and in this case it misbehaves if the vectors are ever different lengths. You want this to end as soon as one of the two vectors is exhausted and not only when the second vector is exhausted. Um, so having a comma there is a real bug in this case, it seems seemed to work fine, but if I had let's see if I have too many elements, we would end as v2 ends, so it would seem to work fine. But if v1 does not have enough elements, the && will work properly where we stop as soon as we consume the final element 20 of v1. But the comma will give us undefined behavior, and it will be diagnosed in debug mode. Ohh yeah, we let's disable the [[nodiscard]] warning 4834 and if we compile in debug mode we'll get the debug assertion. Yeah, where you think you think. Yeah, it intentionally crashes because we get our debug check and in release mode we briefly saw you get undefined behavior. But in practice what we get here is garbage. So there's a real bug if you say comma and [[nodiscard]] catches it because it gets the library to communicate information to the compiler. The compiler just sees a function call here -- operator!=. For a vector<int> iterator, which is a class type, it's reasonable to call a function and then drop its value on the floor. That's what happens when you call printf, did you know the printf returns an int? Almost everybody ignores that int because it's not really useful. But here we really want this pure observer not equal to not be discarded, so [[nodiscard]] will find bugs. You want this enabled. We do enable it by default, and ideally point of this code review is to try to convince you to start marking your own functions as [[nodiscard]] when they meet the proper criteria. Yes, it's a little bit of verbosity, almost always it's not going to find anything, but when it finds something you're going to be really glad. Um, OK, so let's pop the stack here and let's go back to why we did not see this. Let's, I think C++ 20 will find the issue. So in C++20 we've got the comma here and it's not diagnosing, so I think this is actually a compiler bug. I'm going to need to report this after this video. Or perhaps one of the STL maintainers here can report the compiler bug as I talk. The issue here is that I am calling operator!=. In C++20 mode we got operator<=> and along with operator<=> we got a bunch of cool rules that says that a class only needs to provide operator==. Let me add some comments here. op==, and then if you provide operator<=>. Then the == will be used to generate, um, !=. Or really if you say != it gets rewritten, I should say rewritten. So usage of != is rewritten to ==, and with <=> any usage of <, >, <=, >= is rewritten to <=>. Umm the there's articles, uh, that will explain why == and <=> are treated differently. But the quick answer is that for some things equality can be answered faster than a full less than or greater than comparison. For example, if you have two vectors of different lengths, we can see instantly that they are non equal by just comparing their lengths. Whereas if you want to know is one less than the other, we actually have to look at every element because if one has the same elements as another and is simply a prefix or suffix, then we actually do need to compare all the elements until we exhaust one of them. So that's why they can't be fully fully unified all the time into just <=>. But we can always generate. Or we can always rewrite != and ==, and the STL now takes advantage of this in C++20 mode. I can actually dig up the relevant code. Let's go to vector. Here we go. Let's look at. Let's just search for occurrences of operator==. So in our internal implementation vector iterators we have something called _Vector_const_iterator and another one for modifiable iterators. We always provide an operator==. In C++20 mode, here's our internal macro to indicate that we also provide a <=>. In non-C++20 mode, we then need to provide !=, < >, <=, >=. But when we're in 20 mode, all we need is == and <=>, and the rest will be rewritten to one of these two. So, going back to why I was momentarily confused. Um, we have very carefully marked all of these things as [[nodiscard]] because calling any of these iterator comparisons is a pure observer, and if you drop that on the floor well you probably have a bug like I just showed. However, this has shown that if the compiler, if the user has written, me being the user, !=, and then the compiler says, oh, we're in C++20 mode, I'm going to rewrite that into == because I see that operator and this iterator class did not provide a != operator. When the compiler does that rewriting, it is not carrying along the [[nodiscard]]. We marked the actual operator that's being called as [[nodiscard]], but that bit is being lost when the rewrite happens. That should not be the case. For this rewrite, if the function that's ultimately called is [[nodiscard]], then the rewritten call should absolutely emit a [[nodiscard]] warning. So we should get a warning for that. I see a new bubble in the chat. Did we get something? Here we go. OK yeah there Casey and Nicole are asking who should report. Cameron, our compiler Dev, says can confirm I have a bucket of Casey bugs and Nicole reports that GCC exhibits the same bug but Clang does not. So we have some compiler variation, but hopefully in the future all compilers will properly carry over [[nodiscard]]s. So this is actually good to know. I did not realize that this was language mode sensitive until I wrote this example. So, Casey has one argument that it's not a bug, that !(x == y) doesn't discard the result of x == y, But it's really the compiler should because the compiler is doing the rewriting so it can see that the top level invocation is being discarded, and it really should. And then yeah, Cameron has an example whereâ€¦ Oh, interesting. So I wonder why why clang handles some of them? OK, so a little bit more investigation needed there. So that's the idea behind [[nodiscard]]. Now let me quickly explain what this PR is going to look at. [[nodiscard]] was added in C++17 and we are now using that. In fact, we use it even in C++14 mode because we have, Uh, it it's permitted as future technology where uh features from future standards are supported. And C++20 added [[nodiscard]] with a reason. So you can now put a string literal in [[nodiscard]]. Let's see what that looks like, with the compiler. Let me get rid of vector here. OK, so let me go back to this example [[nodiscard("pure observer")]] int square(int n) and return n * n. OK, so I cout << square(5) and everything is good. 20 mode, warnings enabled, it works, but if I call square(5) all by itself with the semicolon, what happens? OK, we get warning now. The numbers changed 4858. I think that is different than before discarding return value: pure observer. So whatever string literal you put in this [[nodiscard]] gets emitted. I guess I can try both. What if we don't have the reason? What if we were cubing something? And then we call cube(5). There we go. OK. Umm, OK, yeah, indeed they are different warning numbers and we can customize the message with [[nodiscard]] with the message. So we had filed an issue early on in the repo's history noting when this feature was voted in and one of the todos that we had in mind was maybe we could use this in the STL to provide a little bit more context to users. So as I mentioned, we have a few criteria which we've sort of mentally laid out and we've explained it like to the Standardization Committee a few times because the standard is now marking a few things as [[nodiscard]] which strongly suggests to implementers that they do that in their implementation, although it's not a binding requirement why you would want to mark things as [[nodiscard]]. So by far the most common reason is pure observers, things that do not have side effects or they have side effects in very rare and unusually pathological cases. So, comparisons, those are almost always [[nodiscard]]. Another example is like std::find(). std::find() takes a range of elements and a value, or find_if() takes a predicate and looks for the first occurrence of an element that's equal to the desired one, or satisfies the predicate and then returns an iterator to it, or the end iterator if it didn't find anything. That is a pure observer. And if you call a find and you drop the value of the iterator on the floor, you've probably done something wrong. So you're just spending cycles when you don't need to. It is true that either the comparison could have side effects because it could go log something, or go modify something, or especially the predicate form could go have side effects somewhere, even while it upholds the standard while it's conformant, as long as it returns consistent results for the same input, the standard actually doesn't care if that predicate has side effects, but it would be very unusual to call find only for the side effects of the predicates. It doesn't mean it never happens. In fact, I've seen the compiler do it once or twice. Um, but it's very unusual. So this is not the case where like 10% of calls are totally valid and 90% of calls are bugs, but we care about the 10% we want to avoid marking things as [[nodiscard]] in the case of like find 99.99% of invocations that are discarding that iterator are doing so incorrectly. And for that point you know 0.0001% that really do want those side effects, it's reasonable to ask those users to silence the warning in a targeted manner. So applying like /wd4834 or /wd4858 to silence these [[nodiscard]] warnings. That's a very large hammer. You don't want to use that because it shuts up every single [[nodiscard]] warning. Instead, if you see a [[nodiscard]] warning and you want to silence it, you can just cast the thing to void. This will tell the compiler, hey, you know I really did mean to call this thing and then just ignore what it does. Most of the time, in fact, almost all the time, this should not be necessary. But if you ever see a [[nodiscard]] warning that is validly marked and yet your usage is valid, put a void cast there. And if you don't like (void), you can also do static_cast if you really like this. Yes, most of the time this happens in a compiler and library test, because we're very interested in writing expressions that we verify compile, or don't crash the compiler, but we're not actually interested in what they do, so we just drop the value on the floor. So most of the time it's the actual library implementers that have to go add a bunch of void casts, and we have had to do this in a bunch of places, but in user code, unless you have similar sort of tests, this should almost never be necessary. OK, so I mentioned, Pure observer is the most common reason, but there are other reasons that you would want to mark something as [[nodiscard]]. So off the top of my head there are functions that are easily confused. So vector::empty() is the classic one where if you want to, if you want to get rid of all of, I'm trying to avoid the words here. If you want to get rid of all the elements in a vector, you might say v.empty(), because empty sounds like a verb. Unfortunately for the STL, empty is an adjective and it returns a bool, so if you call empty and you drop it on the floor, you've done nothing rather than wiping out all your elements. What you meant to say was v.clear(), so this confusion is so notorious that the standard itself has marked vector::empty() as [[nodiscard]]. I can actually bring that up if people are interested. Um, now, for us, that doesn't actually make a difference, because, um, vector::empty() also falls under the pure observer criterion, so we would mark it for that reason alone. But even if you didn't have, you know, the willingness to go mark 3000, 5000 functions in your STL as [[nodiscard]], the commonly confused case is a justification. Let me actually just bring this up so we can see what it looks like. Here's vector. Here's the class definition. I scroll down a bit. And I've scrolled too far. Here we go. empty() in the standard is depicted as [[nodiscard]], a nonbinding suggestion to implementers that they actually mark it. So pure observers are commonly confused functions. Other ones are cases where dropping the return value on the floor is likely to be incorrect, or a memory leak, or a resource leak. So allocate(), raw allocation functions. Those should totally be marked as [[nodiscard]] because you either need to store them in a resource management object, like a unique_ptr or something, or you need to manually ensure that you deallocate(), free(), release(), whatever the thing, and that you don't leak during exceptions. So at raw resource allocation functions, those should be marked [[nodiscard]]. And another more obscure case is where you're not going to leak resources, but if you discard the results, you're going to skip some important second follow-up step that would make your program incorrect. So that example there is like std::remove() and std::unique() Where those are so notoriously confusing, they had to be an item in Scott Meyers effective C++ books. Where the algorithm, um, sort of compacts the good elements that you want to retain at the beginning of the range, leaves the remaining elements in some garbage unspecified state, and then you need to follow that up with a call to container erase to actually physically make the container smaller and get rid of the garbage elements. So if you say, std::remove() or std::unique(), and then you drop the return value on the floor, you have a bug, even though it's not a pure observer because it's really modifying stuff, it's not allocating memory, um, it is skipping that second step that you need for correct program. So that's a case for [[nodiscard]]. So [[nodiscard]] with a reason is a way for the STL to communicate to users why you would want to do this. So that's what these issues we're talking about and that's what Alex Guteniev has gone and done. So this has PR been open for a while. We're now finally getting to review it. Apologies for the delay. Let's actually take a look at the code. OK, So what Alex is doing here is taking that macro which we mentioned, _NODISCARD, which is for the STL's internal use, and replacing selected occurrences with other macros. Because oftentimes the message that we want to give is repeated in a whole bunch of different places, like we got std::remove(), std::remove_if() ranges::remove(), ranges::remove_if(), they all have the same rationale so we can just use the same message for all of them and centralizing that in a macro is reasonable. In the future we might make the message itself a macro and otherwise use an attribute. The reason why we're using an attribute for [[nodiscard]] is partially for historical reasons that we added it when not all compilers supported it, that we may be able to change that now, especially since we like [[nodiscard]] so much and we have not had cases where users have had needed to activate the escape hatch. But for the time being, putting the whole attribute in a macro is what we do. So first I'd like to look at the macros, make sure that, um, all of them make sense. I'm gonna, I'm gonna skip reviewing the actual grammar of the messages for now. I'll come back and do that later, and then we'll see if they're being applied to all cases properly and if we're forgetting anything. And if I could make this highlight go away, that would be good. OK, there we go. So let's alt click and see what files are being modified. So although it looks like 257 lines are being modified, it's really just a scattering. This PR is not as large as it seems, and most of the lines are <yvals_core.h> because it's adding a bunch of messages. So let's see what messages are being added. OK, so um, here we go. <yvals_core.h> the STL central internal header, a transition comment because currently vcruntime is not open sourced. This should go to <vcruntime.h> agreed. So right now Alex is following the pattern. Ohh I see this was, this is essentially following the [[nodiscard]] ctor for constructors because that's a separate feature. So this looks right. OK, so transition this should go to <vcruntime.h>. #if the compiler does not support __has_cpp_attribute, then [[nodiscard]] message of a message expands to nothing. #elif __has_cpp_attribute(nodiscard] >= 201907L I believe this is the correct value but let's check. So if we search for sd-feature test this will bring up the standing document showing feature test macros. We're going to look for the __has_cpp_attribute(nodiscard). And let's find wee. We're gonna skip that. Here we go. So OK. The same value of July 2019 is used for two different papers. [[nodiscard]] should have a reason and [[nodiscard]] for constructors. So even though these are different things that we're testing, they have the same value. So 201907 is the correct thing. I love to double check this because copy paste errors with feature test macros are quite possible. So exact same value, that's good. So if we don't have it at all, expands to nothing. If, or if we don't have the ability to check __has_cpp_attributes, expands to nothing. Otherwise, if the nodiscard attribute is greater than or equal to nodiscard message, then it should expand to [[nodiscard]] with a reason. Now there is a transition here that's blocking it for the CUDA compiler because CUDA 10.1 did not support [[nodiscard]] message. What has changed fairly recently, I'm not actually sure if it changed, I think it changed after Alex created this PR, but I can check. That was, the fastest way is actually in the change because I forget what file we we modified. We increased our CUDA requirement to 11.6.0. That happened fairly recently. I think it was this PR. Yes. Where we updated our CUDA compiler to the first version that officially supported VS 2022, that also updated its front end and it is now required. And that happened on June 15 of this year. So it did happen far after Alex originally created this PR. So we should check if CUDA 11.6.0 supports [[nodiscard]] message. I would hope that it does, but it might not, because this is a C++20 feature and supporting it in lower standard modes, Umm, actually no. This should be controlled by the standard mode. This gracefully downgrades. If you have [[nodiscard]], but you don't have [[nodiscard]] message. Then Alex's machine reads downgrade. So really this we should not need to block __CUDACC__. If this works OK, add a comment um. Uh, #blah um. Ah. As 2791 updated to CUDA 11.6. Is this um block still, Or do we still need to block? The less special casing the better. OK, as 2791 updated CUDA 11.6, do we still need to block CUDA here? OK. And that is definitely on us. For not getting around to reviewing this earlier we've been slowly getting through the uh the PR backlog. OK reloading everything in my head, TRANSITION, this should go to <vcruntime.h>, we don't have __has_cpp_attribute detection at all, then expands to nothing. #elif [[nodiscard]] is greater than or equal to the [[nodiscard]] message version and ask about the CUDA block, !defined(__CUDACC__), OK, then expand to actually use it. Otherwise if the [[nodiscard]] attribute is at least the classic value, and I think this is right, but let's double check. Yes, 201603 is the original value. Correct, >=, then use it by itself, otherwise expand to nothing. And because the control regions here are pretty tiny and it's not heavily nested, we don't demand comments here, OK. So this is. Ah, OK, so that's [[nodiscard]] message and then, Alex is adding a variant attribute for [[nodiscard]] constructor message because sometimes we may want to mark constructor with a reason. So if we don't have the attribute, if we can't look for attributes at all, expand to nothing. If we have both the constructor and the reason, then [[nodiscard]] ctor expands to the one without a reason [[nodiscard]] ctor message expands to [[nodiscard]] message. Otherwise, this is the case where it is not sufficiently new for the constructor, so we have no possible fall back. They expand to nothing. Agreed, and two lines are controlled here. This is still OK to not have a comment. And here we do not, we can't unify the macros because if we just use [[nodiscard]] message, it would degrade to double bracket [[nodiscard]]. But that cannot appear in such old modes or old compilers on a constructor. So this macro is necessary assuming it's still being used, and I think it is. One thing I like to check for is if a PR has been heavily revised, make sure that all of the machinery it's still adding, the need for it has not disappeared during edit. So I'm going to expand everything, search for uses. Here's the definition. OK, so _NODISCARD_CTOR_LOCK and _NODISCARD_CTOR_THREAD are using it. Like ignoring a thread. OK, it is being used. Good. So this is not stale in any way. Excellent. OK, so that's [[nodiscard]] message and [[nodiscard]] ctor message. So now I'm going to look at the macros that are being added to understand if these are good cases to emit the warning, why we're getting the warning there or why in this case, I think this PR is converting every everyone already had a [[nodiscard]] to reason, so we just need to make sure the reason is unique enough to deserve a message. And think about are there any cases that are not obvious that should also be marked? So as I mentioned, the remove() algorithms, those are a classic example where they have a second step that needs to be done. So this is definitely good. The unique algorithms, same idea but a different name. This is sufficiently different enough that I think having a separate macro we could super unify it into like remove-unique. I suppose one could do that. But here, just looking at the message briefly, there's a good reason Alex has got a good reason for splitting these, because with remove() he suggests using the erase() and erase_if() functions that I added to the standard originally in a TS. But that's not applicable to unique(). There's no unique-ifying thing that will also sort. So that is sufficient reason to not super unify all of this. OK, next is empty member function. Although this does fall under our pure observer criterion, this is a very likely bug that new users could commit when you're just using vector for the first time. And although experienced users will understand what happens when they drop, like, you know, operator!= on the floor or something empty() versus clear(). Providing the guidance to call clear() is reasonable, and there's only a few occurrences, so having a dedicated message is reasonable. Also because the standard thought it was important enough to mark. Um, OK, next? empty() on an array. Um, that's a pure observer, but there's no such thing as clear(), so providing guidance for clear() would be wrong. So have special special casing this for array also seems reasonable. It could be argued that the user might think that this is more of a pure observer case, but I could see a user converting from like vector to array if they're not really familiar with the two and then thinking they could empty() it out, and having the separate guidance here seems reasonable. OK. OK, so it looks like Alex is adding messages for everything named empty(). There's one in stacktrace, which is the feature Alex himself implemented. This explains how to clear the stacktrace. I like this one because since I use vector all the time, I'm like everything behaves like a vector. I don't need to know any other class, and I might, you know, if I'm not sufficiently caffeinated, say stacktrace.empty(). Having guidance that explains what to do and how to reassign it is reasonable. And then it looks like Alex just has a fallback empty() function, but not, doesn't need specific guidance for clear(). This seems reasonable. Can any, this is sufficiently vague. Container or container-like object? That seems right. _EMPTY_MEM_FN_ADAPTER. Ah, for queues and stacks, I was like _EMPTY_MEM_FN, but I thought that that function doesn't have any sort of empty(). But no, it's a empty() on, an empty() member function on an adapter. Now I'm currently thinking do I like _EMPTY_MEM_FN here, eh it's not really a problem for searching because the actual function is lower case. _EMPTY_MEM_FN. Yeah it's not worth trying to rename. OK yeah queue or stack and agreed that there's no way to clear. I'll like I mentioned later I'll do a check for spelling and stuff because that needs to be fixed so these all seem good. Next up barrier. So this is the multithreading. New multithreading component. If you arrive at a barrier, you should not discard that token. You're going to need it. You're going to need to wait. This is excellent because if you're new to barrier you might not realize I didn't remember this case, that we marked this as [[nodiscard]] for an unusual reason. This is a case kind of like removing unique that it's a multi step thing. Um try_wait(). OK, so here I guess we had we had marked it as [[nodiscard]]. And if you, tried to wait for something, you would probably want to know what happened, like did you success? Did you reach this success criterion or did did it time out? So you really should inspect it. I remember there were some, there were some controversy slash question about there was some, I'm trying to remember what it was in condition_variable or something. There's like a member function where we really, it was like unique_ptr::remove() where we wanted to mark it as [[nodiscard]], but users came up with some cases that were like 10% reasonable 10% of the time and we ultimately did not mark it. I can't remember it, was that try_wait() or was that something else? Something like that I guess I can search. It's been a few years.

>> Nicole: My understanding is that try_wait() like. Immediately returns you like, I don't think that there is any reason to call it except to check if something is finished.

>> Stephan: Ohh it's like instant. It doesn't take a chrono or something

>> Nicole: Right, that that's my understanding anyways. I very well could be wrong.

>> Stephan: Oh oh cause it's it's latch. Latch is try_wait()'d. It just returns a bool. OK, I was thinking of wait_for() and wait_for_until(). OK yeah you're right. So in fact let's check wait_for(). Uh, let's see. That's future. That's ugly. I don't want ugly. Ah, here we go. So, like in condition_variable, are we in the normal condition_variable here? condition_variable_any we've got wait_for(), it returns a cv_status. You probably should be checking this thing, but there's a few cases where it's reasonable not to, so we did not mark this as [[nodiscard]]. Um, but you're right that try_wait() is special, and we already marked it as [[nodiscard]], so this is just providing a reason. Excellent. Um, OK. Great. Um, _TRY_CHANGE_STATE. What even is a _TRY_CHANGE_STATE? Interesting. This must be. This must be used on things that are not literally named _TRY_CHANGE_STATE. I would just like to see what it is and then I'll resume.

>> Casey: Search for the macro.

>> Stephan: Yeah ohh try_lock OK. try_lock_for, try_lock_until() OK. OK, that seems sufficiently generic. OK, let me go back. _TRY_CHANGE_STATE, um. _TRY_CHANGE_STATE_FN. Non-member versus member. Here it's, these are really similar as, is this the first pair that was member versus non-member? I think it is, every, everything else here was like member yeah remove() and unique() are nonmembers for the ones we care about. Empty is always a member function. barrier() is a member function. try_wait() is member function. So these are the first ones that are free versus member function pair.

>> Nicole: I believe that empty() has two, one for member function and one for the like std::empty() of a container.

>> Stephan: Oh, oh, yeah, because we have. Uh, yeah, you're right. Yeah, like, like size() and um. _EMPTY_MEM_FN. Ohh, EMPTY_FUNCTION. Ah yes. Good catch. Yep, there it is. Yeah, non-member. OK, so yeah, it's reasonable to have one for _TRY_CHANGE_STATE and _TRY_CHANGE_STATE_FN Ah.

>> Nicole: It would be nice if the things were standardized so that, like the member function one is always _MEM_FN,

>> Stephan: Yeah yeah,

>> Nicole: the function one is always _FN.

>> Stephan: Yeah, at least in the case where we have both. And this this one actually spells out function. _EMPTY_FUNCTION, _EMPTY_MEM_FN. I suppose when we I, I like having the different spelling function because that way one is not a, um, like strict substring of the other. But I agree that it should be consistently done. That's worth a comment. OK, so.

>> Nicole: That I have a concern with calling it function just because that sounds like a very common thing, and I think that function has an empty member variable or member function.

>> Stephan: Ohh std::function understood. std::function does not. It has just an operator, explicit operator bool(). You're right that it is a very common word, unfortunately. Standard doesn't quite say free function anywhere. It just says non-member but _NON_MEMBER_FN or something. Seems very verbose. Let's see. Any any ideas? There's, um, let's see the

>> Nicole: could be, _MEMFN without a thing, and then just _FN, so you could search for like _FN with a underscore before it. Versus _MEMFN.

>> Stephan: We we could do that, I'm thinking. Where is the calling convention thing? Um. It's a non-member. with case. Uh, OK, let's search for all occurrences of stdcall. No, that's gonna be horrible fastcall. There we go. That's the next to def. Why did I miss it? Ohh, it's _EMIT. Ah, OK, so we have it. _NON_MEMBER_CALL for these horrible macros, and then _MEMBER_CALL. So that's the precedent where we have to distinguish members versus non-members. We spell out member and then we say non-member. So for these macros, let me go back to the review. If we followed that convention, which I'm not necessarily saying is a great convention because those macros are horrible, it would be something like empty non-member versus empty member adapter. Member is more common here, but non-member is more common elsewhere like well. Now actually I would say all of the cases where we have both, the member ones more common because we have a lot of member functions then just one non-member function to mention. So how do you feel about like _NON_MEMBER versus _MEMBER and just not saying function at all?

>> Nicole: Seems reasonable to me, especially because [[nodiscard]] is not getting applied to like. member data or whatever.

>> Stephan: Right. OK, I'll add a comment there. Let's see where to mention it. Yeah, seems reasonable. Maybe on the first occurence. So _REMOVE_ALG, _UNIQUE_ALG, _EMPTY_MEM_FN. Let's see. We should, uh, consistently mark these. Let's see? When there are both member and non-member versions of these macros, we should have a consistent naming convention for them. Currently, there's, ah, some variation. Example variation is: _NODISCARD_EMPTY_FUNCTION is the versus I'll just get that plain member versus non-member. But, and then the other one was _TRY_CHANGE_STATE versus _FN. Yeah. I want to think thoughts that are bigger than three lines. Compared to: _TRY_CHANGE_STATE_FN, this is the non-member, versus _TRY_CHANGE_STATE. OK. Let's see if I can quote. Let's see I didn't open it locally or open it in the repo. Let me close some of this stuff. OK, what's that? OK, let's open up, the dreaded header <xstddef> where mortals fear to tread because calling conventions are horrible. Let's see fastcall. Smallest thing that I can quote here. I guess I could quote individual lines, I suppose. The non-member call. Versus the member call. Using MEMBER versus NON_MEMBER would be reasonable. Umm. Also avoiding, um, possible confusion with std::function, as Nicole mentioned, mem_fn. precedent. OK, let's see how this looks. When there are both member and non-member versions of these macros, we should have a consistent naming convention for them. Currently there's some variation _NODISCARD_EMPTY_FUNCTION versus _NODISCARD_EMPTY_MEM_FN, compared to _NODISCARD_TRY_CHANGE_STATE_FN versus _NODISCARD_TRY_CHANGE_STATE (member). Using capital MEMBER versus NON_MEMBER would be reasonable. Also avoiding possible confusion with std::function, as Nicole observed, and with std::mem_fn as I briefly thought and consistent with precedent here quoting _NON_MEMBER_CALL and _MEMBER_CALL. OK. Right. OK, so I was at _TRY_CHANGE_STATE.

>> Nicole: It might be also useful if you go back. Um. Personally I would appreciate if we had _EMPTY_ARRAY_MEMBER as opposed to _EMPTY_MEMBER_ARRAY. I think.

>> Stephan: I agree that is quite reasonable. Um. Trying to think all possible permutations for reminding me of the recent XKCD comic about tetherballs, rope versus pole versus ball. Which orders are most fun, in this case. _NOISCARD_ARRAY_MEMBER_EMPTY. Because you could say the class name kind of like, you know, array::empty(). Um. So you suggested what _EMPTY_ARRAY_MEMBER? I agree that putting MEMBER, _ARRAY_MEMBER sounds better than _MEMBER_ARRAY.

>> Nicole: Yeah, that's what I suggested.

>> Stephan: So there's _EMPTY_ARRAY_MEMBER. Or _ARRAY_MEMBER_EMPTY. Beginning with the prefix _NODISCARD_EMPTY, even though it doesn't quite follow the order of like declaration where you would say array::empty(). This keeps all the empty, they sort together.

>> Nicole: Yeah, I like that

>> Stephan: I think that is good, yeah OK. Let's see, I'll add that here. Cause it's really just the naming. Can you again? Yeah, that. Additionally recommends, and I agree that. OK, so _NODISCARD_EMPTY. And then _ARRAY_MEMBER would um. be easier to read than _NODISCARD_EMPTY_MEMBER_ARRAY. While still having all of the EMPTY macros sort together because we love sorting. OK, let's see why is this, like almost truncated here. Nicole additionally recommends and I agree that _NODISCARD_EMPTY_ARRAY_MEMBER would be easier to read than _NODISCARD_EMPTY_MEMBER_ARRAY. While still having all of the EMPTY macros sort together. Ok, _TRY_CHANGE_STATE. _TRY_CHANGE_STATE_FN. _NODISCARD_PTR_ALLOC_FN. This function constructs an object wrapped by a pointer. Versus a raw pointer? What is the difference between these two? _PTR_ALLOC? And _PTR_RAW_ALLOC. Oh, _RAW_ALLOC, _RAW_ALLOC does not construct. And _ALLOC constructs. Or _ALLOC returns like a smart pointer. I'm curious about the difference here. What uses this. make_exception_ptr(). So this is resource managed. It's not gonna leak, but it makes no sense to call it and drop it on the floor. Um make_shared()? It seems reasonable to have a dedicated one for this. Um, in theory the the construction of the object would, could have side effects, but then why are you dynamically allocating it? That's interesting. Cameron reports in the the chat that he's just fixed the compiler bug preventing [[nodiscard]] in C++20. Thank you Cameron, that is awesome. OK, so then _RAW_ALLOC. This one I assume applies to something like std::allocator and scoped_allocator. Yes. And memory_resource doesn't directly provide allocator, right? It's um. Or should we be expecting to see polymorphic_allocator pop up on this scan? Why is polymorphic_allocator not here? Trying to remember like all the stuff we've added to the standard. OK, who says allocate(? It's gonna have a lot of stuff. Who says pointer allocate(? Um, interesting? <memory_resource>. Do you have a polymorphic_allocator? No. There's a subheader now. <xpolymorphic_allocator>?

>> Casey: <xpolymorphic_allocator>. Yeah, it should be in its own header.

>> Stephan: We have something called allocate. Uh pmr::memory_resource has an allocate() that returns a void*. It's marked as [[nodiscard]], but this really should deserve a reason. Because it's absolutely falling under the, I'm allocating something wrong, and I don't think <xpolymorphic_allocator> is being marked here. Um, check. No occurrence of <xpolymorphic_allocator>. OK, so we've got a missing thing. It's a good thing I'm reviewing all this. That's a raw pointer one, because it is a void.&ast;. OK, so let's quote that. Go back. <xpolymorphic_allocator>. allocate(, here we go. Is that the only occurrence here? It says void*. Sorry for that. If that sound is being captured, here we go. OK, that's the only occurence here. Hit y to get a permalink? Do I want to show that it's memory_resource? Sure. Ok. And umm, polymorphic_allocator? Where does that allocate() come from? I'll check that in a second. Let's see. Probably should quote the whole thing. This should be applied to memory_resource::allocate. Yes, because it's a raw pointer. OK, so where does the actual polymorphic_allocator class live?

>> Casey: Same file. line 206 I think is what you want.

>> Stephan: Alright, line 206, up, we're there. Ohh yeah, um, this returns a _Ty*. Equally wrong, yeah. So this one should also be annotated. OK, let's get that. Back here. 206 polymorphic_allocator, allocate, this one. What I really want is the ability to like quote but then hide lines in the center with like a little expand-y. So I don't need to do 2 separate quotes, I'm just going to quote one polymorphic_allocator::allocate(). And polymorphic... Mighty Morphin' allocators::allocate(). OK, this should be applied to memory_resource::allocate and polymorphic_allocator::allocate. Really, um, one of the things I like to do is think about like all the ways to search the STL, because like a lot of the things I do are powered by searching for every occurrence of a thing, and that's how I learned the STL originally, and I still rely on it a lot. In this case, our internal macro _CRT_GUARDOVERFLOW is something that we use to tell the compiler that we're going to internally do a multiplication here, in this case bytes times number of objects. And this tells the compiler to do something very useful, although slightly nonstandard, that if an integer overflow / wrap around happens before the function is even called, then that should send, instead of the actual result of the allocation, it should send negative one. You know the maximum value of size_t to the function so that the function can see that, oh, you just try to allocate a zillion bytes, I should fail. This catches cases where somebody tries to allocate something and they have an integer overflow in the expression passed to allocate. That is extremely likely to be a security bug, and it justifies doing something very slightly nonstandard and detecting that bogus code before they call allocate. And it has to be a special __declspec annotation on the parameter, because otherwise there's no way for the library to influence what happens before you call it. So let's search for all occurences for _CRT_GUARDOVERFLOW. Casey is beating me to the punch and finding cases where users don't directly use stuff. So unfortunately this, also what we've also marked this that the compiler teams request on a whole bunch of things that internally call allocate pretty soon. These are not raw functions, so they should not be, not marked, but anything that mentions allocate should. So let's just take a look. regex search for anything that says hopefully it should be on the same line and not wrapped: allocate.*. OK, much fewer occurrences. So we've got _Crt_allocator. That's an internal type Casey mentioned. Users don't directly call this, so we mark it as [[nodiscard]] for our purposes, but we don't need to provide messages, because if this occurs we're going to know what happened. scoped_allocator I believe was already addressed by the PR. Let me split these real quick. You go on the left, you go on the right. OK, let's journey over to <scoped_allocator>. Yes, pointer allocate() and allocate() with hint are being marked as _RAW_ALLOC, so that is done. This is, I wish I had more monitor width, um

>> Casey: allocator_traits.

>> Stephan: This is, yeah, allocator_traits, the wrapper in <xmemory>. <xmemory>. So we've got. See who is this? Or are these the allocator_traits up here? I want to see the context, this is std::allocator. Interesting. Allocator traits on 546 should really be marked too, because it's wrapping the allocator. It happens to say pointer rather than _Ty*, but. If _Al.allocate(), like you should not call allocator_traits and then drop it on the floor. That's equally wrong. OK, so this is the missing occurrence. We should comment this right now. Um. Let's see, it's allocate(), allocate_at_least(), and then allocate() with hint, right? Yeah, because the wrapper here, let me maximize this quick. It's allocate(), allocate() with hint. Do we have an allocator_traits for allocate_at_least()? No, we don't. That's interesting. So it's only allocate() and allocate() with hint. OK. Um, should I quote? Let's quote. um <xmemory>? First occurrence of allocate(, with a space before? OK, normal allocator_traits::allocate(), allocate() with hint. Phase two, I want permalink. OK, I don't need this anymore. OK. Maximize um. allocator_traits::allocate() should also be marked. Yeah, _NODISCARD. It's possible that these were missed because _NODISCARD was wrapped on a different line than allocate. I'm not exactly sure how Alex found all these occurrences, but I could easily see this defeating a search. I know I've been defeated many way, many times by things wrapping and I expected the regex to get them on the same line. In this case, _NODISCARD and allocate, were on the same line. OK. So those those two. OK, we were searching for all occurrences of allocate. So that is traits and traits. And these are the _Default_allocator_traits. Oh, on 6, oh I should also quote this one. Um 632 and 646. And it's not actually allocator_traits. This one is what we have these two specializations for compiler throughput because allocator_traits asks, it asks a lot of expensive questions. If we know it's the default allocator, we can short circuit a lot of that SFINAE like here. This is asking, do you have a pointer_type? Do you have a const_pointer_type? Do you have propagate_on_container_copy? And if we're allocator_traits for std::allocator, we know the answers to all these questions. We don't have to ask the compiler to do all that work. So let's search for following occurrences of allocate( with space. And here we go. _Default_allocator_traits::allocate() and deallocate(). These are kind of widely separated, but I know GitHub will at least abbreviate this when it's a bunch. _Default_allocator_traits. I'll mention both and back to blah. ::allocate() must be marked. OK. These are all occurring before line 800 something blah blah and blah blah. OK. So that's those. Go back to the search. We're going to want that open again. OK, so this is the _Default_allocator, _Default_allocator_traits mentioned, I mentioned, and then finally the std::allocator one. These are the ones being marked. On the left here. OK, so these are definitely. Oops. Go away. _Default_allocator_traits. I wanted, I wanted Alex's PR here. Yeah, 1, 2, 3 for the std::allocator itself. That's 1, 2. And then the third one, why did this evade my search? Because the _CRT_GUARD OVERFLOW wrapped to the next line. So yes, you got all the ones in std::allocate. That's good, or std::allocator. And then the last ones were the ones we mentioned allocate(). The memory_resource::allocate() on the polymorphic and ooh hello you were hiding allocate_object(). OK, the compiler, the standard just keeps adding stuff. I, I forgot about this, that this this was the thing. This should also be annotated too, because we're definitely allocating a bunch of bytes. And we get the size of the object. Yeah, that's ohh, and it's specific to C++20, so let's go update that quote. Um, back to <xpolymorphic_allocator>. [singing] polymorphic_allocator::allocate_object(). Yeah. That was I think, on >yvals_core.h< that I commented? Yes. polymorphic_allocator::allocate() and copy-paste. Hopefully this is correct. I'm saying polymorphic_allocator::allocate_object. That is the correct spelling there. And you are indeed. I'm not getting confused that allocate_object() is still a member of polymorhpic_allocator. It is, OK. Good, update the comment so I don't lose it. OK, so we are almost done scanning for all allocate()s. We got all three there, and then the TZDB one is just the _Crt_allocator. OK, so that gets all the allocates, which is good. That answers the question where did the polymorhpic_allocator go. Go away, OK now. _ASSUME_ALIGNED. So these are the, UM, the fun compiler wrapper functions. If you, say, assume_aligned() on a pointer, that, by itself does not have interesting side effects, you actually have to use the thing it returns. So that is an unusual reason to mark something [[nodiscard]]. So a message is good. launder() the even more obscure standard library function. Again, only the return value is specifically laundered. The original one is still dirty, so you don't want to use it. Yep, that's good. Now _NODISCARD_LOCK_SUPPRESS. Just an escape hatch. What is this? OK. So Alex is introducing an escape hatch. For _NODISCARD_LOCK and _NODISCARD_CTOR_LOCK. That's reasonable. Previously, we didn't have an escape hatch, and we just told users that if they they tried to do this unusual thing, I guess. I guess I can sketch it out. So one example where you can write unusual code, which is technically cromulent, you could say something like instead of. What is it? mutex? No, it's lock_guard. So if you have at global scope like a mutex mut, and then you say lock_guard. guard. my guard{mut}. Then you can do cool lock stuff. Do cool stuff and then when it's destroyed. This is not that language. Uh. When it is destroyed, the lock_guard is destroyed. So this you can do if you name it. We marked all of the lock_guards in the STL as either [[nodiscard]] on the type, or if they have multiple constructors, some of which should be [[nodiscard]], we mark it on the constructors so that if you accidentally say this, which constructs a temporary and then drops it on the floor immediately, that is dangerous because you are not actually locked when you do this. You've destroyed it at the semicolon. So that is a very, very important thing to mark. That catches a whole bunch of bugs. However, it can occasionally be used validly. That's if somebody writes something like this. Comma do_cool_stuff(), awesome_stuff(), semicolon. This constructs a temporary, suspends it in midair, does a bunch of other stuff through comma expressions, and then at the end of the full expression or the semicolon in ordinary human speak, the temporaries are destroyed. Nicole asked. Doesn't that create a default constructed lock_guard named mut? Let me think on. With uh there, I think the answer is different for braces or parens. I always get this wrong. By itself one case will do that. I think with parens it doesn't. It does. lock_guard with parens. I want to say this one. Actually creates the default constructed one named mut. This one constructs the temporary, but I'm not 100% certain we can actually check on Compiler Explorer. Open up godbolt.org

>> Casey: On the comma expression, it can't be a declaration anyway, so it should yes, be fine,

>> Stephan: but Nicole was asking about the, the the case where it's just by itself, which I've very briefly depicted. So that's the difference between if you've got a mutex mut, and then you have a lock_guard(guard1), versus lock_guard{guard2}. OK, what happens on 20, um? 6 cannot deduce. But let's just provide mutex here so we don't have to deal with thinking about CTAD. Constructor template argument deduction. mutex. No, that's not a thing. There we go. OK, um, six. OK, so six is trying to default construct, let me comment this out. Yes, so this. This parentheses are essentially not doing anything here. They're wrapping the name of the variable in parentheses. So this is not constructing a temporary, it's trying to construct a named variable with no arguments, and here it's complaining there is no default constructor. So you're right. But with braces, this does construct a temporary and throw it away and. We get um here by my. Why am I getting undeclared identifier.

>> Nicole: It needs to be called, it needs to be lock_guard<mutex>{mut} as opposed to guard2.

>> Stephan: lock_guard<mutex>. Ohh. That's right. Duh. Thank you. Try to construct from mut. Um, here we go. Yeah, discarding return value. So this one makes a temporary and then does nothing with it because we forgot to say guard. With parentheses, if you tried this, this would really be redeclaring a variable. If mut is already around in the same scope. Redefinition, basically different basic types. But if this were global scope, you could get away with this. And there we go. No appropriate default constructor. OK, so our reason to use braces. And so essentially what Alex is doing here is, we had very intentionally said we're just going to mark these constructors and if you try to do the fancy thing with comma expressions, well, don't be so clever. And it, it is reasonable to have a escape macro here in case you really do want to suppress the warning on those, but without having to refactor code as long as it's enabled. As long as the [[nodiscard]] warning for the guards is enabled by default, I have no objection to the escape hatch here. Essentially, if that lets people enable [[nodiscard]] for most of the time and write their unusual code, then that's reasonable. OK, so #ifdef _NODISCARD_LOCK_SUPPRESS, we might want to rephrase that message, but just the existence of the macro is fine, expand to nothing. Otherwise, _NODISCARD_LOCK and _NODISCARD_CTOR_LOCK. OK. Uh, then we have ones about, um, these are for constructors. Thread or if you create a thread and then just drop it on the floor, you never joined or detached it. Well, that's bad. It's going to terminate. With jthread, that's interesting. Do we mark jthread's ctor as [[nodiscard]]? It is unusual to construct a jthread and then do nothing with it. Let's see. jthread. OK, we did in fact mark jthread ctor as _NODISCARD_CTOR. So Alex is simply providing a reason here, and it does seem reasonable that you spin up a thread and then immediately join at the end. Why did you bother making a whole thread there when you weren't going to do anything else simultaneously? Very unusual. Probably wanted to wait until the end of a scope and then join. Yeah, so that's reasonable to have. async famously also has the blocking. Yep. And getting a future, if you get() and then discard, yes. OK, so these are all reasonable to have. OK, so I like the existence of all these messages. And. We found the I think the allocate() one was the case where we really needed to do an audit of the STL and find all of the occurrences. I'm not as worried about the other ones. I'll, I'll go review this later and make sure we're not missing anything obvious, but from a brief glance we're getting like all the remove(), all the unique(), and so forth. So overall the direction of the PR seems right. And I don't think we're missing anything. I'm trying to trying to rack my brain. Are there other cases where we had definitely applied [[nodiscard]], but we didn't provide a reason and we could provide a reason now. And this is getting all the ones, in fact, several ones that I did not think of. So it's great that Alex has done this, getting all the cases where the reason for [[nodiscard]] was far from obvious. The other nice thing is that, umm, we talked to Alex earlier. This PR originally tried to add reasons, I think for a lot of pure observers. That ended up being very verbose. It changed a zillion lines most of the time. The reason for [[nodiscard]]'ing something is that it's a pure observer and it's not very surprising, except for like the empty case like we discussed, where if you call you know std::find(), you drop it on the floor, you get the [[nodiscard]] warning. They're pretty self-explanatory we feel. So using the plain [[nodiscard]] for the vast majority of cases. And then using the special macros for the cases where it's unusual. It seems to be reasonable for warnings that do not get emitted that often they only get emitted under you know, unusual circumstances and then we just need to ask OK is the user going to be confused why they're getting [[nodiscard]] here? And the non-pure observer cases are the ones where it seems reasonable to have the macro. So I'd like the direction of this PR. I will come back to it after this, and check all the grammar and make sure that we're not missing anything else. But. I think this is good, so I'm going to hold off on submitting this review, but hopefully we are able to explore the reasons for [[nodiscard]] and why you should use it in your own code. Especially like even if you're just maintaining an application. [[nodiscard]] is useful because everything defines functions and calls it. But especially especially if you're maintaining a third party library, you should be using [[nodiscard]] as much as the STL. We are not only putting on all of our public functions now, we're going back and adding it to internal machinery as we update it, because in our own code we might forget to call something. Um, and it's so easy to add, has essentially no cost to the compiler. Um, because it's just an attribute. It can, you know, digest that token very quickly. It sets a bit somewhere. Saying, hey, you know, if I ever see this, [[nodiscard]], if I ever see this discarded, I should have made a warning, but otherwise it has no, you know, interesting costs, especially the one that doesn't have a message at all. That's just, you know, double bracket [[nodiscard]]. Very easy for the compiler to parse that, so we recommend using it as much as possible. OK, let me go through the chat, see if there's any remaining questions. Let's see, we talked about the, the bug that Cameron has already fixed. Casey advises please use views::take_while() instead of hacking find() with a side-effecting predicate. That is like take elements from this view until some condition is met and that condition could be state accumulated in the predicate. Is that correct or the function object?

>> Casey: I don't really recommend stateful function objects, but if you're using find() right you're going, if you're using find() and you're hacking it with a side-effecting predicate, your goal is to change every element up to the first one found that satisfies some condition, right? So you should pull out some condition into a predicate, use that with views::take_while() and now you have a range of exactly the elements that you, you know, wanted to modify and you can use that instead of this weird hacked find() thing.

>> Stephan: Yeah, and I think I've only seen one or two occurrences of that. In the the compiler itself. But yeah, that does seem like good advice.

>> Casey: It's a much clearer expression of programming intent.

>> Stephan: Yeah, just just write what you mean rather than sort of mangling the STL into something that does what you want. But the reason we have named algorithms is that you can see the name and you have some idea of what to expect if you get a find() that's doing fancy, unusual, side effect-y things you probably shouldn't be using find() in the first place. I'm checking the chat for anything else. Hi Casey's Kitty. Uh, let's see. Uh, let's see. Nicole does not like the name allocate_object because it only allocates storage for objects, not actual objects. Yeah, that's a reasonable concern. Let's see. Oh, interesting that internal tools are available, but if it's not available to the public. Then I won't mention that you're all here. And Casey mentions we're up to 5430 uses of [[nodiscard]] in STL headers. Funny thing, [[nodiscard]] is still going to be more popular than export. I only have about 3000 occurrences of export in standard library modules, and that's because we not only [[nodiscard]] internal functions, but member functions. And export does not need to be applied to every member function, it only needs to be applied to top level classes. So now and forever [[nodiscard]] will be the most popular thing. And oh, Cameron's already got a PR out fixing the bug, so that's awesome. Thank you, Cameron. OK, I think we can end this review. Thanks for watching and we'll see you next time on the VC Libraries Open code review.