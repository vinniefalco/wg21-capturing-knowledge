>> Casey: No. Apparently transcription has started itself. Hello everyone. Welcome to yet another Visual C++ Open code review. I'm Casey Carter. Remember the library's team here? I spent a lot of time working on the STL and quite a bit of time working on standardization with WG 21 of the actual C++ language. Today we're going to be talking about. PR2580 for the STL, which is implementing P2440R1 ranges::iota, ranges::shift_left, and ranges::shift_right. I'm gonna pull up the paper real quick since I didn't do that yet. Ohh no. Sorry I don't have my shortcuts configured correctly here. No, this is a relatively short paper.

>> Casey: Adding

>> Stephan: you are not yet sharing your screen,

>> Stephan: by the way

>> Casey: I'm not yet sharing my screen.

>> Casey: Thank you. OK. This is the paper of P2440R1. It adds 3 new ranges algorithms. The things that were already existing algorithms in pre ranges, world right? iota exists, except it's not in the algorithms header, it's in the numerics header. But it's nonetheless an algorithm. This adds iota, shift_left and shift_right. As ranges algorithms, in addition to their std algorithm versions. So let's get the PR and the paper. Side by side. We'll go into the files here. Alright, in my usual alt click trick to compress everything down and wow this is touching a lot of files for adding three algorithms. We've got a new test for each. Test case. And configurations for test, test, test configuration. We've got a change to the feature test macro, presumably because this paper adds a feature test macro that we'll now need to test for. Changes to core, probably to show that the paper has been implemented. Interesting, did we add ranges::iota in the numeric header? We must have. That's news to me. I thought we were gonna add them on algorithms. But I was apparently wrong. Yeah, even says the feature test macros in numeric. Alright, awesome. It's more fun to discover these things as we go than to read the paper ahead of time right. So? And we know why that's changing all of these headers. Let's, uh, start from the top. Let's make sure the new tests are in here. And that the names are spelled correctly. This is a the shift_left test. And both of its files are there. shift_right? Uh-oh Oh no, this is a change to the existing shift_right test. Now I'm very confused why we're choosing the existing test and adding a new test. But we'll work that out when we get to it. Addition is actually correct. The correctly spelled name, and that's all I'm concerned about right now. Again, these three new tests have been added and the spelling of the names is correct. We actually have to double check that because otherwise the our test automation isn't bright enough to tell us. If the names are spelled incorrectly, it will just run no tests and be happy. Next step, let's pop into yvals_core. Yeah, there's the addition of the comment that says we've implemented this proposal. It is in sorted order. I'm not sure if the name matches. #2537 the name in our issue, we're usually really. Sticklers about. Using a simplified name. This simplified titles for papers that are easier to keep track of. That's not the right one. 537 OK. The transposition. Yep, that's exactly the title we listed it with in our issue for the proposal. So that's all correct. Looks like we have pulled __cpp_lib_shift out of the C++ 17 section of feature test macros. Probably to move it down to the conditional section. Make this bigger. Too many comments. 23 section now that we've got this in the wrong place. Apparently Stephan has already commented that this is the wrong place. It needs to move down to the macros with language mode sensitivity section. We have Four different sections of feature test macros we defined here. There are C++17 macros. Things that are defined in 20 things that were defined in 23. Whenever the macro depends on language mode or pretty much anything else, it gets pulled out and goes into a fourth section for the whatever configurable things. And just needs to go there, but isn't yet so. That's already noted, we don't need to note again. We'll make sure that the value is right. Yeah, it's 202202, which is the February. Waiting, I'll check that in there. Good that I conveniently have the working draft open before. __cpp_lib_shift Is in fact defined to 202202? So this was added in February. We've got endif comment that matches correctly matches the condition on the if so, that's all good. Addition of the new feature test macro for __cpp_lib_ranges_iota This is out of order. It was added to the end of this section instead of being added into this section in sorted order, which would put it somewhere up here. In between invoking this snooping on Stephan has already commented on that.

>> Stephan: It should actually move up just one because

>> Stephan: it's __cpp_lib_ranges_iota.

>> Casey: Thank you. Luckily I didn't comment incorrectly and I don't have to fix it. Anyway, we have feature test macros that's presumably all of them that were defined by the paper. I don't understand why people can't put the feature test macro wording in the right order. Like we never do. Update the value __cpp_lib_shift in version.syn Find __cpp_lib_ranges_iota. Those are all the features test macros, so this header has everything correct There's nothing additional to comment on in this header I should say. They are all commented on. Moving on. Let's do product code. I'm going to look at xutility first because it's a. A higher order header than algorithm and numeric that users include, right? This is an internal header. And this one happens to be included by both algorithm and numeric, so I assume there's a common code in here. And this is adding the out_value_result algorithm result type. There are a whole bunch of these things that we call result types whose names all in with under score results that were added to be types with pretty user. respellable names for the return values of the ranges algorithms because we wanted to avoid ever having anything return tuple or pair, we wanted to always return names types with named members that people would refer to that would be stable. Because it's very hard when you're writing fresh code that takes. A pair, right? If you're using, say, insert into a std::map. Returns a pair of an iterator and a bool, and people can never remember if it's an iterator and a bool or bool and an iterator, so having actual names you can see you don't have to remember the order. Anyway, this is called out_value_result, which means it's going to have a member named out. and a member named value. We have a very very simple. naming rule that wg21 uses for these types. Uh, these are gonna have [[no_unique_address]] applied to them, which is a pretty much a good idea with anything generic. In C++20, I'm going to go find. Here's the declaration of this class template. It's supposed to be in std::ranges. Make sure we're within ranges, yes? Within ranges we're in the concept section. This is being made conditional for C++23. Which is all correct. There's the endif, there's commentary. It does match. The detailed specification of this and I didn't want to click that that's going to link. Yeah, you got the standard. Alright, details back. This is again a class with two parameters. The members are both there. They're types are the first parameter. The first template argument and the first second template arguments. There [[no_unique_address]]. Appropriately, we are leaving these commented out. In the STL, for now, because MSVC didn't support [[no_unique_address]] for a very long time, and what we did do was add the attribute to the compiler so the compiler understood the attribute and didn't do anything with it. And then by the time it came, you know, by the time we decided we needed to actually implement the semantics of the attribute. It became clear that doing so would be an ABI break because we had been compiling code, they had that attribute in it already for a couple of point releases and not doing anything with the attribute. Since we really, really don't like breaking ABI, that meant we decided to have [[no_unique_address]] do nothing in MSVC until the next ABI break. We do have another attribute that's in the MSVC namespace. It's [[msvc::no_unique_address]] which does do the it does have the semantic effect that the standard specifies for [[no_unique_address]], right? There are no backwards compatibility concerns because we added that with the semantic in place right when that attribute was new, but unfortunately that means we still can't use [[no_unique_address]] even with the MSVC specific attribute. In the STL, because clang doesn't support it yet. And clang largely doesn't support it yet, because they're waiting on me to get information to them about exactly how our implementation works, and I haven't had time to do that lately. So for now we have [[no_unique_address]] with comments and many places in our header files. Is there a reminder that eventually? There needs to be [[no_unique_address]] there. Or the equivalent. OK, again, this is result type. They have the standard format they have named fields in a struct. And they should be convertible to other specializations of the same class template when the types of the members are convertible from the types used in this specialization to the types in another specialization. So here is a conversion operator to. out_value_result with _OOut and _Ty2. Interesting. I would expect to use the same convention either adding two to both of the names. Or doubling the character at the beginning I I wouldn't care about a convention, but it's kind of strange that we picked two different conventions for naming these, so I wanna comment on that. It's odd that we're using two different "name adjustment" "name adjustment" conventions to get the parameter name for the conversion operators. Please pick one. I'm going to go ahead and edit this point. I thought it applies to both.

>> Stephan: Looking at other examples in the STL, it does appear that the repeated character is the current convention. We've got I in, O out, F fun.

>> Casey: Wonder if _TTy was a problem. Can't imagine what it would be.

>> Stephan: Interestingly, for like minmax result we do use _Ty2, so there's Preston for both, just not in the same type Actually, maybe there is one I. I haven't completely searched thoroughly yet.

>> Casey: Uh we. I guess consistency is the hobgoblin of small minds. I think is what Einstein said Anyway, we'll we'll work that out. Alright, so it's a conversion operator. It is correctly constrained to require. That the target type _OOut is convertible from a const lvalue out, and that's gonna be const lvalue because this is a const lvalue qualified conversion operator. And. Same for the other type. That const _Ty& is convertible. Sorry, that _Ty2 is convertible from const _Ty&. And little helper concept. And of course, it just has to return. Members yes, this is an aggregate. It's not not. It's an aggregate. We don't need to worry about explicit conversions. So so it doesn't need a name and it's hard to type. And the other one. This is going to be the rvalue converting constructor. Yep, it's rvalue qualified. And we require that. rvalue out. Sorry an xvalue out I guess. Right that out is convertible from an out xvalue. The && here is extraneous. This is one of those things that we like to harp on a lot in the code with type traits and or concepts that use. declval essentially in their implementation the T&& is the same as T and is equivalent. And we try to keep the excess &s the sorry, the extraneous &&s out of the code, because it's just a little more garbage to read and decipher. Someone has already commented this so I won't comment it again. Thank you miscco for catching that. Otherwise, this is a constexpr conversion operator to out value result of those types once again. We're returning, you know, the difference here being that we're moving these members to get conversions from rvalues. Which is consistent with the rvalue qualification of the conversion operator, all good. So this is matching the pattern that we use elsewhere for. A great many algorithm result types. And that's the only change we have here in xutility. Personally, that's gonna be used in at least one or two of these. It's also possible that they just put it in the header. No, it uses out value results. Sorry, I'm going to scan through quickly. No, these return subrange. So it's actually only gonna be used. In numeric. But presumably someday we might have another algorithm that needs it, and it might make sense for it to be an xutility instead of pushing it down and.

>> Stephan: Ohh, it looks like we lost Casey. OK, maybe his teams crashed. Please stand by.

>> Casey: Hello, welcome to another another Visual C++ Open code review. OK, where was that when I disconnected?

>> Stephan: You were talking about potentially moving something defined in xutility down to the header it's used or whether it should be kept in the central header for potential

>> Stephan: future use

>> Casey: right, out_value_result.

>> Casey: This out_value_result apparently is only used in numeric right now. We could put it in numeric instead of putting it in xutility. I'm tempted to leave it in xutility because that's where the majority, if not all. Of the other algorithm result types are defined. Yeah, they did put this. Together with other algorithm result types in the header.

>> Stephan: You might want to reshare your screen.

>> Casey: I did it but apparently I didn't do it hard enough. There we go. We are online. OK. Tiny little throughput cost. Or one class template that's not instantiated? I don't see this being a huge throughput problem. If we do leave it in xutility, so I'm not gonna complain about it. But then again, I've. I wouldn't refuse a change if somebody else said they wanted one either, so I'm just gonna let that one go for now. And we're going to move on to more product code. We're going to numeric and take a look at iota. OK, I need a little more context to see where we are in the header where right after std::iota. Excellent, that's where I would want this to be. Right off the bat, we're defining the alias for the result type. This again is also part of the Convention used for ranges algorithms. We'll have a result type called a generic result type. It's name is exactly the same as the names of its members member name, member name, etcetera under score result and then we'll have a specific alias for each algorithm for the result type that it returns. Since this algorithm is named iota it's iota_result is an alias of out_value_result and that again is exactly as specified in the paper. Moving on, this is internal machinery. I'd like to get down to see the actual user public declarations first. Make sure that they match the standard. OK. We have input_or_output_iterator, sentinel_for that input_or_output_iterator and weakly_incrementable. requires indirectly_writable. First type comma, const lvalue of third type. Those that agrees constexpr iota_result First parameter, third parameter. iota, this overload takes an iterator and a sentinel And another type initial value. So this does appear. Exactly. Like the declaration in the paper. And this next one also. weakly_incrementable, output_range const lvalue of first parameter type. constexpr, returns an iota result of borrowed_iterator<R> comma T iota. A forwarding reference to RNG. Range type and value. So these declarations do look exactly like they do in the paper, which means they are wrong. Yes, this is one of these weird things we have front matter. For ranges algorithms That specifies. Lemme get the standard open. Which I lost somewhere here.

>> Stephan: And while you find that I'll read out Cameron's question, Cameron asks, I have a question unrelated to this specific PR rather ranges as a whole. I notice that some algorithms like for_each are not available for ADL to find. That's argument dependent lookup because they're implemented as an inline variable. But others, like this iota are not. What is the motivation for one method versus the other?

>> Casey: What is strangely pertinent question. So. The reason for the difference is that these in the PR are incorrect. We have front matter that states various requirements for, uh, overloads of algorithms and ranges. Hmm, this is the right stuff I will find. Parameters otherwise specified. There we go. The entities defined in the std::ranges namespace. Let's make this bigger. So that I'm not the only one who can see what I'm reading. OK, look at paragraph 2 here in algorithms.requirements. The entities defined in the std::ranges namespace in this clause are not found by argument dependent name lookup. When found by unqualified name lookup. Or the postfix expression and the function call basically unqualified lookup or a function call. They inhibit argument dependent lookup. This is an intentional bit of design weirdness where we had to introduce this property so that. Calls to ranges algorithms would be unambiguous and they wouldn't be, actually unambiguous isn't the problem. If you think about calling find, for example the the the two iterator version of find in std has a corresponding iterator sentinel implementation defined in ranges and if you wanted to call find with two iterators. And those two were somehow in the same lookup set. You would end up calling the std version. Instead of the ranges version, because it is more specialized since std::find, takes two first arguments by the same type and the ranges one takes those two arguments could be different types. It is less specialized. Anyway, and in order to get around this problem, we decided to make the ranges things not findable by ADL and inhibit ADL when they are found otherwise. So that these calls will work. And of course, implementing that means we have to implement them currently as objects. It would be nice if C++ gave us a better tool so that we could go ahead and actually implement these things as function templates, but function templates that have the same property of inhibiting ADL or not being found by ADL. But that hasn't happened yet. There are proposals in the works. In the standard, but none of them, to my knowledge, is actually progressing. So that's the thing, we have lots of things that are not really specified as objects that are implemented by, implemented as objects in the STL. For ranges algorithms, they're often referred to colloquially as niebloids. Thanks to Tim Song who is a cppreference maintainer and occasionally shows up at WG21. He came up with this name niebloids to basically mock Eric Niebler. Since Eric wanted them to be objects, and I argued that we should probably force the language to make functions work so that libraries could use functions instead of having to have everything be an object. Anyway, until that day comes, that means these things have to be implemented. As sort of object likes. We have a convenient pattern we use for that in the STL already. Go into algorithm here.

>> Stephan: While you're looking that up, I have a question. So in the the standard there's been some movement towards trying to name things by what they are rather than after people because the people based names are confusing like argument dependent lookup, occasionally used to be called Koenig lookup after Andrew Koenig who was the one who specified it, but Koenig lookup tells you nothing unless you know who he was and what he did and argument dependent lookup at least says what it does with the niebloids is there a formal term that we should be using? I know that customization point object is related but different and I can never remember if.

>> Stephan: Yeah

>> Casey: and people get the two things mixed

>> Casey: up all the time because one of them has a name and the other one doesn't. And because we added both things in ranges at the same time to the standard, so a customization point object is something that is explicitly an object. Right, it's a call. It's callable it's a function object type. But it is definitely an object you're allowed to treat it like an object, which means you can pass them around as arguments to things that take function... that take function object arguments, which of course is extremely handy, and it would be really handy to have for the rest of these algorithms. But again, since I would like the core language to be usable by people who write libraries. I I would like if we had first class overload sets or. Overloads of function templates and we didn't need to make again, we didn't have to artificially force things to the objects so that they would be useful. So it would probably be nice if we had a name for this thing, especially if it's gonna stick around for much longer. Umm? I think maybe in one or two more cycles of the standard at most will either have changes in the core language that let us use all these things, actual function templates, but function templates with an attribute on them that gives them the right semantics, or we'll have given up, and these will become actual explicit objects, in which case they'll just be Cpos. Like the other Cpos. And we won't need a name for niebloids. Anyway, the the transient, the intended transient nature is why we never had a name for it in the 1st place. We just called. Let them be things and somebody had to decided to come up with the name. The document that right Tim is a, I said he was a cppreference maintainer and he came up with a name to be able to document these things as a class.

>> Stephan: Thanks, that explains a lot and I've been reviewing this for a couple of years now and I didn't know the

>> Stephan: whole story.

>> Casey: Well, now you do.

>> Nicole: I also have a question about these things, uh, which might be. Unrelated, and if it is, you know we can talk about it later, but. How do you get a function pointer to these things? Because I don't see in the standard that you can't take a function pointer to these things, but I don't see how it's implemented to take a function pointer.

>> Casey: Sorry it's not implemented because you're not allowed to take the address of things in namespace std except when explicitly allowed.

>> Nicole: Ah. fair enough.

>> Casey: another one of the changes that came there in C++ 20. Yeah, we we have algorithm requirements and or blanket requirements that have just enough magic to let you implement these things as functions. I'm sorry as objects. Despite them being depicted as function templates in the IS.

>> Nicole: Cool

>> Casey: for example we have word that says you can't pass explicit template argument list to these. Because that would break if it was an object and not actually a template.

>> Casey: Anyway, there,

>> Stephan: and it's worth noting. It's a it's worth noting that users taking the address of standard library functions or passing explicit template arguments to them was problematic even before these object imitators were added. For example, people doing that with std::make_pair back in C++98/03. were broken when the signature of make pair changed in C++11 to be perfect forwarding. It would create a totally you know, undesirable templates specialization. If you said make pair angle bracket you know int comma double you would now get int, ref, ref, comma, double ref ref as your function parameters and that is not something that code written in C + 98/03 was expecting so it had always been problematic and with the addition of these object like things, the standard flatly forbidding users from doing this unless otherwise specified has solved both those problems and more.

>> Casey: Yes, and forbidding taking the address has also conveniently allowed us to make some more optimizations to the STL that we couldn't do otherwise. Sorry Nicole, I think I interrupted you.

>> Nicole: Ohh I was just saying thank you for the explanation.

>> Casey: Yeah. That's what this process is all about. So anyway, here's an example of find_first_of, the implementation of the find_first_of algorithm, it is defined as a again a class object, and we have a helper called _Not_quite_object that we derive these from whose purpose. Is to make impossible. Some of the behaviors that you would expect to work with this if it was supposed to be an object to keep people from accidentally taking advantage of what's effectively implementation details. So _Not_quite_object. It's got to be in xutility, right? tada here we go. _Not_quite_object. Actually describes its what its purpose is. Because this is a really weird thing. It has deleted default constructor to keep you from constructing objects of this type without knowing the magic construct tag. For example, right, we have a secret tag type that's necessary to construct these. They're not copyable or movable, and we've even deleted the address of operator. You can't try and take the address of it like it's an object. And. Ohh protected, default protected destructor always a nice thing with the base class to have either a virtual or a protected destructor to keep people from destroying through pointers to base. With the undefined behavior. So this is designed to be a base class and it inhibits lots of otherwise useful things that you would want to have your objects to have if they were intentionally objects. So these, tada, two template overloads of iota There are only two right, yes? Ditto niebloid sorry. I'm scanning the existing comments. It looks like we actually have an an attempt. Let's clarify this a little bit. Clarifying: ranges algorithms

>> Stephan: I think did you look at miscco's first comment because I think in his first comment he did at least try to explain what niebloids are. This is the this is the second occurrence, that's why he just said ditto.

>> Casey: Yes, I get that and. Let's look just search for niebl So now this is unfortunately in ranges. Algorithms are not functions or function templates. But are currently implemented as niebloids Those are objects with the call operator. The reason for that is that it inhibits ADL. Close enough. There are some conventions to follow here, and you should have a look at how the other ranges algorithms are implemented. The general starting point is something like. Class. Algorithm name underscore fn yes This is how we name them all consistently. Name under score fn. inherit privately from _Not_quite_object. Make its constructor set available with a using declaration. Then implement. Overloads of the function call operator to implement your actual algorithm. Declare an inline variable. Object of that type. The type of your function object. And initialize it with _Not_quite_object secret _Construct_tag. So. This is a great comment. I think he actually did a pretty good job of explaining what to do here, yeah?

>> Stephan: I just wanted to save you the work of writing all that again from scratch.

>> Casey: Yeah, miscco has implemented quite a few ranges algorithms in his time, so I I'm not at all surprised that he knows how to do it correctly. Anyway, that's awesome. It's fun having a community. Around the STL to do our work for us. Alright, coming back here so that that's already clear, right? Uh, they are nibloids Presumably they will understand if they read miscco's comments in order. What that is trying to tell them? So we will go ahead and review the algorithm. See what the paper had to say. Paper, which I've lost track of. Add the following, effects equivalent to. While first is not equal to last. while first not equal to last. *first = as_const(value). We are as_const'ing the value to enforce the value doesn't get modified. Which I don't think std::iota does, but hey, that's OK. It's still pretty close. We increment the iterator. We increment the value. Move one around until we get to see the range, and then we return the final value of the iterator and the final value of the. Object that we're using to initialize things. Pick your name. Accumulator would be the name if it was. Uh. std::accumulate, but it isn't so. Accumulator is nevertheless what it's doing. And let's go see what the actual implementation does. Is this going to be hard to read? It's a shame there's no way to collapse comments in GitHub that would be really nice. Anyway. Let's look at the iterator sentinel overload first. We've already checked. The signature is correct. He the first step is to verify. The iterator sentinel range using our iterator checking machinery we have. This is a standard, _Adl_verify_range does a look up to figure out if these iterators are, iterator and sentinel type are opting into our iterator checking machinery and it's so it does any checking necessary. After which it's safe for us to unwrap the iterator types into an unchecked type. Let's the STL use checked iterators and still. it allows the STL to use checked iterators in APIs so that we can ensure users are using the iterators correctly and then unwrap them and have fast, unchecked iterators that we use internally for the actual implementations of algorithms. In any case, we're verifying the range and then we're going to unwrap. Those first and last. Since this is. Potentially an input iterator. Yeah, this is potentially a single pass iterator. We have to pass in rvalue to _Get_unwrapped. Since input iterators may have things that need to be moved. So we are wrapping our value. We unwrapping our value of the Sentinel. We'll pass all of this to. The helper _Iota_unchecked, which is a common name that we use for helpers that implement the algorithm. After the unwrapping. Right there, using unchecked iterators instead of checked iterators. And _Iota_unchecked is up here It takes an iterator. Const reference to the sentinel. Instead of taking the sentinel value. That's kind of odd. That was already a commented here on the thing that I'm calling out as being kind of odd. I don't know if this is a different thing, sorry. miscco's comment was suggesting that we could take _Val by constant reference instead of by mutable reference, which doesn't work. As Stephan has already pointed out here. And I'm gonna go ahead and resolve this comment. Just to draw attention to the to the fact that there's no action to be taken here. So the the author of the of the PR can read the comments that they like to, but they will hopefully know that they don't need to do anything. Here's the body we're using that for loop instead of a while loop. First, not equal to last, increment first, increment Val. It's got the mandatory mandatory void cast here. Which hopefully keeps, uh, overloaded comma operator from being called. As always in the STL, we have to defend against hijacking of operators that we use by strange ADL overloads. Right, this algorithm is not. Specified as comma operator with an iterator and this whenever object type we're passed in, so we can't observably call that operator. We have to make sure that. It's not observable by user, and we do that by basically ensuring that no ADL lookup will find an operator comma and invoke it. The built-in operator comma. All right, and we've got a *first = const_cast. This is a handy way of implementing, as_const directly. Instead of calling as_const

>> Nicole: I would, uh, make the argument here that it should probably use static_cast. Umm?

>> Nicole: Because

>> Casey: so would I

>> Nicole: So we're we're not casting away const, so we I, in my opinion,

>> Casey: should we suggestion to actually call std::as_const instead. I don't think that's a great idea either. I think we can get away with the static_cast here.

>> Stephan: And I have offered a third alternative because and you can read my comment there. static_cast is powerful in a different way. It can't remove constness but it's willing to, you know, make temporaries and that sort of thing. Or maybe not temporaries, but it's willing to do fairly powerful transformations. So here we want something that happens implicitly, so if we're willing to spend an extra line, we could just implicitly bind a const _Ty&. I think that would probably be safer than a cast, or at least less scary looking.

>> Casey: Interesting.

>> Stephan: Yeah, because the the thing about static_cast is it's willing to reverse implicit conversions, which is actually what we don't want here. We want the forward implicit conversion of adding constness, but there's no like super safe static_cast that'll do just that. So that's why I suggest. Just make a temporary variable or a local variable.

>> Casey: I wouldn't say no to this. I wouldn't write this. I would write it I would write the static_cast I. I wonder why it matters to me. It's interesting. I would write the static_cast probably cause this consumes an extra line. There's another name to reason about. We avoid that with the cast. It is unfortunate that there's no clean cast that just says add const to this other than the one. Of course that we define in the standard library. Which requires instantiating a function template and suffer the throughput cost. So yeah, I will. I'm happy with this, I'm I'm not gonna add another comment here just to be clear.

>> Nicole: One thing I will say is, uh, something that is confusing to me is why we are not OK with as_const but are OK with move. Because that that. Seems odd to me.

>> Casey: We're not really OK with move either.

>> Stephan: Yeah you gotta, that's it's an excellent point. Like we we do spend move, oh sorry go ahead

>> Casey: the the the cognitive overhead of implementing move directly is high. And that that's really the issue, it's it's much more readable to see std::move(blah) than it is see static_cast<X&&>(blah) and then have to go back and determine OK is X actually the type? Is this move, or is it forward or is it doing something else? And in that sense, having the actual names move and forward as vocabularies is nice for readers.

>> Nicole: Fair enough

>> Casey: that said, there is a throughput cost and it would be nice if we didn't have to pay the throughput cost. You know, I could be convinced that we should have forward and move macros. Even though I despise macros, I could be talked into it as a way to

>> Casey: improve throughput. If

>> Nicole: I I would be,

>> Nicole: I would be interested in the like. Amount of actual speed you'd get from switching to move and forward macros. Uh. Especially since move, I think you still need to instantiate, remove, remove_ref_t. which is a template, I don't know.

>> Nicole: Anyway, beside the point

>> Stephan: and we have we, we have active conversations with the front end team about making at least forward and move compiler known so that it can just directly transform them without emitting real function calls for reference clang and I believe GCC have already done so, and MSVC does similar things to things like remove_cv_t just not move and forward, so that's that would be my preference compared to macros and honestly, I mean now looking at my comment here, it sounds like I'm advocating that we shouldn't use as_const I'm actually fine with as_const here. I mean, it is one call per element, which is a little bit more expensive than one call per outer call to the function. I had just recommended ohh you know we could use a local variable here in case you know throughput was a concern because I know that I personally have been relatively unconcerned about debug performance over the years and I should probably care a little bit more, and this seemed like a reasonably cheap way to do so that didn't involve like obnoxious static_cast<T&&> or anything, but I would be fine with as_const myself.

>> Nicole: Also, this is totally gross and I hate it, but you could put the const _Ty& const Val equals Val above the loop. Uh.

>> Casey: Yeah.

>> Nicole: Which would result

>> Stephan: And keep it bound

>> Stephan: even though the value changes

>> Nicole: yeah

>> Stephan: Yeah, that it. It still spends a line. I don't think it would necessarily interfere with compiler optimizations, but it is weird to reason about.

>> Casey: It would be a line you wouldn't have to skip over every time you're going through the loop in single step mode.

>> Stephan: Sure there would be that improvement, yeah

>> Casey: A little bit of UX. If you're debugging through this, but. Yeah, we can argue there's lots of reasons. Lots of little reasons to prefer one thing or another thing I. I don't think any of them is actually the best suggestion. Sorry I don't think any of them is clearly better than the others. Except of course getting rid of const_cast. I think we all agree. If we don't like the const_cast,

>> Nicole: no const_cast everywhere, please God.

>> Stephan: Well, we we do have some const_cast in the code base I believe, but keeping them to where they're necessary is like really unavoidable is ideal because that way we can focus all of our attention on them and say, OK, we're doing something super scary here. Let's make really sure that this is the right thing to do. Which is generally true for cast, but especially for const_cast.

>> Nicole: It really seems like we should have this like unsafe keyword maybe that puts all of our focus on unsafety into like 1 area maybe.

>> Casey: We already have one. We have a lot of them in C++ We have as many unsafe keywords as you like in C++. That's one one advantage it has over rust. Advantage OK. Moving on. I think we've beaten this point into the ground. We've got this loop. We're happy that the loop is correct. We don't like the const_cast We've made recommendations about putting something different there. Umm? I don't think we need this move. _First is the name of a variable with automatic storage duration. Right?

>> Nicole: Does that mean that gets UM

>> Casey:  get the magic value treatment and return right?

>> Nicole: Yep.

>> Stephan: They they added that though after 11. I think that's why I missed it because in 11 original the function parameters I think were not eligible for auto moving and that did change at some point. All the standard versions blur together for me now. Umm?

>> Nicole: Right, because function parameters cannot be Like nrvo'd like they can't be like without

>> Casey: Right they they can't be RVO you can't do return value optimization because the parameter has to get stored where parameters go like they can't get stored where return values go. But nevertheless, I think the implicit move rule works here, so we don't really need this move.

>> Stephan: And I think Nicole was correct to say nrvo specifically because it is a named parameter.

>> Nicole: Although now return value optimization is not a thing in C++ because prvalues are actually a real thing, I'm so happy they finally fixed that.

>> Casey: Here we go. class.copy.elision 1.1. This move is extraneous

>> Stephan: Looking at this makes me wonder if this is potentially a global problem throughout the code base, like if we're redundantly moving parameters that are non cv-qualified. I bet you there's other occurrences, not that we would ask this contributor to go clean up things globally. If anything, it should be a separate PR.

>> Casey: Should we do a global global thing for this. I'm not terribly concerned because it's not really a throughput issue. Redundant move is only a problem when it inhibits.

>> Stephan: Ohh that's right, yeah So it most. It's in the extra call

>> Casey: so it's just extra words to look at.

>> Stephan: Yeah

>> Nicole: I believe.

>> Nicole: I, I believe that this should be paragraph 3. Uh. Paragraph 1.1 is about r named return value optimization. So, uh. In a return statement, when the expression is the name of a non volatile object with automatic storage duration other than a function parameter, the copy move operation can be emitted.

>> Casey: Throw, coroutine, exception declaration. And implicitly movable entity. This wording got changed. Recently for 23. More things became implicitly movable. automatic storage duration that's non-volatile, or rvalue reference to a non-volatile object type. OK. So they haven't broken this wording. It's still 3 and 3.1 specifically.

>> Stephan: And I do recommend citing a working paper number when you cite a paragraph, particularly when they are editing the the standardease. Those paragraph numbers can be moved around, as we've seen here, so saying like in 4910 if that's the latest one could be helpful. If we got to go look this up, you know in five years and wonder, wait what we're what we're reciting, what paragraph with the was this?

>> Nicole: Should this use Tim Song's cppwp. So that it's stable.

>> Casey: That's a really good idea. Don't remember. What? no 4910?

>> Casey: Attack the.

>> Stephan: I didn't see a tip of trunk,

>> Stephan: but I don't know which that corresponds to. I haven't. I haven't used this myself. I was just proposing citing the actual just name to say 4910 and let them look up. Look it up necessary because mostly concerned about us looking at this comment.

>> Casey: The problem for years down the road right now I have to go look at 4910. Because I never used the working, I never used the working draft I always use my own copy. That I regenerate every day. All right, where were we? Class dot copy. Alright, there we go. It's paragraph 3. In in 4868. It probably also isn't in 4910.

>> Stephan: Yeah, as long as it hasn't changed recently, most time I was just suggesting citing a specific graph so that if we ever needed to look this up later, we could find exactly which paragraph we meant. So.

>> Casey: _First is. Alright, moving on. Next overload now this is the overload we're working on. Still sorry, this again returns the final value of the iterator from the loop. We don't need to return the final value of _Val because we're using. An lvalue that references the original value of _Val in the caller, tada! There so. We get first back from this _Iota_unchecked call. It's an rvalue, so we don't need to move it. We wrap it back up inside. The original iterator. Which we then return. In our out_result. iota_result<_It, _Ty> we're returning. The result of moving _First and _Ty, and the paper did want us to move. _Ty. Didn't it? Return move first move value. The other other overload for ranges. let's take some iota. It takes a range and a _Ty. There's not gonna be any wording for this in the paper or in the working draft. No, because again, we're lazy and we had like to have magical blanket wording. That means we don't have to repeat things over and over. So we have. Magic wording in the algorithms requirements again that say that range algorithms to take a range are equivalent to the taking the result of calling begin and end on the range and passing it to the iterator sentinel overload. So now we'll look at this and make sure that that's what it does. Luckily, we don't need the any kind of verification. The major advantage, one of the many advantages of ranges is that. They are correct by construction, right? Somebody passed in a range. We don't need to worry about mismatching begin and end. Units indicating where that range lies straight out of the range itself. So we're pulling first out. Of that range with ranges::begin. OK, yeah. Going out first. And then we're going to call the same _Iota_unchecked, with the result of unwrapping first. And calling, tada, _Uend range. _Uend is a magic accessor that basically does the unwrapping for us of getting the end of the range. It's sometimes more efficient. if for uh range types that are implemented specifically to have access to an unchecked end, which is the thing in our design. This will grab it directly instead of calling end and then unwrapping the iterator. It may be more efficient. So we're taking those. We're passing 3 arguments to _Iota_unchecked, which doesn't. We already know that it does. It returns the final value of first, which we wrap back up. Iterator that we have and we return the first move out just as we did on the other overload. So this is correct. It can be implemented a little more efficiently using _Rewrap_iterator. We have a helper. Lots and lots of helpers. This is probably in xutil. Yes.

>> Casey: _rewrap.

>> Nicole: You gotta turn off related matches.

>> Nicole: It is the. Dumbest feature so so frustrating.

>> Casey: I guess if you don't remember what you're looking for, it could be handy. You know, if it's something like this then then I might use that tool, but when I know exactly what I'm looking for there anyway, we have a utility called _Rewrap_iterator. That takes a range and an unwrapped iterator. And it will you either. Sorry if the unwrapped iterator type is the same as the wrapped iterator type. That's what this is trying to say. Right, if this unwrapped iterator type, _It is the same as the actual iterator type of the range. Then we don't need to do anything funny in rewrap, we just return it. If the unwrapped and wraps types are different, this meaning this is a range that has checked iterators. Then we'll go ahead and grab a new begin from the range. And we'll wrap up our. Unwrapped iterator inside that and return it. This is constrained to only work with forward ranges by necessity because you're only allowed to call begin once on a single pass range. Like calling begin on an input range or an output range can suck the magic smoke out of it and make you unable to call again on that again. Since this takes an. output_range _Rng. It may be single pass. And that means we can't really use _Rewrap_iterator. We don't have any facility for. Yeah, we're dealing with that. Unfortunately.

>> Stephan: So if we if we tried to it would but fail to compile, but only if our test coverage calls it with an actual output only range.

>> Stephan: Is that correct?

>> Casey: Yes.

>> Stephan: OK

>> Casey: yeah it will fail to compile but

>> Casey: only when called with a sub-forward. Single pass range.

>> Stephan: And to check my understanding because I I actually hadn't looked into this commentary, I was like, oh _Rewrap_iterator. That sounds good because I hadn't used it myself. Even in the case where we do have like a strong, you know forward range in this code, we need to start off by calling ranges begin and then unwrap it. I guess we could call _Ubegin,

>> Stephan: I suppose

>> Casey: Yes

>> Casey: We would call _Ubegin

>> Stephan: I see _Ubegin, OK,

>> Casey: checked right into. range wrap with the idea idea that it doesn't necessarily even need to keep first around if they're the same iterator types, for example.

>> Stephan: Right

>> Nicole: and not a use after move?

>> Nicole: I guess it's not. I guess _First is

>> Casey: technically it is a use after move, yes

>> Nicole: OK, but are we like asserting that this must be OK for anything that

>> Nicole: deals with our

>> Casey: it's an OK use after move

>> Nicole: OK

>> Casey: it's it's part of the design of the iterator unwrapping design that. _Seek_wrap. _Seek_wrapped could take can have a a moved from input iterator.

>> Nicole: OK cool.

>> Casey: OK

>> Stephan: yeah essentially the the wrap

>> Stephan: state has not been changed the like the pointer to the parent but the pointer to the element is what's getting totally reset here. Most I was wondering like I see what that would do for like a forward_list or a std::list for vector. Though it seems like we would actually be calling begin twice. Ohh no, not if we called _Ubegin to begin with. We would at most have one begin. OK, never mind, only the single pass thing is preventing this from being desirable.

>> Casey: Obviously you could sandwich something together with if constexpr here. But it's probably more trouble than it's worth. We're talking about a pretty minimal benefit in the first place. Let's go ahead and say I don't think it's worth. to if constexpr. And sub. Separately, I don't know spell that word. I'd leave this as-is. Oh, no. Somebody say something. Am I not? Am I dropping again?

>> Stephan: No, you're fine. It just looked like GitHub took a little second to respond there, possibly because you just pushed a comment with a typo oh no.

>> Casey: Because what I pushed a comment with a typo?

>> Stephan: Yeah, you're you're separately, you didn't. You didn't fix it before submitting. It's like my eyebrows twitching. I'm like no, never, never mind, it doesn't matter.

>> Casey: Uh. I spelled concepts correctly.

>> Casey: OK

>> Stephan: yeah, separately should be

>> Stephan: designed to be spelled correctly.

>> Casey: It took three seconds and I realized nobody had said anything for 10 seconds and thought that it was disconnecting it again. Anyone? OK, let's take deep breaths. Everything's fine. We are through iota. I should verify. This new endif comment matches. And if comment. if _HAS_CXX23 and __cpp_lib_concepts is defined. Yes. That's also correct, because this is a C++23 addition. And we don't want to define it that code and or test it when we're running, EDG in a test suite. Because EDG concept support is still not quite ready. For the STL, although it works well enough that it's been enabled in Intellisense. So Intellisense does see all the concepts code in the STL. OK. Moving on to algorithm. Same gaurd, which is again right for the same reasons. OK, let's slide down to. Again, the public interface. Definitions we've got the niebloid comment. you'll recall, so we don't need to worry about that. Where did the paper go? Shift left and shift right. Oh, this is weird. Whatever we used to write, the paper has kept the enormous margins on my narrow window. Which makes it pretty hard to read. Anyway, uh. This is the template. It takes. A first argument. Must satisfy permutable and the second must be a sentinel for the first. Which is exactly what this says. constexpr returning a subrange of the first parameter. shift_right. First template parameter named first. Second template parameter named last. And iter_difference_t Of the iterator type. All right, this person is using _Iter_diff_t which is an internal thing we had even before it was added in C++20. That does effectively the same thing, but by going through iterator traits in sub C++20 mode and by going through the actual iter_difference_t alias in C++20 mode. Yeah, I think if I recall. miscco had already commented on that. But I don't see it. Is this above? Yes. miscco commented the first occurrence and Stephan pointed out that there were several, so this is already taken care of alright? Somebody already caught the iter_difference_t issue. I won't come on it on it again. That probably came from copying our C++17. Implementations of these algorithms in the 1st place, at least that that name _Pos_to_shift seems really familiar to me.

>> Stephan: I'm glad that miscco caught it cause I probably would have missed that one. I do know enough about like remove_cv_t that if I see the ugly one being used in modern code I'm like ohh we can unconditionally is the modern one but with _Iter_diff_t I think if miscco hadn't noticed I probably would say yeah I know what that does that looks right and wouldn't have realized oh we should just unconditionally use the standard one there. So I'm very glad you noticed it.

>> Casey: It's correct right? It would have been correct. Again it does the same thing in C++20 mode it's just a readability problem only. You know it's uh look at the other. Template forward range. Requires that the iterator type is permutable. We're returning a borrowed subrange of that range shift_left. Takes the range argument by forwarding reference. And it also takes a range_difference_t which is spelled correctly here because we don't have another version of that. And at the same that parameter name _Pos_to_shift. So let's go ahead and look at what these are doing. This looks strangely similar to the iota thing in that it's. Checking the range right, doing the validation first of the range. And then. Auto result equals first. I'm sure that should mean something to me. Let's go back and find this. OK preconditions. Zero is true. Effects, if it is zero or it is greater than or equal to last minus first right if N is greater than a number of elements in the range. What that means. It does nothing. Hmm. Returns: define something called NEW_LAST. We return the {first, NEW_LAST} for the overloads in namespace ranges. So we need to make sure that this. Is the unmodified. First argument. OK. And we do that by making a copy. To rewrap alright, this is this is clear to me and we're making a copy the first we're unwrapping. There's no move here, so let's make sure this is. Yeah, Permutable refines forward. No, it's OK that we're not moving first when we pass it to get unwrapped. Which should leave it unmodified. And we're going to wrap the return value in this copy we've made called result. So hopefully with the return value from shift left unchecked is going to be. This NEW_LAST that the paper says it's calculating, which is the. Well, whenever that pointer, sorry, the iterator after the final element that was that contains a value that was in the original range, right? We're gonna ignore the the tail of elements after that that are going to be moved from when we shift all the elements to the left. So we checked this already, right? It's unwrapping first unwrapping last and passing _Pos_to_shift left unchecked, let's go take a look at that unchecked algorithm. Which I'm certain was defined above here. Is that against our style? Yeah, it takes an iterator and a Sentinel returns the iterator type. Doesn't need to modify the sentinel Again, this needs to be iter_difference_t And its behavior is. We're shifting by less than 0. We advance first to the end of the original range, and return it. And that is going to be first plus. The original number of elements in the range. Minus. Zero, right? If it is zero, then we that's number of elements minus zero. So NEW_LAST will actually be the iterator that corresponds to. The sentinel last. And that's what we're doing. We're advancing first until it's. equivalent to last and we're returning it. Otherwise, we want to start at first. believe that only equals zero, this is. Interesting. I think. I thought there was a change. To allow negative N with no effect. Or maybe the paper? Sorry, May actually maybe shift originally allowed negative N with no effect. And the change was to make it a precondition. You go look at what the standard says. Or the existing shift left of C++ 17 Yeah, precondition. So this was not an error in the context cited in the paper. That's what the paper says. So yeah, that must have originally allowed in negative values, and it was later changed by lwg issue, and I got the order. Mixed up in my memory. Alright, I I won't argue with Stephan's comment. This is reasonable. And if anything. If you do and I agree we should. The assertion should shift left itself. Should be in the caller instead of in this helper. Easier for users if we report errors inside something with a name that they called in their code. Which is probably obvious to Stephan and obvious to me, but may not be obvious to the person that wrote this, so we'll include that comment.

>> Stephan: We would need two assertions right for the Iterator Sentinel and the ranges form.

>> Stephan: I think. Is that right?

>> Casey: Yes.

>> Stephan: Did we do that elsewhere? Where we repeat the assertions in each public entry? Rather than centralized or does it? Has it not just come up with enough that we've got preconditions?

>> Casey: I think we'd usually do that. Yes, we usually apply preconditions as close as we can to users.

>> Stephan: OK, I couldn't remember, uh, what we do.

>> Casey: If we don't, we should fix it.

>> Stephan: I think I I think we may have some cases where we do centralized, but we're careful that the I think I recall the message will sometimes mention the the standard pretty name rather than the under score ugly name and say ranges::shift_left requires blah, even if it's being emitted within the internal helper. But I would need to go check to see what the actual precedent is.

>> Casey: I believe we should not do anything here except checking this. I can't see the code. Can't see the forest for the trees OK? We make a copy of first. If we have a sized sentinel. Recheck that positive shift if positive shift is greater than. Yeah, again, the entire length of the input range, and if so. We return first. Which is correct? Now do last would be, I lost the definition. I still looking at shift left. Now I'm looking at shift right. Alright, NEW_LAST is first plus the number of elements in the range minus n, OK. Except n caps. Effectively. At last, minus first. So if n is larger than last minus first. Then we return the NEW_LAST is just first, which would be the result of doing all this math. If this was. Max of N and last minus first. OK, so that's correct. If it's sized_sentinel_for if that's not greater, we advance _Start_at, _Pos_to_shift. skip over You take this copy of first and we skip over the the first N elements. Now that we know that N is somewhere within. The the range. This is gonna give us a a copy from the point right? We're gonna end up copying from here into first later on. OK, otherwise if we don't have a sized sentinel. We're going to start. We're going to. Index our way into the range manually instead of calling advance. Decrememnt _Pos_to_shift and for each decrement. We'll increment _Start_at But not if it's already at the end of the range. If it has hit the end of the range. We return first. Which we already decided was the right thing, right? If the shift count was greater than the length of the range, they should return first. This is just another way to do it. We try to avoid the other conditionals. And I've afflicted miscco with my hatred of multiple Blank lines, oh no He just doesn't like this blank line in between the If constexpr and the definition of the variable. I believe we should not do anything here except checking the distance via _Ranges_distance. If difference is less than 0. It's less than zero. We we have a problem. If it's zero this does nothing. Just familiarize yourself with debuggers. Usually we use an internal helper function for both implementations. Without the balance checks. But here the implementation might be simple enough to do it inline. All right, I'm not sure. Entirely what he's talking about. I do see. Wondering if we could use the three argument form of ranges::advance here? There's a form of ranges::advance that takes an iterator, a count, and a sentinel. It tries to advance the iterator count steps and stops if it reaches sentinel before. Going count steps. I think that's how I would do this. Because I could get start

>> Stephan: I wonder if it would result in the same behavior when you do reach that last, because here it looks like we need to return the first iterator if the user has asked for an unreasonably large pause to shift. But if we use the three Arg clamped version of ranges advance, I think we might not end up returning first. I could be wrong though. I haven't traced through all the logic. And with the miscco suggestion to use move unchecked, I also am not sure exactly what it means now that you've pointed it out. Yeah, because there's no like move unchecked in. We're trying to find the specific iterator in the middle. yeah, we do call it there, so I'm not sure what the suggestion is. Oh, and time check it has been one hour

>> Stephan: and 31 minutes

>> Casey: Oh we're at time check already

>> Casey: Oh, this is so much fun. OK. The nice thing about the three argument range is advanced is it returns. Uh, you know count that's leftover. So if there is a nonzero if it returns nonzero, we could return first. As we're advancing whatever is _Start_at, we will advance _Start_at by _Pos_to_shift towards last. So it would work here. I don't know if it's better or not without thinking about it, and we've run out of time for thinking about it. Unfortunately, so why don't we go ahead and knock off here? Yeah, it'll take at least another 15 minutes to finish shift left. So we're going to go ahead and stop, apologize for starting a little bit late. We might have been able to get to the end of it if we had that 5 minutes back. Sorry I haven't used this particular machine. I haven't driven here before, so I wasn't set up and prepared. Anyway, let's, uh go to questions. Are there any questions in the chat? Has everybody been asking?

>> Stephan: No outstanding questions, just some talk about, uh. Why are we using those nibloids and the std move optimization? So you, you've already covered everything.

>> Casey: Ohh, there's a suggestion from Cameron that we assign our suggestion. Our suggestion to him to implement move compiler running. Anyway, OK. Thank you all for coming. And I actually like the live question format better than people type things in chat and having to go back and get them later. It worked well. Yeah thanks. I will stop the recording now.