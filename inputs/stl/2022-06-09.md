>> Stephan: OK, hi and welcome back to another VC libraries, Open code review. Umm today we'll be looking at PR 1794. Use iterator concept in vector's range constructor. A PR from our contributor Adam Bucior. This is fixing an issue that we had filed by a user a little bit over a year ago. And this is about, Umm, constructing a std::vector from a range of iterators, so let me give you some background on how this works and then we can look at the issue and the PR itself. So here I'm opening up the latest draft copy of the C++ standard and let's go to containers, sequence containers and then vector. Let's just look at the class definition here. And zoom in. A little bit of a core language note when I say class definition that refers to the stuff starting from class here or template class all the way down to the closing brace semi colon. All the declarations of type defs and constructors and member functions and so forth. And the standard name for that is class definition. Even though most programmers would refer to that as a declaration, it's actually defining the class, and it's a layout because the data members are there and and so forth. Sometimes learning how the core language or compilers refer to things helps you understand how to read the standard itself. So vectors got a bunch of constructors, and of course member functions not quite as many as std::string. The one we're interested in looks like this here. So I can actually. Why don't we use compiler Explorer? I can maybe give a quick tour of how this works. Let's see, this should hopefully be big enough. OK, I don't want that compiler option for sure. OK, so we've got like a vector. Maybe I'll include some other examples here. List and iterator. And iostream. Yes. And maybe. A string OK, this is not quite sorted order. It's good enough. OK, so let's have our example. Have a print function. I'm just going to use a vector<int> because I don't really care about the element type here, but this of course applies to all elements. That's inspect everything in the vec. And print out that element. That's not going to work. This maybe just spaces. I'm here. OK. So we can have a vector of int I see. Let's start with the things I want to demonstrate. Are what if you have? One vector. Call this. Odd numbers 1, 3, 5, 7, 9, 11, 13, 15 and so forth. And I can just make temporary vectors when I print. So print what if we want to print a vector<int> construct from on odds.begin() + 2 odds.end() - 2, that is a thing that I can do OK. See if this all compiles. Hopefully this is big enough to see. Let me know. That's actually kind of tiny, maybe temporarily increased the zoom to 200 here. OK, hopefully this should be a little bit visible. OK, So what this code is doing? I start off with vector<int>. I'm going to call this one odds just contains a bunch of odd numbers. I can then construct temporary temporary vector<int> from a subrange of this other vector. I can say hey, I want to start at odds.begin() + 2, so skip those first two elements and I want to end at odds.end() - 2. So skip the last two elements so I should get 5, 7, 9 and 11, and indeed that is what's printed out, so we refer to this as vector range constructor because it's constructed from a range, possibly the entire range of some other container or array or some arbitrary subrange. In this case I'm using a subrange of another vector<int>, but I'm not limited to constructing from the exact same container type and the exact same element type. This would also work if this were a vector of short, so I can change this over to vector<short>. It will recompile and I still get 5, 7, 9 and 11, so I'm going to construct. My vector<int> from a subrange of vector<short>. Every short element in the original odds vector will be widened to an int element here. But again, I'm not restricted to the actual container type being the same. I could have a list of shorts so I could actually just change this in place to list and this will compile and this is no longer working because I said plus. So here I can use helper functions, there is next, which is a helper function in the iterator header that will advance an iterator by a given amount. It can also advance backwards so I can convert both of these to say next. The reason why is that random access iterators. Provide operator plus and operator minus, but bidirectional iterators don't because it would be too tempting to compile something and this has to be negative, not positive. Otherwise bad things will happen. There we go. OK, so I've successfully translated the code over to a list of short so I can take an arbitrary subrange, and in this case I'm grabbing from a bidirectional linked list, but I can give even weaker iterators, so if I have a. istringstream because I'm going to read from it. iss construct from and let's say 1,3,5,7,9, 11, 13, 15, 17. This case I don't want to do this subrange thing. But what if I have an istream_iterator? I can read shorts from this from iss and then the same type but empty braces for the end iterator. Let's see if I remember my iostreams and does this work if I not counted the correct number of braces. Apparently I have. I forgot to semi colon here. OK, that compiles and there we go. So here I have an istringstream iss that I have constructed from a string with a bunch of space separated odd numbers and I can use an istream_iterator to parse integers. In this case I'm saying I want to read short values from this istringstream until I run out of them and the end istream_iterator is a default constructed one or value constructed one, value initialized and this will indeed read all of the values as shorts. from the istringstring. So what's happening here is actually kind of interesting. I'm giving the vector<int> the weakest possible range of iterators. These are input iterators and as a refresher for those who are new to the stl iterator strength hierarchy for reading, you've got input iterators, and you've got forward. You've got bidirectional. You've got random access, and in C++20 you have something even stronger which are contiguous iterators. That are like pointers and vectors and string iterators and things like that. So if you have input iterators, the thing that you're giving up is the ability to make multiple passes over the input data, because as you're incrementing an istream_iterator, you're consuming information from that stringstream and as soon as you increment that istream_iterator, you can't go back and read previously obtained values. This is relevant to vector because for forward and stronger iterators, vector can do something cool it can say OK, because I can make multiple passes over this input data if I have a first iterator and a last iterator, I can determine the distance between them. If it's random access or better, I can just subtract them and get that distance in constant time if it's forward. Or bidirectional only I can increment from the first to the last count how many times I had to increment, and that's the number of elements, and then I can allocate exactly that much memory and I don't need to repeatedly resize. This is efficient, much better than repeatedly reallocating and transferring elements over, but if I'm constructed from an input only range like the case here, I don't know how many elements they're going to be attempting to find that would actually consume the elements, and I'm not ready to do that so. Here the vector is no choice but to repeatedly in place back elements and geometrically reallocate, which is efficient but not as efficient as allocating the whole size up front. So this is what we're going to be looking at today. So end of refresher, let's take a look at this issue which I have not memorized, so I'll be reading it. The user says the stl loses the iterator category when range iterators are passed to the vector constructor. Consider the following code. So here we have C++20 ranges with some namespace aliases. sr is std::ranges, rv is sr::views Two vector takes a random access range and gets the begin and end from it and then makes a std::vector of that value type. Then here we start with the std::vector using class template argument deduction. So this is a vector of int storing 1,2,3,4,5. We're passing this or piping it through a ranges views transform that takes every element of that vector. Here v means value, not vector really and then converts it to a float. So we are going to transform this range of ints to a range of floats and we should get a vector<float> out. So the user says currently STL containers, lack constructors accepting ranges. I think there's an upcoming paper. Or actually I think it's in our. Let me see Casey's in this meeting so he'll be able to correct me if I forget it. I'm thinking of ranges too. 1206 OK. OK, so we can look at the stl projects C++23 features. And I'm thinking of. Ohh is that this one here? Conversions of ranges to containers

>> Casey: [unintelligible]

>> Casey: of all because I've got it mostly implemented and I'm perennially

>> Casey: 5% away from getting it finished.

>> Stephan: Excellent. So we will be reviewing this at some point in the future, so there was machinery coming in C++23 that will make this even easier to do. I'll just bring up the paper here real quick. Conversions from ranges to containers. Surprisingly, a coauthor is Casey Carter. So thank you for looking at that. We don't have the paper yet, so that's why this user saying currently stl containers lack constructors accepting ranges. And so here the user says that we are calling eventually an internal machinery as indicated by these underscore capital ugly names. It's invoking vector's _Range_construct_or_tidy from input iterators. So we have lost the iterator category. The interesting thing here is that in C++98 through 17 we had only iterator categories. These were the input iterator tag, forward iterator tag, bidirectional iterator tag, random access iterator tag. in C++20 with the addition of ranges we gained iterator concept which is related to but different from the iterator category. In particular, you can express contiguous iterators with the iterator concept. I'm being a little bit vague here because I haven't completely memorized how all this stuff works. Eventually I'll learn how this stuff works, slowly internalizing it. I'm much more familiar with the old way of doing things, in C++17 and before, so the user has found a very valid issue here that we have something that should be pretty strong. We have a random access range, but vectors older implementation is only detecting these things as input iterators and using the fall back mechanism of calling in place back in a loop so it ends up being correct. It will correct in the sense of it actually does allocate the elements and we get everything transferred over, but it's less efficient than necessary. And then here, on the other hand, calling 2 vector and passing a correctly dispatches to the forward iterator tag version. So that is what Adam Bucior is fixing here. So let's take a look at the code. This is a relatively small change, only 64 additions, 17 deletions, so it's a relatively small tweak, but it is affecting the most important container in the entire STL, which I claim is vector and not string, so we need to be very careful about correctness, performance and all that stuff. Vector is surprisingly complicated, so I have merged main into this PR, so we're looking at the most modern context. We have recently thanks to our contributors almost completely overhauled the STL to use if constexpr instead of tag dispatch, so this code is much easier to read than it used to be years ago. So here we can see vector's range constructor. I hope that this is big enough. Yeah, I've used 150% for other reviews. Let me know if this looks too small. So vector's range constructor. were templated on arbitrary iterators. We've got a constraint here, expressed through enable_if that these things have to at least look like iterators. This is something that goes back to C++98 and has been refined since then. This helps this constructor avoid being ambiguous with vectors and copies of T constructor, because if you're constructing from like 5 copies of 1729, we don't want. iter to be deduced to be int. That would be bad. So this constraint says, hey, you at least need to kind of resemble an iterator. In particular, you can't be an arithmetic type or an integral type, so that's what that constraint is doing. And then at this point we're just templated on some arbitrary iterator type. We don't know how strong it is, so the code originally here was using one of our helper variable templates, saying if you're a forward iterator. Or better then we can take it the distance between these iterators. After doing our iterator unwrapping, which we'll do iterator checking and unwrap down to raw pointers if we recognize oh you're a vector or an iterator or something and we don't need to pay that checking cost over and over, so that's what that you first and you last are doing. So going back if we have a forward iterator or stronger, we can call std::distance, which is a generalized helper function that will subtract. If they are random access iterators or increment from first to last to count the number of elements between forward or bidirectional iterators. And once we have how many elements there are in the range, we can allocate that much memory and then construct from that range of elements. But in the old code, if we don't have forward or stronger iterators, we must be working with the weakest input iterators, in which case we need to repeatedly reallocate by calling in place in a loop. So that's what this code is doing, plus some iterator debugging stuff and. Tidying in case allocation fails for some reason because we are in the constructor. So what Adam Bucior is adding here is concepts powered logic. so #ifdef __cpp_lib_concepts will activate this only in C++20 and above when concepts are enabled as a separate unrelated thing that will eventually become just if has the C++20. As an aside and this says if we are not a classic forward iterator according to the iterator category, but if at compile time we meet the forward iterator concept, then we can do some cool stuff. So that's what this is doing. The question was raised when we first briefly looked at this during the maintainers meeting. Aren't these the same and they are not quite the same. There are iterators that meet the forward iterator concept that do not that aren't marked with the forward iterator category. Oh, Nicole, go ahead.

>> Nicole: Sorry, I'm I'm still sick.

>> Nicole: Uh, so that's why I sound terrible,

>> Nicole: but my point in the meeting

>> Nicole: yesterday was less, uh,

>> Nicole: aren't these the same and more?

>> Nicole: Uh, should _Is_fwd_iter_v uh,

>> Nicole: be like only done in old code.

>> Nicole: Given that I believe that forward iterator

>> Nicole: like encompasses _Is_fwd_iter_v?

>> Nicole: Does that make sense?

>> Stephan: Yeah, OK, so the question is not is it redundant but could we simply replace the old code path?

>> Nicole: Right. And like obviously we would need to

>> Nicole: like do an ifdef and then and else,

>> Nicole: but in theory it's.

>> Nicole: Reasonable,

>> Nicole: I think everything that is a forward iterator

>> Nicole: in C++ or C++17 classic forward iterator,

>> Nicole: whatever is also a forward

>> Nicole: iterator in the new ranges world.

>> Nicole: I might be wrong though Casey.

>> Stephan: Yeah, I'll let. I'll let Casey comment there. My initial reaction is that I think we may need to worry about iterators that essentially lie and they're tagged with _Is_fwd_iter_v without, um not technically meeting the requirements. In particular, I think Casey mentioned. Uh, that the forward iterator concept. Let see the forward iterator concept allows iterators that don't return true references. The classic forward iterator tag or category technically does require true references, but there are types like I think regex iterators. That don't really meet the requirements, but they claim to be forward iterators anyway, and this code actually works, so I would be worried about. Affecting the behavior of existing code, but I'll let Casey comment how close. How close did we get? Casey may have stepped away from his computer, so that's OK,

>> Casey: Sorry. I'm I'm here. I I didn't.

>> Casey: I was muted. Apologies.

>> Casey: I think all actual things that comply

>> Casey: with CPP 17 forward iterator will

>> Casey: actually satisfy the forward iter concept,

>> Casey: and I did just look at this.

>> Casey: Right like moments ago because I was

>> Casey: trying to make sure that it was kosher

>> Casey: for us to check forward iterator on

>> Casey: things that were CPP 17 input iterators,

>> Casey: which it is because yeah,

>> Casey: we checked that they've opted in

>> Casey: by the iter concept value first,

>> Casey: so it's clean.

>> Casey: We can do this under as if and I

>> Casey: actually had that concern with this PR,

>> Casey: but it's fine.

>> Casey: so the question now can we get

>> Casey: rid of the old path and you are

>> Casey: right that there are broken iterator

>> Casey: types that will use the old path.

>> Casey: Still that wouldn't make the new path.

>> Stephan: OK, so in an ideal world we could do Nicole's suggests and just use forward iterator concept for C++20 and above but old code broken code would possibly some in the standard itself would interfere with that. So here because vector is so central. I think this approach is good as is we could potentially in the future explore. OK like how many iterators would be broken by such a change. But I think that being noninvasive is probably the right approach here, because this PR as it stands, is only trying to improve performance. If we tried to replace this old code path, the advantage would be perhaps a little bit of throughput that we wouldn't need to test this additional condition, but this should be quite cheap to check. And if we did eliminate this and start changing behavior for broken iterators, then this would become more impactful. So I'm inclined to leave this code as is in the PR and simply add the additional else if constexpr under __cpp_lib_concepts. But I'm definitely. I'm interesting to look at. OK, I see Nicole's giving us thumbs up. OK, so we're returning back to this code if we have __cpp_lib_concepts then we can chain in an additional else if constexpr and if we meet the forward iterator concept then we can essentially do what we did before. We're also going to have const auto _Count except instead of calling std::distance we're gonna call ranges distance since that will be capable of handling forward iterator. Here we do have an assumption that. And this is very similar to the original code that if the incoming user defined iter meets the forward iterator concept, then surely we can call ranges distance on the unwrapped form. And I believe that holds because we control the unwrapping machinery and essentially if an iterator participates in the unwrapping scheme then the unwrapped version needs to be at least as strong as the user defined wrapped iterator coming in, so that looks fine. This calls ranges distance and then whatever that is. That in general will be something like a ptrdiff_t or a signed type. But what we do is if the iterators have passed our check. Our ADL verify range then we don't want to sign type. We know that it's non negative so we should be able to static cast to size_t and then we've got a helper function convert size that will potentially narrow it down to the allocators size type. Casey, go ahead.

>> Casey: We can't static cast the results of

>> Casey: ranges distance to size_t without

>> Casey: possibly losing information.

>> Stephan: Since, like the iota with 128 bit

>> Stephan: or whatever stuff,

>> Casey: yes

>> Casey: there it's possible that ranges have

>> Casey: integer class type for their size type,

>> Casey: which has values that aren't

>> Casey: representable by size_t,

>> Casey: and we'll be modulating the information

>> Casey: away and that would be bad.

>> Casey: So what we need to do here is instead

>> Casey: of static casting the size_t,

>> Casey: we need to use _To_unsigned_like.

>> Casey: Internal helper function

>> Stephan: Let's see if I can find that I do have my. Enlistment here or repo. OK so you said _To_unsigned_like_t?

>> Casey: No t

>> Stephan: I didn't get it right.

>> Stephan: Oh, no t. There we go. _To_unsigned_like OK,

>> Stephan: that lives in xutility.

>> Casey: lives in xutility.

>> Stephan: Yeah, OK, great. And this is is this only suit? Yeah, this is clearly concepts lands, so we shouldn't be using this in old code. But we should use it a new code. OK, that's 476 ish. OK let me get the citation here. stl, inc, xutility, _To_unsigned_like, hit Y for permalink. OK, and I'll copy the whole thing. OK, this is. It is mostly, no. I shouldn't say, mostly, UM. This would be observable because if I have let me see if I can get the right scenario here. If I have one of those iota views where I am going iota from some enormous range, UM. What would that be that would be? I have to be able to get something that's bigger than 64 bit, right? Oh no, it would be. It would be like iota view of here we go. Iota view of unsigned long long on a 32 bit system. I can totally do that here. The range of distance would be like a 64 bit distance or something static cast to size T would be modular. So even though I can't really represent over 32 bits physically in memory iota view can make 64 bit stuff. Did Nicole did you have your hand up briefly?

>> Nicole: Ohh yeah, I was just gonna say,

>> Nicole: I assume that the convert size throws a.

>> Nicole: Throws an exception if the thing is too big.

>> Nicole: Why this is good?

>> Nicole: Like the basically what what?

>> Nicole: What will happen in the modulo case is?

>> Nicole: You'll get a

>> Nicole: bad codegen where or bad code where you like.

>> Nicole: Create, uh? Uh.

>> Nicole: Create a thing that's like if you have

>> Nicole: a range from zero to two to the uh,

>> Nicole: 33 you create a range of zero and then

>> Nicole: construct n into that range of 0.

>> Nicole: Which is obviously broken.

>> Stephan: Yeah

>> Nicole: and what you want is

>> Nicole: that the this is too big.

>> Nicole: My question is, isn't this broken

>> Nicole: in the other code as well?

>> Nicole: Like my understanding is that std::distance

>> Nicole: On something similar to an iota of

>> Nicole: you could still exist in C++17.

>> Nicole: I guess. I guess it wouldn't be a.

>> Nicole: It wouldn't be a forward iterator range,

>> Nicole: though it would be an input iterator.

>> Nicole:Never mind, right.

>> Casey: Right, it wouldn't.

>> Casey: We're protected by the fact that this

>> Casey: is for working on forward iterators,

>> Casey: and they have to refer to

>> Casey: actual objects in memory,

>> Casey: so we're basically guaranteed

>> Casey: that no forward range is has a

>> Casey: distance longer than size_t, right?

>> Stephan: OK so I'm looking at convert size convert size expects its input to be whoops input to be size_t and then this is really intended to handle what if I'm in like X64 so size_t 64 bit But I've got some 32 bits something allocator. Then I need to convert down to the allocator size type that could overflow, so that's what this check is doing. But if the allocator size type is size_t, this just becomes a no op, so that's what convert size does, so we should be using _To_unsigned_like here. And then. Going down to convert size, do we need like a handwritten check basically? Because the input still may not be size type. Let me bring up the _To_unsigned_like that was here and then close some of these. The bug OK, this just converts over to the unsigned counterpart. But then we still need to get to. We never want to accidentally truncate, so I think we need a handwritten check. Is that right? Essentially doing what convert size is doing, but handwritten?

>> Casey: I just pasted convert size from my P1206 branch

>> Casey: into the chat.

>> Stephan: OK, you've got.

>> Stephan: You've got just the right code.

>> Casey: which does the right thing. There's your code, I cannot read it because the chat is literally like 10 characters wide, which is frustrating. It's on my other screen, which is why you can't see it on the the view. OK, so you've generalized in your code. Convert size to handle this.

>> Casey: Yes

>> Stephan: That's interesting. OK, so for this PR.

>> Casey: So yeah, I can get a link if you want a link ```suggestion

>> Casey: But yeah, this PR is going to need to.

>> Casey: We need that that convert size

>> Casey: change one way or another,

>> Casey: so maybe with this we should

>> Casey: hold this up until applying P1206

>> Stephan: The other thing we could do is we could just say this is a corner case for like iota views. Merge this as is and then patch it up in 1206. I would be OK with that if this is sufficiently obscure because it is really quite extreme. It's something that only happens with extremely large iota views, which hopefully I mean. On the other hand it is vector if you don't want to.

>> Casey: Or user-defined range types. They can define their own range types that use or size so. Yeah, Nicole's questioning the chat. Does MSVC support 32 bit protected mode segmentation? I believe the answer is no. We always have flat memory models for all of our platforms, so we don't I think have to worry about things like that. OK, so thinking range's distance is returning some sign type we can use. _To_unsigned_like to get to the unsigned counterpart, but then we need to worry about getting down to the size type. I guess the other thing is we could use a handwritten check here to be strictly correct and then replace that with Casey's new function in 1206, and have his PR do that and after that everything is fine here. I think I might be. I might suggest that. Yeah, actually Casey can you. Can you send the link so I can at least bring it up on the screen so I can show our viewers and the recording what we're talking about. OK, that'll be faster than navigating there. I think I think probably that may be the best approach just so we never have a even a short time in Microsoft STL main that is doing the wrong thing when we know what the right thing is to do. I'm OK, so we do need to mention unsigned like. Let's see if I can capture the entire discussion. In the UM? Original _Is_fwd_iter_v code path. We're guaranteed to be looking at, uh, real elements. Or looking at UM? We're guaranteed that the source range consists of real references to memory so the distance will always fit in size_t. However in the new forward iterator code path. The. Let me say std::distance here to be clear the ranges distance might be larger than size_t, for example, iota_view. For example, a 64 bit iota_view on a 32 bit architecture. Uhm? The static_cast<size_t> might therefore truncate. OK. We need. 2 steps here. OK, Casey's got the link and then Nicole asks, are we concerned about broken iterator types, IE stashing iterators? I think what the concept? Iterators are really they. Even if they were tending to like lie with the original categories when they satisfy the concept, we should. Ohh, the question is for the non concept code. There it's like we grudgingly tolerate them. Generally we will knockout go out of our way to try to make stuff work, but if the natural loop happens to work with broken iterators, then we accept them. Which is why they they end up working like regex iterators they will, I think work with this even though they return values from inside themselves because we don't do something like grab a reference from an iterator, increment it and then try to use the original reference, even if that technically should work according to the iterator strength requirements. The vector has no reason to do that, so users get away with such stashing iterators. Which is weird, but it works. OK, so we need to steps here first is. The _To_unsigned_like. OK. Um. 1) Call _To_unsigned_like to convert the signed distance type to its unsigned counterpart. And then 2) Convert. That unsigned like type to the allocators size type. Which might need to throw a length error. Uhm? Casey Carter's branch for what's the the issue number I should have? Shouldn't have closed it?

>> Stephan: The projects classic.

>> Casey: I can tell

>> Casey: you the proposal number.

>> Stephan: OK. 2532

>> Stephan: Contains such. Machinery. Yeah, that will cite. This here I see just static assert, some basic things that they have to be unsigned, and then if it's too big. Yeah, so would you recommend? Since you copy pasting this or just doing the if constexpr,

>> Casey: yeah that would be fine.

>> Casey: If they go ahead and steal this.

>> Casey: into that PR.

>> Stephan: OK

>> Casey: Yeah benign merge conflict.

>> Stephan: OK Casey Carter recommends just copying that function into your. into this PR and. Which, will result in a trivial merge conflict to deal with later. OK, let's preview this. If it looks right. OK, in the original _Is_fwd_iter_v code path. We're guaranteed that the source range consists of real references to memory, so the std::distance will always fit in size_t. However, in the new forward iterator code path, the range's distance might be larger than size_t, for example, 64 bit iota_view on a 32 bit architecture. The static_cast<size_t> might therefore truncate. We need 2 steps here, one called _To_unsigned_like to convert the signed distance type to its unsigned counterpart to convert that unsigned like type to the allocator size type, which might need to throw a length error. Casey Carter's branch for conversions from ranges to containers contains such machinery. Oh, we don't get the auto preview because it's just some random branch rather than our own. OK, but we got the citation.

>> Casey: That's unfortunate... I hit y to make sure it was a permalink

>> Stephan: yeah, the fork is not... the repo itself. Yeah, Casey recommends just copying the function to this PR, which will result in a trivial merge conflict to deal with later. OK, yeah, I'd be fine with that. And you added this to what? xmemory, yeah, good enough.

>> Casey: It's already in xmemory, right

>> Casey: I've just updated the implementation

>> Casey: of convert size.

>> Stephan: Oh I see. OK yeah, because you're linked to the branch and not to the diff. OK, cool. OK, we got a first comment here, great. Now onward. And that's about. It's about it. This it doesn't duplicate the construct in line. There's no good way to really avoid that. It's just one line. Yep, that's good. OK and then. This here is being. Changed from tag dispatch to if constexpr. Where's that happening? That's happening down here, OK. We're essentially if constexpr dispatching, because we are still calling a helper function. How big are these helper functions? They're pretty big. Having them separate is fine. OK, so previously we overloaded insert range and internal private ugly helper function with input iterator tag. Now it's being renamed to _Insert_input_range. I like that if we don't need to distinguish an overload resolution having a different name makes it clear what's happening. No ABI concerns or anything. OK, so that's good, same forward range but the forward range one is being enhanced. Previously we always just used up this going to need the same thing. We always used to take the distance because we're inserting instead of constructing. Take the distance and convert over. Now we have two code paths. We're going to definitely initialize a size type. Count, so that's not changing. It's definitely initialized, so it's OK for it to be uninitialized here. If we're in cpp lib concepts mode ifdef, then if we're forward iterator concept, then this is the code that we'll need to change accordingly. Otherwise, do the classic thing. Which is not changing at all. OK, how many occurrences of this? I'll just say Ditto below. I'll just say occurs below cause it clearly does occur several times. Edit. Occurs below for insertion, et cetera. OK yeah, once we get those helper functions, each line will be quite systematic so it should end up being a pretty small change. OK. Next I was wondering, should we request test coverage for that? It definitely is going to throw an exception. I think asking for test coverage is reasonable because this is a should be pretty easy to test, you just make a 60. Well, it's easy to test on 32 bit architectures on 64 bit architectures it's annoying. OK, now I'm less inclined to ask for test coverage. OK, I think just inspecting the coach should be fine. I am lazy that way. OK, so returning to the insert forward range if the concepts end of concepts if forward iterator. Then we activate the new stuff. Otherwise, we already know we satisfy the original forward iterator tag. OK, that looks good, and this avoids repeating the code. Yep, that's our usual convention, OK then. This is the call site in insert some iterator or insert where and then an arbitrary iterator range. Previously all we always just called insert range. But we tag dispatched here. And now we're going to have a bool. And then use if constexpr to switch between them. OK, so ifdef __cpp_lib_concepts above yes below no and if no OK constexpr bool _Is_fwd If we either meet the classic _Is_fwd_iter_v or we meet the forward iterator concepts. So this ensures if you met the classic requirement we will still activate it. This is safe. I like this. If we don't have concepts then only check _Is_fwd_iter_v OK, I see no good way to extract this or anything other than like a horrible putting or is forward iterator and concepts. It's fine to just repeat the _Is_fwd line like this. This is more readable anyways. So then, if constexpr (_Is_fwd) then call the forward range, otherwise call input range. We have not. This doesn't result in multiple lines. There's no reason to ask like extract these in any variables. It's fine to just repeat it and wrap first and last. It's fine then, otherwise make iterator offset OK. That's good, same transformation being applied to assign where we're saying. Just replace the entire vector with this range, assign input range, assign forward range. OK stuff's happening here. This looks horrible because the white space change let me turn on ignore white space. Come back to assign forward range. That should look better. Indeed, it looks much better. OK, so assign forward range no longer taking the tag again, we're going to have a size type new size that's going to definitely be initialized here. Yeah Nicole

>> Nicole: sorry I was just wanted to say it seems.

>> Nicole: I mean. Maybe I'm. Over.

>> Nicole: I don't know, uh, but I think it

>> Nicole: might be nice if this was just one

>> Nicole: function assign range and then we if

>> Nicole: constexpr it in assign range.

>> Nicole: So as well as insert range so that

>> Nicole: we don't have this _Is_fwd copied

>> Nicole: across all of these different places.

>> Stephan: Um. So you're suggesting fuse assign

>> Stephan: forward range and assign input range

>> Stephan: into the caller or something larger?

>> Nicole: Like Fuse, assign forward range and

>> Nicole: assign range together uh and then

>> Nicole: in the caller you can just call

>> Nicole: assign range and it's fine. Uh, I I.

>> Nicole: I don't know if that's good, that's bad.

>> Nicole: That's just something that I

>> Nicole: like saw and I was like, uh,

>> Nicole: that seems like it would be good to do.

>> Stephan: Yeah, that was that was something I asked very briefly when I saw this for the insert. Basically, if we're using if constexpr, why do we still need separate functions here, given that there's only one caller? And I think that these are large. That's the thing. Like insert forward range. It's a large function, it's doing a lot of work.

>> Nicole: That's a very good point.

>> Nicole: I did not notice how big that function was.

>> Stephan: Yeah,

>> Nicole: Never mind I take it back

>> Stephan: the context is hiding a lot

>> Stephan: Yeah, there's a little bit of duplication where like it sets up my data and stuff, but I think it would be in general harder to read that way. OK, but it is something to think about. If these functions were substantially smaller or if they had more useful duplication that could be extracted, there would be an argument for fully inlining them. And that is something we can do in the future.

>> Casey: I appreciate if we keep them separate.

>> Casey: Because I need to reuse them in

>> Casey: other new overloads for P1206.

>> Stephan: AH OK, that's definitely an argument to keep them separate. Yeah, Casey says merge conflicts. Merge conflicts everywhere. I have some cleanup to do well that lives up to your nickname. Back when we installed offices, you and Billy had so you were constantly working on code making so many cool improvements, but you're constantly merge conflicting. So I put a little post notes over your names on your door saying Billy merge O'Neill. And Casey conflict Carter. So there you go. Merge conflicts everywhere. OK, so we were in assign forward range I was checking in the new size. This is a size type new size so the type is the same one. If I see code being transformed like this I want to make sure we're not changing the types of variables or things like that. It's always going to be initialized ifdef concepts. Then here. if constexpr(forward_iterator<_Iter>) OK, same pattern as before. Then again, this convert size will need to be changed ranges distance, and that's all good. Otherwise exactly the same as before. Yep. And then the caller ifdef concepts constexpr bool _Is_fwd This has occurred twice. If it occurred many more times, there would be an argument for extracting this into a variable template. If we could find like a good name with only two occurrences, even though this is somewhat verbose, I'm OK with this as is usually my rules. Like once we see something repeated three times, that's an argument to extract 2 times is not quite enough. If extracting would be annoying. The argument there would be. Yeah, we'd loot the one. The one thing if does. I'm OK with this one more time. I would ask for it to be lifted out. OK, so if _Is_fwd_iter_v otherwise or if it meets the forward_iterator concept. So again this is being very cautious about not disrupting existing code. All the comments are good then if it is forward to assign forward range with unwrapped, otherwise assign input range unwrapped. OK, that looks good. Uhm? Oh, and here's the reason to have the separate functions for assign, because we do. Call the forward one only for init list, so having a separate function to call is very nice for input, the arguments for Casey's code, which is coming aside forward range of begin and end aside forward range because we know. Yeah, it's definitely random access. OK, that looks good. Product code. Aside from the conversion of the size looks great. OK, viewed. Test code. Test code is tiny, excellent. Fancy pointers. We need to change this slightly because let's see if I can intuit why. The concept for the range is probably inspecting operator plus plus and with this fancy pointer we were like, OK, we really never want to post increment. That's why it was being deleted. Here. We actually do need to provide it to meet the concept so. We're just going to provide the basic implementation operator++ returns by value. Result is deref this. Bringing our Rep OK, that's the variable. Restoring and then return the result by value the old result. Yep, that looks good. Sometimes this is written as like plus plus deref this but just directly saying plus plus Rep is fine and more efficient. Not that efficiency matters for this test. Or sorry.

>> Casey: Go ahead and suggest it's possible that we

>> Casey: can have these explode on instantiation.

>> Casey: On if if we make these explode when

>> Casey: the function body is instantiated,

>> Casey: we might be able to still satisfy the

>> Casey: concepts by having the right declarations,

>> Casey: but also achieve the same end of ensuring

>> Casey: that our our implementation doesn't

>> Casey: use these by having them how about?

>> Stephan: How about just an assert false?

>> Stephan: Or would you want like a static

>> Stephan: assert of blah blah?

>> Casey: Yeah, static assert always false what I was thinking

>> Stephan: OK, is this thing templated? It is indeed. And let's say oh, it's a compile only test so hi wouldn't get us very far.

>> Casey: So if it's a compiler test,

>> Casey: these probably don't need to

>> Casey: have function bodies.

>> Stephan: Oh yeah, just semi-colons right

>> Stephan: actually, none of these really need, and they're not constexpr, so we couldn't be evaluated. Yeah, I wonder why we went to the. To bother. Yeah, because we're not actually going to execute code. The internal test harness we'll try to run the empty main, but in no event will any of this stuff be instantiated. Yeah, why do we go to all this effort? So would you still want the static asserts to make sure that we're not actually instantiating this stuff?

>> Casey:Yeah, it would be nice.

>> Stephan: OK.

>> Stephan: UM? OK, I will add first check. Yeah predac. OK, that's all good. OK. See. Although. Post increment and post decrement need to exist in order to satisfy the concept. Umm? Casey Carter notes that we'd still like to avoid actually using these operations. In the product code. It should be sufficient to add a static assert Ohh Casey remarks we do need bodies since the internal test runner links compile only tests. Yeah, this would attempt to link. If it if we instantiate code that calls fancy pointer stuff, they need to link to the function. Bodies do need to exist, but Casey knows they don't need to do actually useful work here. It's reasonable to provide useful work anyways. It should be sufficient to add a static assert. Should we just use the internal always false or? Should we recommend anything specific here?

>> Casey: I'm pretty sure we do use

>> Casey: it in test somewhere else.

>> Stephan: We can check

>> Casey: so it would be consistently

>> Casey: wrong.

>> Casey: Or do we always define... I know there's one in

>> Stephan: No, we don't

>> Casey: algorithm support.

>> Casey: We always define the local one.

>> Stephan: Yeah, we define a local always false in yeah, the algo support. Or null forward iterators. This is the classic type I guess the. constexpr bool always_false = false; is  the cooler one to depict. When I show that range algorithm support test include. tests, std, include. range algorithm support background here For those who are unfamiliar with this fun bit of standardese is that if you just say static assert false in a template, the compiler is permitted to say ha, that will never compile and just fill your compile dead, which is not what you want you. You basically always want a static assert false to be enforced on demand when The thing is actually instantiated. I believe there's work in the committee happening right now to actually make that a reality, which will be awesome so that we don't need to define these inline constexpr bools all the time. Hopefully that might even be applied as defect report one could hope. OK, so let's recommend this. It should be sufficient to add a static assert with an always false helper. Then this would fail to compile if any product code attempted to instantiate operator or post increment. Post meowcrement but the function signatures will still be visible for the purpose of the concepts. OK, how does this look? Casey notes it is P2593, allowing static assert false. I can show that. Link P2593. Yeah, allowing static_assert(false) by Barry Revzin, who has proposed other awesome standard features like constexpr bool, sorry explicit bool which is an incredible help in tuple and pair and things like that. So thank you Barry for that paper. OK so although post increment and post decrement need to exist in order to satisfy the concept, Casey notes that we'd still like to avoid actually using these operations in the product code. It should be sufficient to add a static. assert with an always false helper blah, then this would fail to compile if any product code attempted to instantiate postmeowcrement, but the function signatures will still be visible for the purpose of the concepts. OK. Cameron notes I can hear John John Caves. I presume, crying over the paper because he did so much compiler work to ensure we error. Check nondependent static assert false cases. Yeah, the compiler went to so much effort and then we're just gonna wash it all away. OK, and that's the only product code change needed, because this is a performance change. We have existing code that already exercises vector of input iterator forward iterator. I wonder if we should ask for test coverage to exercise the new code path, not necessarily the check here, but just the essentially along the lines of the original code, just to make sure we're instantiating, I think I would want to see that. Because if the danger is always. What about stealth build breaks where we do something that looks like it compiles, but the moment you instantiated it fails. Where's a good test to add that? It would be ranges, but is there a good ranges test where? ranges transform maybe? because the original code involved to transform. Yeah. Even yeah, even something very very similar to this, you know, slightly cleaned up. Would be reasonable. OK, so that would that be ranges algo transform. Let's see if we can find that test

>> Casey: p0896 ranges algo transform, yeah?

>> Stephan: There are two. There is unary and binary. This would be the unary 1. And we do use what views? Oh, we don't test the view here. Here we just say std::transform or something. Can't type transform. Here we're just calling we're we're not using the view. Is there a separate test for the views?

>> Casey: You mean the transform view?

>> Stephan: Yeah, the transform view.

>> Casey:it would be 0896R4

>> Casey: views transform

>> Stephan: views transform OK,

>> Stephan: that's the one I wanted because in this case it's is it the view that spits out the iterator that we care about. Because if we just run it through the. Function object ish thing that actually does the transform. It doesn't doesn't emit iterators. Or am I completely confused?

>> Casey: We we want to use views transform

>> Casey: the function object to this thing

>> Casey:and it will pick the proper

>> Stephan: yeah

>> Casey: specialization of transform view.

>> Stephan: OK, but the other one. The ranges transform that wouldn't

>> Stephan: be what we want, right?

>> Casey: Right

>> Casey: that's just an algorithm.

>> Stephan: Yeah, OK, yeah, just that would actually physically do the transformation in place right? Not not emit the view. OK, so this is the one we want to ask for. Basically yeah, just depend to the test. Yeah, just add to main. Yeah, I think this is a good ask for. OK so. I'll just link main here. Maybe permalink hit Y there is the main. OK, and where's a good place to ask? Maybe just at the test. I really want the ability to like add comments that are not attached to any specific line. I guess the product code too. Yeah cause it's not specific tests. I'll add it to the end of the product code. OK. Umm? It would be good to add a small amount of test coverage to exercise these new code paths I'd recommend. Adding. This to. The end of main in. Views transform. And let's cite AlexBAV's code here. It should be sufficient to use code like. The. Like the original report. Like the original test case in. 1709 but also. Calling was it? Covering the constructor, insert  and assign Honestly, if they're like instantiated, that's good enough for me. Probably just checking that the values that are value gets into the vector is good enough. Uhm Asserting that one. Element. Asserting that one element is successfully transformed each time should be sufficient to. Verify that we've. Successfully. Stored elements in the vector. OK, it would be good to add a small amount of test coverage to exercise these new code paths. I'd recommend adding this to the end of main in views transform blob. It should be sufficient to use code like the original test case in 1709 covering the constructor, insert and assign asserting that one element is successfully transformed each time should be sufficient to verify that we've successfully stored elements in the vector. I mean, maybe add the rationale. This will ensure. That there are no stealth build breaks compiler warnings. Or compiler bugs always got to worry about the compiler bugs with this advanced concept stuff. And the new. This will ensure that there are no stealth build breaks, compiler warnings, or compiler bugs in the new code. Yeah, just a good habit to get into that. Try to instantiate all the new stuff that you write, because even if like 99% of the time it works 1% of time. Oh, there's a compiler bug that nobody would have thought of. Or oh, we forgot to assign. Not usually that bad these days, but a compiler warning like truncation or whatever. Very easy to encounter. So a little bit of test coverage would be good. OK, so three comments 1) dealing with the size, 2) add a little bit of test coverage. 3) add the static assert. Otherwise this looks good to go. I like it. OK, so I think we can mark all this as viewed. And this is changes requested. This is close enough that we could even just push changes. And move it forward. I think I know exactly what I want to see here. I could just push changes and that way. Expedite this for merging because I think this should be ready to merge once these changes are made. This is one of our older PRs. We're really trying to clear the the PR backlog. I think I'll do that when changes need more when they're more open ended, and we're not sure exactly what should be done. Giving the contributor chance to read the feedback and think about how they like to handle it is good. But these are so targeted now mostly pretty tiny. This PR is really high quality. I think I can just go ahead and push changes so I will hold off and actually submitting this. I'll make the changes. I'll push it and then speed this forward to final review later and then this should be actually possibly even ready to go in the next batch of PRs that we merge. So I think that does it for this review. Are there any other questions I don't haven't seen any accumulated in the the chat? I think we were able to look at a bunch of cool stuff in vector. And I've learned some things about how the concepts world works as well, slowly catching up to all the stuff that they've added in C++20 and now 23. So. OK. Cameron says my first question isn't directly related to this PR. It's OK if something comes up that makes you wonder what's going on. Then it is cool to talk about. Oh, here we go. Here's the question. Cameron asks. So you noted earlier that the STL is greatly favoring if constexpr as the method of dispatching versus tag dispatch. There's an implied behavior change here, and that is that the old tag dispatch behavior worked by best match. Well, if constexpr works by first match has the STL observed this behavior changed? It's an excellent question, so Cameron is asking is that let me see if I can maybe just sketch something. I will actually try to compile it. So. If you have something like uhm. Let's add some template stuff so it's vaguely realistic template type name. Iter void helper taking Iter, it and then. input iterator tag that's then going to do stuff. Like this? And then replicate several different ways. Forward. Bidirectional. And random access something like this versus the new World order of template type name iter. void do_stuff taking the iter it, and then we would have if constexpr and I can actually bring up the definition of _Is_fwd_iter_v because this is not what one would always expect. UM, where do we define it? xutility, we ask, is_convertible and not is_base_of because is_base_of will return true even for things that are ambiguous, is_convertible as essentially very similar to what we were doing with tag dispatch. So if we were to hand write this. This is a course also an internal helper. I can show the definition of that _Iter_cat_t Is not actually referencing my favorite animal, but it's asking what is the iterator category. So if we were to fully expand this thing out. Do a little bit of copy pasting here make this somewhat realistic. OK like that. And I can actually look this out. We could let's make this fully realistic, so. Do a little copy pasting. Yeah, looks good. Multi cursor editing. I love it. OK. This last one is really an implied else, so we can go like this. OK, so Cameron's question is, there's an implied behavior change here when you had. Let me show the new stuff too. This is old. This is new. Helper of iter and category brace brace. Just make A tag type or object of that tag type versus the new way of doing things. So in the old way we're asking the compiler hey, do overload resolution. We're going to give you an object of this tag type and choose the best match here. Sometimes this could even involve a conversion, for example in the vector case we only care about. Are you input only or are you stronger than forward? So if you have a random access iterator tag and these let me comment these out. If categories are random access iterator tag, you would need a conversion to call both of these. But thanks to the core language, which is awesome. The conversion from random access iterator tag to its base class forward iterator tag is better, meaning less severe than the conversion all the way up to its even higher base class input iterator tag. So this is more preferred if you have an random access. iterator, which is exactly the behavior that we want, so that overload resolution is happening all at once in some sense. But if you have if constexpr now, you have essentially classic control flow, you can control the order in which things are tested. Here we test random access iterator. 1st and so forth. But if we had done this the other way, I mean, just reverse this for the sake of exposition. This would not have the same effect if we test bidirectional first, this would activate and absorb random access iterators and we would never get a chance for this to be correct. So to answer Cameron's question, have we ever observed a behavior change here? The answer is no, because we have always been very careful when transforming old tag dispatch to new if constexpr. We're very careful to test things in the correct order. Not this order, but the original order where we test the most specific thing first and then gradually test to more and more general things, which exactly replicates the behavior that we wanted from the old tag dispatch. Essentially the what the STL does, although we could do a lot of things with tag dispatch, we generally only do two things. The most one of the most popular is testing on iterator strength, where iterators fall into this. Power hierarchy and we can test from strongest to weakest or we all. We have a lot of yes, no tests like is this thing a map versus a set? Is it trivial or not? Is it copy constructible or not? Only occasionally do we have something even more complicated like think I think one of the most complicated ones I can think of is a vector reallocation where we need a three part test. Are you noexcept movable? If you're not, are you copy constructible? If you're not, well, then you're throw movable and we'll just move you and hope there's no exceptions. And so in that one actually, if constexpr is much more natural because we do want that sequencing compared to tag dispatch where we had to sort of enforce sequencing with a specific pattern of true false and true type and false type parameters. So it is something to keep in mind. But if constexpr is actually completely fine, as long as we're careful about the order in which things are tested. Really, it hasn't really been an issue because the nice thing is that because if constexpr looks like control flow, all of our intuitions for testing things in the correct order completely apply. If anything, it's the sort of unsorted nature of overload resolution that makes things a little bit harder and scary, right? Like here, when I look at this classic tag dispatch. Overload set I'm not too worried because I see this pattern. I know how it works, but if it gets more complicated with we've got like ones that were like true type false type, any tag where any tag was like convertible from anything there we really need to sit down and think real hard about OK does this produce you know unambiguous results for every possible combination, but when we have if constexpr we can just say OK, we're going to test the thing we care about first otherwise then we've sort of examined that thing we no longer need to worry about it. It's much more than methodical. So I would say the changes there have been entirely positive, but it is something to worry about. OK and yeah, Casey says in fairness, the vast majority of our tag dispatch is only two cases, true type and false type.

>> Casey: Yeah,

>> Casey: we haven't had a whole lot of

>> Casey: opportunities to screw up.

>> Stephan: OK so I will go ahead and push changes to this PR later and thanks to Adam Bucior for this excellent PR that will improve the performance of using C++20 ranges with the most popular container in the STL. I did not even realize this was an issue because I would look at the old code. I'd be like ohh _Is_fwd_iter_v? Yeah that's going to tag forward iterators and yeah concept should be fine but the STL is always full of surprises so thanks and I think we'll see you next time on the VC libraries Open code review.