WEBVTT Hi and welcome back to another VC libraries Open code review. Today we'll be looking at a PR from our contributor superwog implementing new algorithms for the C23 standard. The paper number is P1223R5 and the algorithms are find last Umm, and there's a whole family of them. The PR that we're looking at in the Microsoft SQL Repo is 3268, so here's the PR. This has a link to the tracking issue that we filed, um which lists the feature test macro that should be implemented. And here is where we link to all of the relevant papers that were voted in. Sometimes there's a primary paper and then patch papers that update it later, sometimes LWG issues from the library working group. In this case, there's just one paper. And here I've opened it up to see what wording it has, and then finally I've opened up the currency versus working draft with the current standard's. I don't believe this has been patched by anything later, but when a paper just adds a whole bunch of new wording and doesn't have like. Lots of fine grained changes to existing wording. It can just be simpler to look at the, uh, the final version in the working draft. So we've got the features macro here. These algorithms are there's a little bit of interesting. Detail about how they work with, um, uh, forward versus bidirectional iterators let me actually see where the wordings being added so. Here is the. Post wording. This is just the context where it's being added. The new stuff highlighted in cyan here is find last. So we get find last, find last if taking a predicate and then find last if not, and then the actual addition is in a section named Alec find last. And that's it. OK, so there's no aside from the synopsis change, which is just declarations, there's no other. Changes to existing standard's so we can just look at the working draft now. I've already found the relevant section. This is a. It looks like a whole, you know, dense mass of keywords and identifiers. It's not as frightening as it May 1st seem. It's just because this is specifying both the. Predicate forms and the non the inverted form find last if not, and so forth. And it's got 2 forms to handle iterators and Sentinels and ranges, because C plus doesn't provide us a way to sort of unify these in just a single combined declaration. But it's not quite as complicated as it seems. So let's take a look at the PR and then as we see, interesting things all refer back to the standard's. Me magnify this. OK alt Click to on the Chevron to see what files are being added. So we are updating our central internal header to mention the new paper and the feature test macro product code changes in the algorithm header. We have new test being added and then a feature to smacker test. Ever since I was in kindergarten, I like to eat my dessert first, so I'm going to look at the easy changes first. Here is the new declaration or the new list of the paper. Let's make sure it matches the tracking issue. It does. This makes sure that there's no typos or digit transpositions in the paper number. So that's good. This is in sorted order and is this being listed under C23? It is. That's good. And then we've got the feature test macro. So here's an interesting bit where I originally recorded CPP Lib find last, but the feature just macro is actually going to be named ranges. And last and here super wig has added a comment that there's a library working group issue, so I'm gonna use my search shortcut. I just type LWG and this takes me right to the issue. So the paper this was actually opened by Super Rick, thank you. The original paper specifies CPP Lib find glass, but it's only adding ranges algorithms. So for consistency it really should be named ranges find land. So this is already been approved by the library working group. It will be voted in during the next meeting. Totally fine to implement it now by convention. We'll comment when we're sort of implementing things. A little bit advance of the standard, so commenting LWG 3807 here is appropriate. So range is fine. Last and the value is 202207. That has not changed. Um, so this looks cracked. Yep CPP Lib Brain just fine. Last that's sorted order LG 3807. Double check that this is correctly and see what was 23 and not say C + + 20. Correct. OK, which is good. Let's take a look at the feature to smacker test. Uh, we've got the new ranges. Find last. I will check that value. Ah, we've got a typo. OK, so this is. This is why I habitually search for all occurrences of the value to detect. Copy paste those in this case, because this stuff is so repetitive, the the usual way to add it is copy pasting, but one of these was not updated. Where we emitted an error, but this says a different value, so that's a bug. This uh value. Because I'll just say it's incorrect. OK, because I expect to see it three times repeated exactly. I'm assuming that the spelling is correct because this would fail if it were spelled incorrectly. But for completeness, let's double check. OK, so all of these were updated. Occasionally I will find like a copy paste error where one of these macro occurrences was not updated, but here they're all good. Let's see. Jose asked in the chat. Can we script these repetitive sections? That would be nice. Unfortunately, the preprocessor does not really have any advanced logic for doing so. In theory, we could write an actual script that would emit code, but then we would need like a build step in the test machinery to run that script to generate a source file. And ultimately it would just be sort of the the stuff that would drive that script would be kind of repeating the just sort of the the declarative list of macros and values here. So ultimately I don't know of a better way to do it. This is just sort of repeating information twice in different ways to make sure that we detect any divergence. In uh in in theory I mean this test. This test was originally um, and it's an interesting question. This test was originally added for both the compiler and the Standard library. When I went into the compiler and pretended to be a compiler dev for a day and added feature to smacker support, it was testing the compilers expansion, which could go wrong in all sorts of ways. The library macros have always been simpler. We just define them or we don't and we set them to various values. So ever since. We carved up this test into half and then sent the compiler part back to the compiler. That's in the internal test harness. Now, the library part of the harness is admittedly not providing super duper useful coverage. We probably could just eliminate this task and wouldn't lose a whole lot. We would need to be extra careful to make sure that we're guarding things and the header properly. But there's not a whole lot of ways that this can be damaged. I suppose it does provide a useful check to express things in different ways, so this tells us. We should only expect to see find last when 23 and CPP Lib concepts are enabled. This is implied by the structure of the header, but expressed in a different way because it's guarded by of 23 and concepts. O if we tried to script this, the stuff driving it would end up looking more like rivals Core H um. So would, I think, actually reduce the utility of the test a little and in addition to significantly complicating the the test machinery. But perhaps there's a more elegant way to do it, I'm not sure. OK, so returning here. So we've got the macro name spelled correctly. We've commented about the value not occurring here. Does everything else look good? We are indeed guarded by if has 23 and defines eclip concepts. Here I'm just checking for all the underscores and capitals being correct. We've got this comment because hopefully we won't always need to be checking for concepts. There's a tracking issue about that. There's also a comment about LBG 3807. Totally reasonable here. Once that's accepted and working paper, we'll go back and eliminate all these comments. Um, last thing to check is is it actually in sorted order? Um, ranges contains ranges, find ranges, fold. Yes it is. OK, so this looks good. OK, I'm continuing. Easy to miss because this is only used by the internal test harness. Um. This is incorrect. Um, it appears that these directories were added and then the name was updated to add the ranges. Alec for consistency with our other tests. But then test dot list was not updated. So this works in the GitHub harness because the Python powered machinery will just recurse and find all the directories. But in our internal, much less advanced Earl power to harness, I cringe when I say that. Um, these directories just won't exist and I think it will emit an error or it will just silently skip them. In any event, this needs to be updated. These test directory names are outdated. This is absolutely something that could be scripted, but we would have to descend into Pearl Madness to fix this and we just have never actually had the time. In the future, I hope that we will be able to get the internal machinery to run to drive the, uh, Python power test harness. That would require a fair amount of engineering work, but we would be able to eliminate all this legacy stuff. It's on our it's on our To Do List. We've got a project for completing more of the GitHub migration and getting rid of our internal legacy stuff. OK, so comment there. I'm aside from that, at least the, UM, the paper number is OK. I will check. That is what the the guiding principle here that I'm not voicing until now is that when I find something like a typo, sort of, my level of caution immediately goes up a notch. I start looking for care. There other typos or copy paste errors, things like that. Because where there's one, there's usually more. So paper number is correct, so we just need to correct the directories and it is inserted order. Another thing we don't algorithmically enforce. OK, good. Uh, we've got configuration files. Let's look at these first. Uh, we always need our copyright license banner here. I have a personal tudu to maybe add some scripting to validate that each of our files has the banner here. These need concepts because they're powered by ranges and it's a 23 feature, so we need the latest. These matrices have sets of compiler options that we throw at each test. So concepts latest matrix is correct and we do permit the. Permissive mode. So the absence of strict here is good. It increases our test coverage, so concepts latest each time. This is all good. I'll come back to the test files just checking that each of them have the banner before I forget. Yes, OK, that's all good, we'll come back. OK, let's actually look at the algorithm now. OK, so before I get to the algorithm, let's take a quick look. Let me close this at the working paper UM to give a quick overview of what these ranges algorithms do. OK, so, um, sort of the fundamental ones are find last. So there are six of them here because it's covering find glass, find last, find last. If not, that's three of them times Iterator, Sentinel versus. Take an entire range at a time. Um, but really the core algorithm is just fine. Last, so the reason why we have find less if and then finally if not. This is very similar to the classic design of the STL. So let me change to. I guess I can just scroll up to find the existing ones because the the classic signatures that don't take range of stuff are sort of simpler to look at. So here is classic STL find versus find if. So there is a reason why find and find if are named differently. One takes a range of iterators and looks for a specific value and is going to use operator equal equal to see hey are you equal. The other one takes a predicate, a function object. Returns the first element it can find where the predicate returns true. These are differently named because, especially in the classic C + 98 era, the STL could not sense whether something given is a value that's intended to be used with a quality or a function object that's invocable with operator in front. You could even imagine pathological scenarios where you've got an object that's comparable with equality to the element type and it has a function. All operator that accepts the element type. There's nothing stopping such a strange thing from existing. So in theory there is no actual way to distinguish the programmer's intent, and that's why these have separate names and are not just overloaded. Sort of less defensible in the modern era, but it did need to exist. Back in the classic era. Is the negated form find. If not, this takes a predicate but then returns the first one where it returns false. So the STL in C + 98. Decided to provide these, not versions because they were, you know, sort of simple defined in the algorithm and it didn't require creating a reversed predicate or wrapping the predicate in a negator. The classic SDL did have. A helper machinery to negate the results of predicates. But it was sort of hard use. Um, not generally applicable. Um. And it was just a pain to use. So although I'm not 100% sure of the design rationale, I believe that these not algorithms exist because the negator machinery was not as useful as one would hope. That is actually changed. We now have something in C going off a little bit of a tangent on cppreference, not fun. We now have a generalized negator wrapper. Or you can give it a functor and a callable object and it will return something that will invoke that thing and then apply operator or not and return the opposite. It's opposite, stay or because in C plus we can now use lambdas. It's if you're gonna provide a Lambda, it's easy to just write a Lambda and put the exclamation mark character in there. So I would say that in the modern era and C + 23 there is much less of a reason to provide not algorithms and I imagine library evolution. We've talked about this um, but currently it is following the Convention of hey, if you have an if algorithm, also provide a not algorithm because otherwise it could become a frequently asked question where somebody says, oh if I have you know, find if and find if not how come there's no, you know, find last if and find last if not counterpart. So it provided 6 algorithms instead of four. Even though possibly in the modern era we don't really need these, it's not really much trouble for us to define. Um, if we were gonna create a completely new STL, we probably wouldn't have the the NOT versions. But that's why these exist. And then according to the ranges system, there are now these projections which allow you to view range of elements through a lens. They are projected. According to some function object or call by object by default just identity, so by default it does nothing. But occasionally it can be useful to say, OK, I've got a range of elements, maybe strings, and I want to find the first one that is bigger than. Or find the last one, um, with a length of, you know, uh, larger than 16 characters or something. So I'd like to project the string to just its size before invoking some predicate, like a Lambda that looks just at the size. This can be more useful than having to bake that projection into the predicate. And it's especially useful when you're using the value form because you could say if you wanted to, say, find the last empty string, you could say, find last, project the size, and then just look for. Ro as the value rather than find last if and then test the size again. Zero different ways of expressing the same thing, so that's what the projection is doing. Umm, and so this wording um says uh, it it handles sort of the differences between these um, value versus predicate versus negated predicate form, saying the value form uses operator equal, the predicate form will invoke. This is the invoke protocol that we've talked about in previous code review videos, which will handle the syntax differences between things like function pointers, member member data pointers, and call objects or function objects like. Lambdas and then the negated form says operator not there. And what this returns is the last iterator in the range for which this expression is true, and if it doesn't find anything, it will return just the last iterator. Bringing the range algorithms also return a sub range. Um, so. If you have a input range, it will return the answer as a range, which can be useful when chaining these sort of things. And there's a complexity requirement that we don't invoke the predicate and projection more than the number of elements in the range. That says basically, no repeated tests, you get a test each thing exactly once, no more than once. And then the other interesting thing, which I alluded to at the beginning of this code review, is that these algorithms take forward iterators, but it talks about returning the last iterator in the range. So as we go to the implementation, we're going to see something interesting because if you have bidirectional iterators or stronger like random access or contiguous iterators, if you want to find the last element in the range that satisfies a predicate or value, you can just March backwards. From the end, the last iterator and as soon as you find something then you say hey I found the last one done. But if the user gives you a forward only iterator, like a forward listed or forward list Iterator, a singly linked list, then you have no choice but to March from the beginning because you can't ever go backwards. So the algorithm there would be search from the beginning of the list or sequence, as soon as you find something, remember where it is, but then keep going onwards and as soon as you find another value. Toward that as the last value you found, and so on, and then when you're done, return the last one you saw. Of course you must traverse every single element in the list, but that's the best you can do with forward only iterators, and there could be use cases for that. Nice to have the STL do this for you rather than having to call a whole separate algorithm or write something from scratch. But in the case where The thing is not found, in the case when The thing is not found, it's same complexity either way, when it is found, the forward version is to traverse basically all the elements, whereas the bidirectional version is order length of the distance from the end to that element. So that's why it says forward iterator. It does not accept input iterators because and the STL forward iterator means you can March forward, but you can also preserve iterators to an element and dereference it as much as you like and it's going to still be there. It's multi readable. Conceptually, this means that four iterators point to something in memory that's persistent, like a singly linked list. Whereas input iterators are something like from an input stream, an I stream where you can consume something from the stream and look at it, but then if you advance the iterator, that existing value evaporates. It was just returned to you, but it's not existing anywhere persistent in memory. So an input iterator is a input iterator algorithm is a single pass. Algorithm. You don't get to do something like preserve an iterator March forward and then look at the previous value. So that's why this must insist on forward iterators and nothing weaker than that. OK, so, um, that's sort of the overview of what these algorithms are doing. Let's actually look at the code. OK, so we are updating the algorithm header. I'm going to look at the context to make sure that we are in a C23 zone. I can see we're calling fold right here, so I'm almost certain we are. And I just. Expand. If I get bored, I might just open up the STL in VS code because we've got a lot of C23 stuff. Yeah, that's taking too long. Let's just open up the STL. Um, OK and actually I can just check out this PR. Uh what number is this 3268. Use the GitHub command line tool DHCR. Checkout 3268. Great. And then we want to look at, now that I've expanded all this, I want to unexpand. There's no button to immediately do that. Whoops. OK. Here's where the code begins. I could dip against main, but I can here. I just want to search for this find less fun. OK. That's on line 2801. You'll be the guard. OK, it was actually 600 lines above where um starts with fun um. OK, so we are in a C + 23 zone. Uh, I guess I could look for the next end if to be super duper careful. I kind of wish it wouldn't immediately navigate me as soon as I type something, because I want to see where I was. OK. Yeah, we and then. In fact it ends after the new algorithm, so if I Scroll down I could find it. I can just do that here. Yes. OK, so we are adding to A to an existing HASC X23 region. So that's good. I checked this because nothing will complain if we add something to a too old mode. Like if we added this to C20 and we didn't depend on something that was specifically C + 23, that would compile, and yet we would be defining these identifiers in a mode that they really shouldn't exist in yet. OK, so we're adding to the correct region, so we're going to define a class because. These things in the standard that look like functions are actually function objects in the ranges universe, which handles, I think, argument dependent lookup. It means that they're not subject to ADL, which is nice, it's just a new design. And that means that what looks like 2 functions in the STL for each of these forms is actually just two operator overloads of a single function object. The other thing I'm going to verify before I look at anything else is that we are respecting modules. After adding 3000 occurrences of the macro export stood to the STL. Now we just need to make sure that all new user visible identifiers are marked as exported. So the Convention here, the way it works is that the user visible object is marked as export. We do not need to export the internal class or any of the function call operators or anything like that. So for these three overloaded functions we mark as export and here it is. And the objects O exports did find last exports stood find last if and export stood find last if not. We don't specifically need modules coverage of this. Our modules test tests a little bit of every STL header, but does not go so far as to test every single algorithm with every you know possible iterator combination. That would take years and years to write, so here just spot checking that all of them are marked as export stood is sufficient. OK, so let's actually look at this class. So we derive from our internal helper. Not quite object. Then we have public machinery and operator pren prens we need to use inheriting constructors from it. This means that users can't like default construct this object thing. That's what it's not quite object machinery does. Let me actually split this so I can at least look at the signature real quick. OK, here we go. I don't think we need the tracking issue anymore. OK, um, that is annoyingly small. I want to think big thoughts. Come on, give me longer lines. OK, this uh, maybe if I minimize this. I know that the standard won't be super readable this way, but um. The code is more important here, OK? Maybe one more step. OK, it's kind of tiny. OK, so Umm, here I'm looking for that a everything is ugly, which I'm here I'm not too concerned about because super wig has written many peers before and to make sure that things are mentioned in the right order and if there's any divergence between what the standard says and what the implementation does that I understand why it diverges sometimes for some optimization or some internal unwrapping thing we need to do. Also I want to highlight things. Where's my little highlighter? Here we go. Um, OK, so we are looking at find last. That's this one, the Iterator Sentinel. It's following the standard order. So we're templated on a forward iterator, named it. We need a Sentinel for that iterator. C Class Ty class PJ is the identity functor. OK, we have a concept requirement that it's an indirect binary predicate. That if we use ranges equal to on the projected iterator. Um, and looking at Consti star, uh, that essentially dereferencing. The iterator and then running that through the projection and then looking at that value. UM here because it's indirect binary predicate. We say Constance star because it's indirect that we can compare them with equal to. So that looks right. And that matches the standard which says Consti star. OK, so each of these things should be no discard because they're observers. We're looking for the last occurrence, so we should see six notice cards. I'll double check that we have this and then I won't refer to it again. Um, also internal helpers are marked notice card. That's nice. So two public and then one internal again here. Ohh, we're missing one. Four find last if operator paren paren the range form. This should absolutely be no discard and it's missing here. No discard. OK, so again paranoia increases. Let me double check um find last two public functions internal helper. Find last if one public function but not the second commented and then internal helper. And then find last if not. Public one again missing here and then internal helper. OK, so this one also missing no discard. OK. Count it. Correct. OK, going back. Um, pure observer. So it's no discard. OK, these things need to be constexpr. We had long e-mail discussions on the C Plus standard mailing list about should you know things in the STL be marked as no discard eagerly or should we only do it on the most dire cases like vector empty? Lots and lots of discussion. The committee eventually decided to. Follow the status quo, which is not mark. Everything is no discard. That means that implementations need to sort of do their own homework as to whether to mark things as no discard or not, and provide additional, you know, quality of implementation as they call it. We'd love no discarding the STL. We're up to like 7000 or something occurrences of it. I don't even know how many I'd have to search. And every everyone is valuable as long as we avoid false positives, and this is a clear slam dunk case. That it's useful. OK, so constexpr return a sub range for the iterator, and this is ranges finglass. This name is provided by the function object. Below we take the iterator first, the Sentinel last. In this case this is called sent. That's fine. What is oh I'm scrolled down. I'm looking at find Elastic and I want find last. I was like why is there a predicate here? OK find last let me double check context for subrange it operand Pran it first ccent OK here we go tonsai ref value. OK and PJ projection is brace brace. It's constant on the function. The function call operator is constant because the object is constexpr. OK, and so now let's actually look at the implementation. So we are being given a user defined potentially iterator and Sentinel. So we want to verify that these iterators are valid and for example belong to the same range. Aren't reversed if they're random access. We have a helper addl verifier range that does that. Now we can remove checking from them because we know it's a valid range, or we hope it is. So we can call our internal helper find last unchecked down here and we're going to. Call our unwrap helper, so there's some common machinery for this. I won't go into exactly how it works, but we need to essentially provide the Sentinel type to the iterator, and vice versa, provide the iterator type to the one that unwraps the Sentinel. So I actually forget why. I could go look at the definitions, but this is the right convention where we say unwrap it or C and then move in the first iterator, unwrap, Sentinel it, move in the Sentinel. Looks right and they're not constant so the moving will actually take effect. We pass value by consti ref and then rods we pass through this helper *** phone. This helps with the back end code Gen or did. I think this may be less necessary now but I haven't gone through and verified whether this is still necessary. This is correct according to our current conventions. This returns a sub range which we're going to use a structured binding to decompose. This will give us unwrapped. 1st and unwrapped last, uh, return values. But then we need to reapply wrapping. This is the potential layer of iterator checking. Give us something like STD vector iterators. We verify that they're not swapped and that they belong to the same parent container. Then we unwrap down to pointers, run the algorithm real quickly, and then wrap them back with our iterator debugging technology. That's what this is for. So. Here we go O we return a subrange of iterators. What came in was an iterator Sentinel pair O we can't reuse sent, it could be a different type. That's why we need to make a new iterator last brace initialized. Then we're going to seacraft, which is essentially an assignment, um 1st, and then move in. You first, last move you last, it is. Unclear to me. Do we need to brace initialize last? I'm not going to worry about it too much. I sort of believe that everything should be initialized and see what's all the time. In theory it might be possible to use a singular iterator here because this is just going to assign. That's what crap does. UM, I think we might brace initialized elsewhere. This is. I'm going to check for my own education. Seek wrap let me just pull up random occurrences, which is pretty uncommon that we make a fresh iterator. That's why this looks new to me. Usually we're seeking an existing iterator and just resetting it. Let me actually look at the definition because I think secret just essentially does an assignment. Or go ah if, um, it provides a seek to. Member function, we call it. Otherwise we do an assignment. OK, at some point we got this. I think historically we might have just always done the assignment, but in our new machine we've got the seek to. I think this avoids. I want to say this avoids unnecessary debugging logic to like make a fresh iterator or something. Um. No, this is when you're wrapped you call seek 2 because these are these are different types and otherwise you just do the assignment. OK, so I think, I think it historically called C2 and then later we added this optimization here. So when Iterator supports seek two, they just assign the internal pointer. Uh. In the case when you respect iterator debugging, you're a class type and. Usually. Default initialization should be the same as value initialization, but. It's certainly correct. He's value initialization here. I'm not 100% certain it would be correct to get rid of those braces. So this is good. I like it. OK, seek first to you first, last to you last and then move them out. OK, that looks right. Ohh go what? What is the concern? So um. What we have here is. So first here it the iterator first like the idea behind seacraft is. Um. Your. You are taking the provenance of this iterator. Keeping it the same like it has the same container. And then assigning any new pointer like iterator value. And so this default constructed iterator does not have the Providence of any container, and therefore you're right. Totally missed it. You're absolutely right, this has no parent. This this can't possibly know what the parent is, so we really we should be copying it from first here and then seeking it. OK, that's like, so that there was like something in my brain was telling me that this was a little weird because we're making a fresh iterator here and we almost never do that. But I totally missed. Thank you for finding that. That applies to all of these. Yeah, this one, I believe that. 2. I believe that unwrap interior should be. Letters should have ranges on it. I think that's our new convention. Oh, they're qualify it. Umm, yeah, I think we have an issue to go apply qualification. We haven't done that globally yet. Um, I think most occurrences here are not yet qualified. Check leave when I did the upper unwrap it or changes. Maybe I didn't. Yeah, we have tons and tons of unqualified calls, so I think this is conventional right now. Um, I think in the future we can just have a global change to apply this. Um, we did decide to start qualifying everything in the STL, even though it's gonna be horribly verbose. But I would rather have that done all at once rather than piece meal. Yeah, so I think I won't request changes for that, but absolutely request changes for the parent. This indicates a, I would say a massive hole in our test coverage. Why are we not finding this? There should be any use of vector should find this. Yeah, go ahead Casey, I go look at the test coverage. I want to point out that I've been looking for trying to figure out why we don't have this problem already elsewhere since before Nicole mentioned that this rewrapping is weird. We have a helper called Rewrap sub range. That we use for search in the algorithm I'm looking at right now and we desperately looking for another occurrence to figure out how we deal with this before. Yeah like where where we screwed this up for so we say. Paper. First pass result. OK, so here this just demands that one iterator have the parent, and then it will make um. Ohh, this is expecting search into result. The search in helper to return a sub range of the unwrapped iterators. Is that what's going on? Is is this one essentially. We haven't rewrapped first here, yeah? There's always the returns of sub range of unwrapped iterators, and rewrap subrange turns that into a subrange of wrapped iterators. Oh, I see this is a. It's taking a whole range here. OK, and then given a single iterator, it'll apply that parent to both of them. OK. Is that what we're doing here? We've got two unwrapped iterators, OK. It's just we they they come out as on actually, no, they they actually come out as a subrange, but then they were decomposed here. So it would actually be simpler to use Rewrap subrange. OK, great catch. Thank you. Like I can do this pattern anatomy elsewhere in the algorithms. It's like we've done it before, how did we do it? And that's super big. Did ask for help with the the rewrapping because this is new and it's apparently new to me too. I'm learning all this new range of stuff. It's like I know how it used to historically work. OK, so let's uh find some context here and provide this in the comment. Let's look for the first occurrence of Rewrap subrange and then I want to know before I add this comment, why are we not seeing this in the test? Is the test machinery which is used in some of this instantiate or stuff? Why is this not using like wrapped iterators? Is it just the test forward instantiated just doesn't use vector iterators ever or anything that behaves like it? It uses test colon, colon iterator from range, range support, range algorithm support? And they don't have a problem with rewrapping things. In this manner. OK, so there's no sense of. The original iterator has apparent that distinguishes it from value initialized. There is not, and there ought to be. Do we? There is not, and there ought to be. We should all file an issue for that. OK, awesome. Thank you. Expand that bit of coverage in the range. Yeah, and that that the nice thing about that is, yeah it'll it'll be annoying to write. Um, because the the parent checking logic is always annoying. But once we write it, it will provide validation to everything, which is like zillions and zillions of branches algorithms going through this very useful instantiated machinery and prevent further problems of this nature from occurring. OK, so thanks for finding that. Let me find the Rewrap subrange. This is search N. Let me get here. This is saying size Sentinel fours any one of these better than the others. This one is simpler, the unsized one, because we don't need to separately compute the Dist. So I'll give that as the example. Hit Y to get a permalink, and then there we go. OK. So let's go up. And go down because I made the mistake of expanding stuff. OK, so here's where it is. There we go. OK. Expand this. OK, so. Nicole. Noticed um. A major problem here, um. The argument um. It. No, that's a parameter, the parameter. It. First um. Is a wrapped iterator with a. Parent. In the general case. Like a vector. Federator. But it. But the freshly constructed. Let's say let's be proper and say value initialized. Um, it last. Um has no parent. Uh. Therefore um. Calling um, seek wrapped. I just copy this whole thing. There's no there for yet, ccrap last. You've moved you last. Doesn't have any parent information to add. Um. Causeway you last is a raw pointer. When unwrapped. For example, not saying it's a raw pointer all the time. Just provide an example. Um, so we end up. Returning um incompatible. Iterators. Let's see. Going to provide credit here. Thanks, Nicole. And it's time for ask points. Yeah. And then. Can you see notes that the? Ranges instantiated or machinery used by our tests could have detected this, but currently. Doesn't have validation. Or. Matching parents the way that vector iterators do. Umm. Instead, the granges test machinery has its own test iterators. Is filing an issue? Um to add. Such coverage, um. So it doesn't need to be added in this PR. Casey explained that the proper way to fix this issue. Let me Scroll down. Oh no, that's not going to get me. That is to call. Rewrap subrange. I'll verify I'm not typing this, um as other ranges algorithms do. Example. I mean, look at the example for context. Um. Yeah, so it's basically you provide a single iterator. I'm trying to describe it in human terms. Uh, for super wig, provide a parented iterator and an unwrapped sub range and it will make a wrapped subrange. OK. This is given a parented iterator and an unwrapped subrange. Which? Is simpler. Since we don't need to decompose it with a structured binding and returns a. Wrapped subbranch um. Occurs below in all. Algorithms. I'll grow them over this. OK awesome uh proofread uh Nicole uh, noticed major problem here that parameter it first is wrapped iterator with a parent in the general case like a vector iterator. But the freshly value initialized it last brace brace has no parent. Seacraft last you move stood move you last doesn't have any parent information to add because you last is our pointer when unwrapped for example. So we end up returning incompatible iterators. Thanks Nicole for finding this amazing issue that I totally missed on first glance. Casey notes that the range is instantiated machine are used by our tests could have detected. But currently does not have validation for matching parents the way the vector iterators do. Instead, the range is test machinery has its own test iterators. He's filing an issue to add such coverage, so it doesn't need to be added in this PR, Casey explained that the proper way to fix this issue is to call Rewrap subrange as other ranges algorithms do. Example. So call the unwrapped version that matches and then. We can just return here. So it would basically crunch these, uh, what is that 5 lines with wrapping ignore wrapping down to two ignoring wrapping, which is great. This is given a parented iterator and an unwrapped sub range, which is simpler since we don't need to decompose it with the structured binding and returns a ramped subrange. OK. Add or view comment excellent. OK, so, uh, going onwards. Uh, the rest should hopefully be um. Very systematic. Uh. We are looking at the find last for the one that takes a range. So template forward range R or range class TIE class PGA identity requires indirect binary predicate range equal to projected, the iterator type for the range and the prog consti star. We got the notice card on this one constexpr Bard subrange TR. Operator Renren take range ref ref range constant, high ref value J rod is brace brace constant on the object. OK, so going to be doing. I'm going to ignore all the wrapping stuff. Now we get ranges begin from the range. And that's auto. First we're going to call the unchecked helper with. Unwrap range hitter for the range stood move you first. This is uh, it's not. Obviously not new, but um, I don't remember what this does. I've got tons of usage of it. OK, so you give it a range, you give it the original range type. And. Why is this special? Ohh because it passes the Sentinel type. OK, because the unwrap thing. As I mentioned earlier, the unwrap ITER requires the Sentinel type. But it would be annoying to have to say Sentinel T range all the time when we just could just say range by itself. OK. And we check that the thing that we're giving it is the iterator type for the range. So there's a bit of validation in addition to the convenience of grabbing Sentinel. So that's what this is doing. OK. Uh, so we unwrap. Uh, move stood move first. It's not constant. It's good. Past the unchecked end for the range, give the value constant ref, pass the projection. Then we won't decompose this. We'll use the Rewrap subrange, excuse me. And then return it. Good. OK, private helper template iterator, Sentinel, Ty PJ. Notice guard. This is static because it doesn't need anything from the class. Uh, Constexpr helper returning subrange of it. Uh this is the unchecked. I said Ohh there because I'm like what are we looking at? This is the unchecked algorithm helper. So it here is unchecked. So it's a returning a sub range of unchecked. It makes me mildly nervous to use the same type here. I think this is entirely consistent with precedent. So the principle that I prefer to follow is same names for same things, different names for different things. Because the way I always explain it, in templated code, we kind of have no type system. This is not entirely true now that we have concepts. So concepts provide a type system over types. But. Not to the level that you know actual type serve for variables. Um, and especially when you're just rewriting helper wrappers that aren't incredibly concept constrained or static asserted. You can just type anything. Like you can give things a name and then pass it to some other thing, and then that name of that type parameter. That template type template type parameter is sort of all that is telling you what it does and how to use it and mismatches. Yeah, maybe they'll cause. Tyler errors, but without you know definition checking. Um, if you are passing around like an unchecked type or checked type, and then you pass it to something where the name suggests that it's unchecked, well, you get confused about what you're looking at. Just the other day and we found a bug where we were sending the wrong type to some helper machinery where we were sending a wrapped type which could be like a vector iterator instead of an unwrapped type like a raw pointer, and then that caused some optimization code to not activate. Properly. Um. So it helps when writing heavily template code to be extremely disciplined about having descriptive names. And then if you change the nature of a thing like unwrapping or adding a pointer to something or changing to unsigned, or. All these transformations we can do at each layer of templated machinery, change the name that's being used if you know it's always going to be like the unchecked version or the unsigned version or something like that. Here, I'm a little bit uncomfortable in going on this. Side um. Cause we've got a wrapped iterator being passed to the user algorithm, we unwrap it. And. In this helper overload here, this helper algorithm not an overload. Um, instead of being named something like you, it which would signal, hey, this is the unwrapped iterator. It's just named it so it's reusing the name. But for something that is different makes me mildly nervous. Now, it's not incorrect, and I think it is actually consistent with Preston, so I'm not going to request changes here, I'm just going to double check. But it's pretty conventional. Yeah. Ideally I'd like to change the Convention, but I certainly don't think we would want to change this in this PR. And it's probably not even I'm. I'm just nervous because I've seen it occur. And The thing is, is the sort of thing that you can get away with like almost all the time. Every once in a while it gets you. So I worry about it because I try to make code as defragged free as possible. So like, here's an example, the search engine size thing that we look for the rewrap. And yeah, this is just given it. Even though it in general is unchecked O OK consistent with precedent. I wish the precedent were a little bit different, but it is certainly not worth commenting here. OK. O template on unwrapped iterator CTI PJ notice card static on the object constexpr subrange it. This is the unwrapped version. Fine. Last unchecked it first. See last constar value PJ project it's static so it doesn't need to be constant and cannot be. In fact, this doesn't need to be concept constrained because it's just a helper. But we do static cert that all the concepts we expect hold in test machinery. STL internal Static Cert expands only to. Static assert in our tests that we're dealing with a forward iterator, that C is a Sentinel for it, and then we've got the indirect binary predicate thing. Um. Thing that I'm thinking about is for the equal 2 do we say range is double colon or do we use the capital ranges? I don't want to look at Navas. UH-4 the names of the parameter we do just say lane range is double colon. For function calls we say under score capital ranges, but here this is an unambiguous. OK, that's fine. Is it ranges corn corn equal to and not just two? Uh, correct it is ranges double colon equal to um, because that one is uh, it's not templated. The classic equal to does have template arguments, even though you can give it the diamond my diamond that. Makes its function call operator templated, but the ranges version of the predicate is sort of the way the predicate should have always been defined. They've got that transparent functionality baked into them, so that's why this uses the range of thing. I think they might do something else. Did they have some other fancy machinery that the classic one doesn't have? Actually don't know. Let's check. Same thing? I think so. They have concept constraints instead of return types feeding constraints, but no, they're not that much. OK. Uh, what was that, Nicole, you you were saying something? Does ranges last do the? Great thing with pointers that like. Ohh yeah yeah four non flat memory yeah I think yeah I think that is specified in the standard. Not that it makes a difference for replication month of my life figuring out how to write the standard's to make sure that all of the ranges, ordering functions and all this stood ordering functions did the same thing with pointers and that they all observed a consistent ordering and I still didn't get it quite right. And Gaspar, Ashman and W. 821 had to fix one last plug in. The wording is dead last void do the right thing? Because I feel like I heard something about how studless void doesn't impose a strict order or a total ordering on pointers. The issue. I'm sorry, what was that Casey, I was talking over you. It does now do the correct thing. Yes it does. OK, what's funny is that violates my my original design for the diamonds because the philosophy for the diamonds was you get what operator less than gives you no extra intelligence. And I was like, OK, well if you say let's diamond for pointers you're going to get what you you deserve. But I guess they went in and enhanced it anyways. So I guess that's fine it again it doesn't make a difference for. Our implementation. Are there actually any actual implementations of C + + 14 for? For my architecture. I don't believe so. Um, uh, in fact, uh, I think I could be wrong. I think all good news systems say that hey, we just expect flat 32 bit spaces are larger and that would be the systems where you would expect the segmented to possibly be an issue because they cover such diverse family of computers. Certainly for no window systems, windows is like, yeah, everything is going to be flat memory. There has been some talk of keeping around all that, oh, we could handle segmented. Memory pointers, things like that for future architectures where maybe your address space is 128 bit, but the 1st 64 bit tells you like you know, what kind of storage you're in or whatever. That's why they've kept that language around. My understanding, but I don't think it's actually a concern for. Any real systems? I forget what Constexpr does. If Constexpr lets you compare the addresses of things, I think it doesn't. Right now they have to exist at the same memory. If you try to compare addresses of unrelated things, it says whoa, I can't do this because it's unspecified. So in practice, it's the there's. There's no no work needed from implementers. Uh, OK. So returning from the land of comparisons, uh equal to projected iterator T range project, we looked at the signature. OK, const. Umm. And then we grab ranges. Begin first, find lesson checked, unwrap. OK, I looked at this. Ohh wait no I was I was down in fine last unchecked. Here we go. OK. My brain is now resuming. Uh, indirect binary predicate range is equal to projected at PJ star. OK, so here is where we see the. Multiple implementations of the algorithm that I originally talked about. So this says if constexpr, um if the iterator and the Sentinel are bidirectional and common, meaning that they're the same type and we're bidirectional so we can March backward from the end, then we can have the cool fast algorithm. So for auto result is last past the end iterator. Henry read it because we were working with an inclusive exclusive range. Result is last O. We're going to want to. And I can see it on the the next line we're going to want to pre decrement result and then look at the element there. So that's valid for the final iterator because we point past the end. So when we decrement we get the actual last element. But if first and last are identical, we're talking about an empty range. We do not want to decrement anymore. So we want to keep going as long as the result is not equal to first, because when it is, we've exhausted all the elements. So that is the correct condition. I always like to think about my binary conditions, especially or my. Boundary conditions, especially when marching backwards, because everything is topsy turvy and it's easy to get confused with off by ones like reverse iterator is just a recipe for confusion here. We're not directly using reverse iterator, but we're doing the same sort of thing. Um, and then we've got a fancy update. So there's no plus, plus or minus, minus here. O as I mentioned we dereference pre decrement of result. We look at it through the projection by invoking. It stood invoke and then if that is operator equal equal the value then return stuff, return stood move the result and stood move last which is. This here, and we can do that because even though this is a Sentinel type, we have verified that it is common. It's the same type as the iterator, so we can move it out. OK. And then if we don't find it, return last, last as mandated by the standard here? OK, that looks good. Um. I was quickly thinking of um. It is interesting that we go and define find last separately and not just in terms of find last if with an equal 2. I think this is consistent with what we do elsewhere. We spam out a definition of separate algorithms rather than saying oh, we can just implement this in terms of like the equal to PRED because it does kind of save 1 inlined invocation is better in debug mode. Interestingly, this is not the approach that we took with the classic algorithms where we did unify them a long time ago. With um, predicates like if we look at uh, what's a good example? Um. Try to think. Something that compares find find. I'll do it. Why am I thinking hard about look for a pretty, uh uh, precedent when there's just fined. Of course find it occurs in Asian places in the STL. I wanna look at algorithm. Or it might actually be in no, it's an extra utility. Love to play the game of word. We define this thing. OK, here we go. Um. Oh no, we would need we would need a Lambda because fine, take it. It's a predicate versus a value. So we actually do define separate things. We would need to bind like a. OK, so it wouldn't be trivial to unify them. We we could with the Lambda, but we have historically not done that, so OK, so that's why we define all separate thing. OK, we're discovering things. OK, so that's good for the eye case. Otherwise we're either not bidirectional so we're forward only, or they are different types, so the next case is well. What if you have the same iterator and Sentinel types? Which would imply that they are weaker than bidirectional. So forward only then let's do the forward only algorithm. But we can assume commonality that they're the same type. So here's the forward version. We have auto results as last because we are going to need to preserve that. We will need to return it sometimes, actually all the time. Yes, all the time. Um. So result will be the thing that we March, um. Ohh not, sorry, not March backwards, marching forwards. Um, result is the best one we've found found so far, the one that matches. So if we don't find anything, we want to return last, last. So that's why we initialize it to last, correct? And then we've already initialized first as long as first has not reached last. We're going to step forward 1st every time, and then look at Derek 1st through the projections to invoke. If that's equal to the value we want, update result, set it to the current value 1st, and then when we're done, returns to. Move results to move last. That achieves this. Perfect. OK, otherwise, um, we're not MIDI common and we're not coming up. So that means we're looking at um, right? This is if you're bidirectional and common. This is interesting. Is there a fourth case that we're missing here? So I'm mentally working through the matrix of possibilities. I need to sketch it out, cause four things is apparently too much for my brain to handle at once. Without seeing it in front of me, O we've got, uh, bite eye we've got common. Binary, so yes, yes. Make a little table yes, no no yes no no. OK, so if the range is byte I and common, so the same types, then we've already handled that handle. This is the byte icon in case. OK, Umm, let's come back. So if you're not both of them, then we've got one of these cases. So all these elses when same as Iterator, Sentinel, then that would catch this case not by dye, but common. So this is the handled. Same as. As itsy don't know, I'm putting effort in getting all the underscores right. OK, otherwise this else here is handling 2 cases and that's what my brain was asking. OK, we know they're not common. Right, and yet not common. This would be the case of like. Let me see if I get this right. Um. It could be as simple as a stood list iterator and a stood list constant iterator. Is that right? Where they are usable as a Sentinel, but they aren't exactly the same type. This is something that the classic STI CK C nodding, so I think I've got it right. This is something that the classic STL would not handle. It would say whoa, you're giving me two different types as the iterator. I can't deduce what template argument you would want to fail at. Compile time ranges handles this, which is nice. But it means that checks for like same as in common will be false because you can't produce, you know, the same type. You could convert them to a type, but they're not literally the same type. It's odd that common is used there even though they do have a common type, but anyways, the Bidi case. Ohh you switch back to the code. Yeah, sorry, I think. OK, uh, because there's no minus minus here. That's what my brain I I quickly scan forward. I was like, hey, there's no minus, minus. Shouldn't we have like the case where, yeah, we can use the Sentinel, but can't we use that advanced thing to get an actual iterator to the end, possibly instantly, and then decrement? The question is, is it worth the trouble to do so? Right. Is that going to be more efficient than making a single pass using the forward iterator algorithm? Yeah, well I think it will be more efficient for a random access, right? I think if there are sized and random access, we should probably also have. In that case. Because if you have like. I don't know a vector iterator and a vector concentrator exactly. You have to go through all of the entire thing to find. Exactly. Yeah, because we we essentially can keep the, the efficiency um, so is that is that what so you said? Uh, random access sized uh. I'm trying to think what is the exact criterion that we want to ask for where we could use the minus minus case. So I guess we have it would need obviously need to buy dye but what about random and obviously contiguous we don't, we don't care about and then? Sized. Unsized. I'm trying to think which ones? Unsigned. Unsized. Which ones can we do anything for so. If you are by dye only, then. Even if you're sized, um, if you have an iterator and a Sentinel, even if you know the size of that, you need to March forward. To find the actual last iterator and then possibly go and decrement. That doesn't seem like in general it would be a win it that it does like. There's a tradeoff here that is hard to make without knowing actual types because the algorithm of March that Bidi iterator forward either counting with the size or just until you reach the Sentinel and then start inspecting backwards. You would end up having to pay and increments and then order until you find the actual thing. Uh, decrements, essentially. Um, but you get to save a whole bunch of predicate invocations, uh, because you've skipped over invoking the predicate and the projection on all those initial ones. So you do pay some extra traversals. You pay like twice as many traversals in the order of from the end to the found element, but you get a avoid a whole bunch of predicate invocations and projections, which is potentially nice. So I'm kind of tempted to say, hey if you're if you're bite, we should just always advance to the end because the the usual idea in the STL is that iterator operations are cheap and things like predicate invocations are expensive ish. Which is why like complexity requirements are given in terms of number of invocations of predicate and they don't ever talk about, OK, exactly how many times can you increment iterators and stuff. Certainly it may not always be a win in wall clock time when the traversals are expensive as they actually kind of are for linked lists because everyone kills the cache. Um, and if the predicate invocation is cheap? But it seems like it could be valuable now in the case of random access. If you are random access, it doesn't matter sized or unsigned, you can always uhhh no no, it's got to be. Random access and size Sentinel 4 because if you have random access and if you have a size Sentinel you get that distance then you do plus and you're done. If you have random access and unsized Sentinel like I'm looking through a string that's null terminated, then that actually it doesn't help you that it's random access, you must traverse the whole thing, so random and sized. Um, can't jump to the end instantly, so this is definitely the case. Random in size is definitely a case where you'd want to do this for by die. Doesn't matter whether you're sized or not. That's the interesting question. What do you what do you think after having talked through? The performance pros and cons? I kind of think you're right. Since we're almost definitely going to have to seek all the way to the end anyway. That we're going to have to evaluate all of those predicates at least once. It's probably worth the trouble to to evaluate the Sentinel predicates all the way through the range, one-on-one, traverse, and then maybe minimize the number of. User predicates that we have to evaluate. So I agree that it's probably worth the trouble to have a plain by diversion Abidi not common version and to have a random in size Sentinel slash size range is another pretty obvious win. But I think we were going to handle those in the caller by having the caller transform random and sized into the same as case, right? By having the caller find the end iterator. And pass in begin iterator and iterator to this helper. Ohh, really interesting. Yeah, because that way you don't have to deal with the size. The size range case is the weird 1 right? We might have a sized range whose iterator in Sentinel or at size Sentinel 4. So to deal with that will either end up having to pass a size into this function or get rid or deal with the size problem before we call it. So it would be pretty simple I think in the McAuley starting the caller. To say if that we have random access in size, find the final iterator and call this one helper with the. First and last iterator values. OK, so slightly different forms for the um. This would want size Sentinel 4. This would want size range. Yeah. OK. And then have a case the bite I bite I bite I yes come in no case that does the essentially pretec. Right. And then that would go ahead. Given the implementation of advance. The bidai non common case. Would be exactly the same as the size Sentinel 4K. OK, yeah, yeah. That's why I was wondering. Like doesn't advance with this for us. It's gonna use whatever the get final iterator helper, yeah. Grants, right? The range is one could be more efficient. We have another helper called another ugly helper called get final iterator value or just get final iterator. That takes a range or an iterator and Sentinel, I think. And figures out the. Oh yeah, wow. Even does the unwrapping. OK, so this says, um, if they're the same type after unwrapping. Then just take that last thing and then unwrap it. Otherwise use ranges next on the appropriately unwrapped thing. OK, right. So this is what we were just random access in size will obviously do the O1 version. So yeah, this has the smarts wrapped up inside of it because this problem of course appeared in other rounds. Would we be able to do this in the helper algorithm? Would would each call site need to do it with the caller need to do it? I think it's very simple here. It's best if the caller does it still, yeah. OK. And we were going to do this because there's a there's a range overload. Arsenal. Yeah, I see. Well, it's actually overloaded. OK, why? Why did I not see that here? Ohh because it's right. Pull up. OK oh oh and this. Here we go. The range one says oh if it's a common range then we got more cases. OK, so this this logic is actually quite annoying to do from scratch, but it's already done. There's even another overload there if we have a range and amid iterator from it. Yeah yeah because that would say even even more. The right one. OK. Umm, it's sort of hard to describe. I guess we could just give the name of the algorithm and say here figure this out super quick and then. They can ask if there's any question about what to do. I think that the press should probably say if the if the range slash iterator type is at least bidirectional, we should use get final iterator and pass the result into the unchecked. Helper. Which is what feinglass unchecked. Sorry and define last OK, but that that would basically request and if constexpr in the callers right? Saying if constexpr bidirectional then do this thing. OK, that's that's a lot of complexity, but I guess it could be worth it. I mean, it's obviously worth it. It's only one layer of if constexpr and it avoids wasting effort for the forward case, which is something we want to avoid. Yeah, that's a good point. And I see we do do this elsewhere like in rotate unchecked we're like hey if constexpr bidirectional iterator of course rotates you know special but it also needs to do some special stuff here we have got a lot of calls so a lot of precedent. I'm just looking is there any precedent for this sort of we handle forward iterators but if it's by die then we'll step up and use. I don't immediately see anything like that. So this is sort of a new case, um. Yeah, it looks like whenever we call it, we already know we're ran or Abidi. At least in most of these. Of course, many still algorithms already want random labidi. That's this rotate one. That's the only one I'm seeing. OK, I'll suggest it anyways. Um, OK else here you can tell them to figure it out, and if they want, they can figure it out by asking us to explain it. Blame Casey. He's the one who wrote all this stuff. I don't want to write a book about how to do this right now, but ask Casey if you can't figure it out. There's an exercise left to the Casey, OK. So there are. Four possible combinations of bodye and common hike Kitty. The remaining 15 minutes of this review will just be STL making cat noises. Possible combinations of Bodie and common um. Leave um. Above the. Umm. Buy dye. And common. We've handled. By dye and common. And. Ah, I'll just say forward. And. Common. Hereby bite I really mean bidai and stronger, but it's fine. I think that's clear and forward and common. Uh, cases above, um. But I come in forward comment the remaining cases. Umm. That would be. Bidai. Uncommon. And. Forward on common. Are. Ah. Are possible here. Um, the implementation. Below. Trying to make clear what I'm referring to in this else. Brace else brace just made me else block. Um, is the only possible implementation? For. Or non comment. Course. Umm. However for the buy dye non common case. This is invoking the. Uh, this is using. The forward only algorithm. Which invokes the predicate and. Let me put in the order of actual invocation, projection and predicate. On every single. Element. It would be possible. To. Find the last iterator. And then use the buy dye algorithm. Umm. 4 by die only iterators. This would pay and traversals only. Followed by order. Distance. From result to. Last um. Traversals. I see. Let's say backwards traversals. Projections. Predicates. That's not a. All that isn't a 100% guaranteed win. It is likely to be better, especially for expensive predicates and. When we are fortunate. To find the result. Near the last. I'll just say the last um. And if the uh. Uh, let's say argument. I'm trying to. I'm trying to avoid saying input because that has its own meaning. If the arguments are random and sized, we can jump to the end. Instantly, um, this scenario. Could occur. When the Iterator Sentinel pair. Is. Vector. Iterator cons iterator for example. OK, so where is the thing? Like I heard us um. There's a helper to. Make this easier. Uh, get final iterator on wrapped um. Should I just say, see existing usage and then talk about how we would want the? Callers to detect bite eye. Use this and then. That would so if the callers say if bite I use um get final iterator unwrapped and then call this unchecked function, that would end up being absorbed by the byte I common case then is that correct? Because get finite iterator unwrapped would convert that Sentinel which is a different type to the common case right? OK, um. The um callers? Iterator, Sentinel and Range can have if constexpr. For. By dye or stronger iterators. And use. Yet final iterator and ramped before calling the unchecked helper. Then. The. But I common. Case in the unchecked. Helper. Would absorb this scenario, so a. 4th. Case would not. Need to be added. Please see existing calls to. All I want, I wanna think thoughts that are bigger than four lines at a time. Here we go. All this all this complicated cpaws totally fine. The moment the UI annoys me, I'm like her. Angry cat face. Please see existing calls to get final iterator unwrapped. Uh, or bug Casey? Ask Casey. Uh, for. Assistance. As he has volunteered. Yeah. OK, always near the end of our review slot and I'm almost done with this algorithm. The remaining ones will be very similar, so I think we found the all the interesting issues here. There are four possible combinations of Vida uncommon we've handled. I'm checking my table here Bidi and common and forward and common cases above. The remaining cases by Dynon common and forward non common are possible here. The information below in the South block is the only possible amputation for four non common of course. However, for the binary non common case this is using the forward only algorithm which invokes the projection and predicate on every single element. It would be possible to find the last iterator and then use the dye algorithm for byte I only iterators this would pay N traversals. Only followed by order distance from result to last, backwards traversals, projections, predicates. While that isn't 100% guaranteed win, it is likely to be better, especially for expensive predicates and when we're fortunate to find the result near the last and if the arguments are random and sized we can jump to the end instantly. The scenario could occur when the Iterator Sentinel pair is vector iterator constant iterator for example. Fortunately there's a helper to make this easier. Get final iterator unwrapped the callers Iterator, Sentinel and range can have if constexpr for bodye or stronger. Iterators and use get final iterator unwrapped before calling the unchecked helper. Then the Bidi common case and the unchecked helper would absorb this scenario, so a fourth case would not need to be added. Please see existing calls to get final iterator unwrapped or ask Casey for assistance as he has volunteered to help. OK. OK, so let's validate this forward case before calling in today. Um, we've got it. Result. This is the unchecked form, so we don't. Worry about the parent thing here. Um, value initialized loop forever. Look at the first iterator through the projection stored. Invoke if that's equal to the value that we want. Remember result is first. There should be a new line between Unchained gift if statements style. There should be a new line between non chained if statements to make it clear where they begin and end. OK, so remembering the result. Sorry for scrolling up and down. Remember the result. We're looping forever. If the thing that we're looking at is the value then record it in the result. If not then don't update. Then after a new line step forward first if we have reached the last. Then that's bad. Ah. I'm saying ohh here because I'm like, have we verified that there's actually an element? We have not, right? This could totally be empty like this input could absolutely be empty. With no guarantee that we can look at an element here, so that's a bug. Yep. Interesting that this was not caught by test coverage. Why don't we pass them D ranges? I guess it depends on the algorithm, um. But that does indicate missing tests. I think we do have an empty range coverage test. Yeah. OK. I'm going to comment on this. Copied the test code from yeah OK, this is deep dereferencing. First um. Without a guarantee. Or just dereferencing first, but we haven't. Umm. I'll just say, but the range could be empty. Umm. This also indicates. Um. Missing test coverage. Do is uh, should I mention that result should probably be initialized to last to handle this case? Because like we got this right? Here, yeah, this loop is is. Uh, well, it's the last because it's not a common iterator. It's not like it's not. Ohh, you're right, yeah. So we we essentially need a um. A case here, I I hear your cat. Um, there's a. The cat is annoyed that we haven't verified that the the range is not empty. Um, so we say we essentially need a test coverage for non common ranges that are empty. Ranges that are empty. I forgot this one case or something like that, yeah. OK, so this is actually a slightly larger problem. I'm going to cancel this and comment on a large chunk of code. OK, so um, this is dereferencing first, but the range could be empty. Will need to actually just. In general, if we never find something, we need to return last. Do we ever? That's interesting, yeah. Both initialized Iterator comma first. It's attempted to be handled here, but it's conditional on if we hit the last here. Um, I don't know. Ohh, that's horrible. Yeah, this does take advantage of the fact that value initialized iterator should at least be equal, but but this is not valid for arbitrary iterators because. Assuming you have an iterator that. Doesn't participate in unwrapping and yet enforces. Same parent or same domain? This is trying to compare value initialized to a non value initialized. We can't do that. You can't do and everybody thinks you can't do it, but you can't. Yeah. And the the worst part or the most subtle part is that. Most the time you'll actually get away with this because we unwrap all of our cool layers of machinery and the four pointers will handle this. But you still shouldn't do this. All the standard iterators do this, but the concepts don't require it. Yeah, we yeah, we recently spent hours explaining this to herb for CPP 2, if I remember correctly. OK, so let's see so many things to explain here. This is dereferencing, so there's the. When I when I make two does I write them in all caps. As a reminder, don't actually hit publish before doing this value and then test coverage. OK, so this is dereferencing first, but the range could be empty. In the. Case. Said. In the uh. Let me begin by saying several issues here. All related. Is directing first, but the range could be empty, um when we don't find a result. Um. For example, because the range is empty. Or it's not empty. I'm gonna exhaustively mention all the possible cases, but nothing matched. OK, value in it. Uh, we need to return. Let me just refer to the standard's here. Last, last. Race. Last, last um. There's. Code below that attempts to. Achieve this with. Blah. Umm. But that is not allowed by the iterator requirements. Umm. Value initialized iterators. Are comparable with guaranteed equal. To other value initialized iterators. But they cannot be compared. To. Other iterators. Ones with parents. Should I say that I'll just say other iterators? I don't want to bring the parent thing in here. I'll mention parenthetically, um. In practice, um. Still iterators, uh, won't. Detect this issue. Because they participate in. Unwrapping. So. By the time we reach. This code. Um. The debug checks that would detect it. I've been unwrapped away. The standard. Fire. And it is totally possible. For user defined iterators to reject or two. I'm trying to avoid confusing negation to lack any unwrapping machinery. And simultaneously enforce the rule. Against comparing value. Initialize try will say parenthood with parented. Iterators. Um, OK, and then should I mention, yeah, I just mentioned this test coverage. Um, this indicates a lack. Of a test coverage. Or I guess I don't really care about the the value in it thing for the test coverage because that's kind of obscure the the the. The issue you filed about having test coverage with the parent iterator is may improve that, but at a minimum I do want to see test coverage for empty ranges. This indicates a lack of test coverage for empty ranges. Year. That are, um, this fundamental one would be used after this optimization is done for. Was it forward? Non common? Yes. Four non common in this case. OK, a lot of bullet points, um. We're like OK, final issue of the day and then it ends up being long. Um, several issues here are related. This is dereferencing first, but the range could be empty. When we don't find a result, for example because the range is empty or it's not empty but nothing matched, we need to return less last. There's code below that attempts to achieve this with if result is it brace brace. But that is not allowed by the iterator requirements. Value initialized iterators are comparable and guaranteed equal to other value initialized iterators, but they cannot be compared to other iterators. In practice, iterators won't detect this issue because they participated in. Unwrapping. So by the time we reach this code, the debug checks that would detect it have been unwrapped away. However, the standard however the standards requirements still apply and it's totally possible for user defined iterators to lack any unwrapping machinery and simultaneously enforce the rule against comparing value initialized with parented iterators. This indicates a lack of test coverage for empty ranges for non common in this case. OK, so this whole case needs a significant overhaul so I'm not going to spend too much time reviewing it, it is trying to do the right thing. Move result move first OK Umm very semi for the class and then export inline Casper fine less than fine last construct tag. OK so we got through we got through fine last who find last if fun and fine last not should be very similar. In fact when I go and re review this after changes have been made I think the first thing I'm gonna do is I'm gonna after checking find last I'm going to take find last if and find last if not I'm going to copy them into separate editor tabs and VS code. I'm just going to dip them because they should look very very similar with only the stuff around, um, how we test the predicate varying and any other variants I would want to look at. So other than that should be, and that would also detect things like notice card appearing on something not the other. Of course, it won't detect things that are common to all of them, but if we review find last first, then find last as the first thing we look at, then we can have high confidence that the rest will be appropriately updated. OK, so that's good. I'm not going to mark this as entirely viewed and I'll come back and review test coverage later. We know that. We know that the test will need to be expanded for the issues that we found. Um, so here, just glancing at this, this test does seem plausible. Um, it does need to be expanded somewhat like I can see, like we don't have missing, we don't have empty range of coverage because we always use a haystack of three things. It makes me a little nervous that this is so small. There are at least found enough found cases so the the the reason why I said it makes me nervous is we've had a couple of other issues where we have found bugs. For example because the only things we passed to 1 algorithm were like less than 32 elements and we had a bug that occurred as soon as we had 33 elements or more because there was a there was a check in the code that hey if it's small use like insertion sort. So net most code doesn't have. Excuse me. Most code doesn't have that sort of dependency on length, so here I don't specifically believe that we need like huge haystacks or anything, but we were certainly missing empty cases. It doesn't immediately occur to me whether there's anything else we're missing here, but I'll come back and review this later. OK. I'll go ahead and submit this review. Uh, I'll just uh yeah, I think this is definitely request changes, so. There we go. And I think that does it. So thank you for, uh, sticking with us until the end of this code review. I believe this one, this one will be our last of 2022. So we will see you next year. Thanks for watching.