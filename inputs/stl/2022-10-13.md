WEBVTT

>> Stephan: Hi, and welcome back to another VC libraries open code review. I'm Stephan T. Lavavej, a Visual C++ libraries developer. And today we'll be looking at PR 3035, adding std::views::zip from a new contributor, tylerbrawl. So this is 1000 line PR, 1311 lines, but it's entirely adding new code, not changing existing code. I'll be doing the final review of it, and Nicole has already reviewed this. For correctness. Uh. Now, I have not looked deeply into um, std::zip. The committee has been adding all this ranges stuff to C++23, so I'm vaguely aware of what it does, but I'll be looking at the standardese for the first time. So this describes this nice detailed description that Tyler has provided explains that this is a partial feature implementation, so it's not completely implementing the paper, but only std::views::zip The paper also adds a std::views::zip_transform, which we won't be seeing today, but it may come in a future follow up PR. So let me open up the tracking issue. Because this is a partial PR this means that we will not be getting the feature test macro. Because our policy is that we only define a feature test macro when a feature is complete and non buggy enough to actually be usable, if something is blocked by like severe compiler bugs, for example, we will refrain from defining the feature test macro until it is usable. So we won't be having this bit. Um, there are a couple of LWG issues that affect this. One is implemented. One is not, because it affects zip_transform, and there's a couple overlapping patch papers that do modify std::zip So we're going to need to open up all this stuff. This is the primary paper. And then the library issues we need to look at are this one and this one. OK. And this has all been added to the latest working paper N4917, so I'll actually probably be referring to that because the code has been patched extensively or the specification has been patched extensively. OK, so this should be easier because it's mostly adding new wording so we don't need to jump around a bunch of different places. So, and I think with zip, the one that we've already gotten, um, this seems really familiar. Um, the tuple and pair and vector<bool>::reference changes from. Or was that another paper? I think we already got those.

>> Casey: We do already have the tuple and pair changes from this. I think A. Jiang submitted that change.

>> Stephan: That's right. Yeah, so we we merged that a while ago trying to load all this state back in my head. The change log I'm explains all this. I think if we search for zip, yeah here we go. It's shipped, it's in the current production release VS 2022 17.3. So essentially the first part of the paper is implemented the tuple, pair, vector<bool>::reference that affects the existing library. So this will be the second of at least three parts. Um, so here's the zip paper. So tuple, pair, all this stuff is done. I go down. OK, so I think we have this. Is, explanations to integer class type, common_type stuff. OK, so the new zip stuff is in [range.zip]. That's a stable name. We're not going to be looking at zip_transform. And then there's also an adjacent and adjacent_transform. Um, do we have this? I think no according to this description, does this mention "adjacent"?

>> Stephan: No. No. "adjacent".

>> Casey: No. We don't

>> Stephan: So this is purely just zip.

>> Casey: Yeah, we don't have zip_transform or adjacent or adjacent_transform.

>> Stephan: OK. So we may be seeing several follow-up PRs. This is good. It means this is more bite size. We only have to look at one section worth of wording. OK. I'm just checking here to see if there's other edits that [range.zip] did outside. I'm almost certain that it's not. Lots of "Effects: Equivalent to:" stuff, a sentinel. OK, so now I'm going to close this paper and I'm just going to look at what's in the standard. Let me look at LWG issue. This is also updating a spaceship standardese again in [range.zip.iterator]. OK, so this has already been applied to the working paper. Yep. And this is the compatibility paper. Scroll down. What wording did this affect? OK, so tuple this has already been taken care of tuple-like. Yep, Yep, Yep. Calling a function with a tuple of arguments, equality for tuple, common_reference specialization. I can't remember if we got this. pair stuff, let me scroll faster. This also edits zip_transform? No. At least not there. Associative containers. OK, it did get rid of a pair-like concept. They've modified elements_view OK, so did change [range.zip.view] OK, so looking at the current working paper will give us all that. OK, great. So now let's look for [ranges.zip] Uh, did I search the wrong stable name? Probably. Ranges library. OK here we go "Zip view". [range.zip]. Silly me. OK. And OK, we got everything here. OK, so let's actually look at the code. And see if I can do side by side. Here we go. OK. So I want to minimize this real quick to see what we're looking at. OK, most of the changes are to ranges, about 500 lines, changes to our central internal header <yvals_core.h> and then adding a new test. OK, I like to start easy. We're adding. One new test directory, correctly spelled, uh, the paper number. I'm just going to check the title here because I think that's right, 2321R2, 2321R2. This is the same paper number, but this one is views_zip, correctly sorted. Yep, that looks good. So the test will be running in the internal harness. We got a configuration here. OK, so this one's a little custom. Interesting. Uh, we've got our banner, which is good. OK, so we've got a note here. Note zip_view::_Iterator defines ADL overloads for iter_swap and iter_move, so the test fails to compile unless /permissive- is set, so it needs strict mode. This issue isn't unique to zip_view, all view types whose iterators define overloads for these functions have this requirement. OK, so this is justifying why we've got the strict matrix strict meaning /permissive- This is, uh, uh, something that um, uh. Ideally we could just enforce strictness all the time, but um, because some legacy programs don't exactly follow the standard. We are supporting the permissive mode, including in C++20 and C++23 mode, even though it would be nice if we didn't have to. And that's why most of our tests try to compile with the usual latest matrix, which means compile in 23 mode and throw in a /permissive configuration. But if something absolutely cannot tolerate /permissive, then we set the strict option and we have a matrix of options for that. So that's what this is. So we're going to use the strict and ranges requires concepts. Latest means it's a 23 feature matrix, that's a correct, and then we're crossing it. So we're actually run this test four different times with TEST_INPUT, TEST_BIDERECTIONAL, TEST_FORWARD and TEST_RANDOM. It's very interesting. OK, I'm going to see why we need this. I'll remember that. But this is good. OK, I'm going to briefly look at the test. OK, good. We got our banner. OK, we'll see what this test does. I'll come back. This is definitely unnecessary here also because we're silencing that clang warning. OK, so let's work our way towards the product code central internal header. So here's a citation for the 2165R4. Now this one, this was just a patch paper. Did we have a top level? Did we have a tracking issue for this? Let's see. Half the, half the work here is just, um, information management, OK. So we actually do have a tracking issue for this. So we do consider a top level feature and I guess we're implementing incrementally. OK, so this is the correct cleaned up name and spelling. Yep. Is it correctly sorted 213, 216, 5, 2166. Yes it is, compatibility between tuple, pair and tuple-like objects. And then we have a explanation changes to views::zip only. OK, good. And then zip paper, previously we said it's pair, tuple, and vector<bool>. And now we're going to flip it and say what we're missing. Missing views::zip_transform, views::adjacent and views::adjacent_transform. Yep, 3 views. That's right. We've got that oxford comma there. Perfect. We're not defining a feature test macro yet. So no change to the feature test macro test. OK, perfect. So let's look at the product code. OK. <ranges> is including <algorithm>. Does <algorithm> include <ranges>? Let's check. <algorithm>. <algorithm> includes <xmemory> OK. I don't think that means it includes <ranges>. But let's check real quick. I think. OK, <ranges> is mostly a leaf header in the STL. Um, the stack adapter and the queue adapter, which are definitely leaves for the purposes of <algorithm> drag it in and our internal stuff. Nothing else includes >ranges< itself, so there's no circularity issue here. It is not great from a throughput perspective that we gotta drag in <algorithm>. Now in some sense it kind of it matters less because <ranges> is already quite big and the C++23 modules which we just implemented make this issue moot because it's so fast. But in the classic header world, there is a throughput impact of dragging in all of <algorithm>. <algorithm> is 200 something kilobytes. It's quite large. I'm assuming OK. Actually, I'm not sure why we need this. Uh, what are we calling here? Be _STD something, something. _STD invoke is from type_traits that can't be it. Same with _STD apply. What does it need? Yeah. declval. Yeah. Yeah. That's all we got yet. I don't see any use of algorithm assuming that it would be a call to a non ugly function. Just apply. That's all tuple stuff. I don't think this is necessary, or if it is, I'm missing something. We have it. We have test coverage. We have a test called include each header alone that we've had running for over a decade that make sure we can include each header from the STL in isolation so we can't accidentally use stuff, at least in a way that explodes if you never call anything. So I'm not too worried about snipping out and include that we're actually are using, but it sure doesn't look from this brief scan like we're using it. I'm going to recommend that we or I'm gonna ask why we're using it. Let's see, did Nicole ask?

>> Casey: Maybe they thought they use it for iter_swap?

>> Stephan: ohh yeah this did

>> Stephan: This did come up. Yeah it was _RANGES max Ah, that's interesting. Um. Do we need the ranges version of max? Yeah, our contributor here mentioned that. Yeah, I think this is still an issue. I I don't like the included <algorithm>, um, just because it's so big. OK, so where's the use of max? Now it would be parenthesized because of horribleness. We're maxing on an initializer list. And I'm assuming min is the UM. OK, 2 uses of min. This one is forming an initializer list. Yeah, that's. Those are pretty small algorithms. I mean relatively speaking, do we only define them in algorithm and not like xutility? Uh, this is gonna be horible

>> Casey: It's probably the case that _RANGES max is only defined in the algorithm because we haven't needed it anywhere else before.

>> Stephan: Right, the ranges one but I'm wondering if we could use classic uh, that element one is not.

>> Casey: I certainly think so. It looks like these are just different types, so they're integer class types. Or sorry integer like types. They're integer like types so they should work OK with std::min and max.

>> Stephan: Let's see, we've got. OK, these are the two arg forms.

>> Casey: We're not using a projection, right?

>> Stephan: Uh, it's implemented an algorithm. So even if we call classic. We haven't needed them before, but could we promote them is the question? Ah. Yeah, you're right. There's no need for a projection or any of that fancy powerful stuff. Where is max? It's in parens because macros. OK, this calls _Max_element_unchecked. Ah. This is the classic one. It just happens to occur after the UM. ranges stuff. OK, so we call _Max_element_unchecked. Where's that live? That lives in algorithm. OK, it's it's nontrivial. Ohh, it's nontrivial size because it also uses our vectorized thing, Alex Guteniev's minmax optimization stuff. So this is larger than it used to be. I was mentally thinking, Oh yeah, that's a tiny algorithm, but it's actually gotten a lot fancier and a lot more powerful. But otherwise it doesn't really have a lot of dependencies. Interestingly, we would like to use the vectorized one here. is <utility> a core header? It's not is it? Oh it is. ohh and we had that issue. All these complexities popping up. We've got this issue where um, core headers which we try not to have runtime dependencies. Uh. If we try to promote a vectorized algorithm to them, that doesn't work. We encountered this in another context. I don't think it was minmax. It was something else we were trying to drag up here and we ended up having to back that out. I think it was std::equal. Or something like that. So attempting to promote the minmax, even if it's just the classic initializer list one up here, um, that would be a problem. OK, so this is not it's not a trivial thing. Um. Dragging an algorithm is not awesome for throughput. But maybe people should just be using import std? Um, this is something we could potentially investigate in the future. The uh. The alternative is a code duplication. Extract a just a very simple hello world, just the core, not the stuff using the std::max or the vectorized version. That way we wouldn't need to drag in <algorithm>, and we could do that if we really needed throughput. <ranges> is I think, Casey is, um, more familiar with the throughput of <ranges>. <ranges> throughput is already pretty low, and I think it's possibly the header you would notice <algorithm> the least in just because the denominator is already large.

>> Stephan: If <algorithm> was

>> Casey: initializer_list and minmax could be in <xutility>

>> Casey: instead of <utility>

>> Stephan: Uh, <xutility< is non-core, right? No, <xutility> Ohh yeah that's the one that's non-core.

>> Casey: <xutility> is not core.

>> Stephan: Yeah, yeah

>> Stephan: this one can use vectorized algorithms just fine. This is where we put count, find, this one is reasonable to promote.

>> Casey: this is the one step up from <algorithm> spot, right?

>> Stephan: Yeah, that's a good point. That's why. That's why. That's why this exists. It could do that and then does <ranges> already include <xutility>?

>> Casey: Yes

>> Stephan: very very likely.

>> Stephan: Oh yeah, yeah. Because it includes like <string_view>

>> Casey: indirectly from somewhere. But yeah, certainly includes <xutility>

>> Stephan: Yeah, that's interesting. Um. Mostly I'm just thinking of the logistics because we've got that toolset up, toolset update I'm working on today that makes large scale code movement very obnoxious because it's reformatting a bunch of code. Aside from that, I see no reason why we couldn't promote this to <xutility> and then <ranges> wouldn't need it. Let's see, should I comment that and then say hold off on actually doing anything there until at least the toolset update's in and then we can move around code? Because I would hate for a comment to cause horrible merge conflicts and waste work. Um, the alternative is do this thing and then file a follow-up issue to go improve the throughput later.

>> Casey: As much as clang-format has changed everything in <ranges>, I think this PR is going to have terrible merge conflicts anyway.

>> Stephan: Yeah, but making it worse.

>> Casey: Not be that big of a deal.

>> Stephan: Yeah, um. I'll include a comment. Or should I just resurrect this comment? The. Yeah, the it is the same issue. So I think we can resurrect it. Um, OK, unresolve. OK, um. See, Casey and I talked about this in the video code review um. We believe that <xutility> would be an appropriate place to move the initializer. Say promote um, promote the classic initializer_list. Uh, actually, are they both using initializer_list? Uh, or was one using a non? init_list, but just arbitrary range sizes or sizes, is literally an initializer_list, and the other one we form braces, so init_list would be sufficient. There's no need for the ranges. Um, classic initializer_list overloads Yeah. No need for the ranges machinery as it is. Included or as it is, um. Uh, let's say I wanna say higher up. That could be confusing. It's uh. Included by <algorithm>.

>> Casey: What? <xutility>? Yes it is included by <algorithm>

>> Stephan: and is non-core. we use it to centralize. Yeah, I won't explain. Yeah, maybe I will explain. And already centralizes similar algorithms of wide applicability in the STL. Yes. That is non-core, I mean too much parenthetical. So the vectorization won't be problematic. Um. Let's see. Note due to the um. pending toolset update I wanna say it's 3155. Let's check. Yes, I remember correctly. 3155 #3155. Yep. Code movement may cause obnoxious formatting merge conflicts. I recommend waiting until the toolset update is merged before attempting to address this concern. OK. I should probably mention that the throughput impact is. We should say we agree about the throughput impact. we share @hewilk's concern about the throughput impact of <algorithm>. OK. Casey and I talked about this in the video code review. We share @hewilk's concern about the throughput impact of <algorithm> and we believe the <xutility> would be an appropriate place to promote the classic initializer_list overloads. No need for the ranges machinery as it is included by algorithm and is non-core so the vectorization won't be problematic and already centralizes similar algorithms of wide applicability in the STL. Note due to the pending toolset update 3155 code movement may cause obnoxious formatting merge conflicts. I recommend waiting until the toolset update is merged before attempting to address this concern. OK, we've got one line of product code reviewed. Onward. OK, so we've got some concepts here. OK, this is actually kind of annoying. Let's split that, OK? Yeah. Minify this OK, that's readable. OK, so we are translating over here. I was going to actually read the standard and see what's going on. We take a bunch of views and we get a view of tuples to references. So like if you've got a vector of ints and a vector of strings and the ints say 10,20,30 and the strings say "cute", "fluffy", "kittens", then you can get a zip_view that will give you tuples of references to {10, "cute"}, {20,"fluffy"}, {30, "kittens"}. And then you can go feed those to some algorithm or something and then use it as customization point object that does that. OK, one other thing that I want to be on the lookout for is usage of export. Because we have merged standard library modules, we need to make sure that every public name is marked with our internal _EXPORT_STD macro because forgetting that will not immediately cause any problems but is a bug. Eventually this becomes second nature to us, but for now we need to make sure that we check this. OK, so. Exposition-only concept does not get exported. Let's switch to highlight here, OK? So we've got template<class... Rs>. These are _RangeTypes. We've got a concept called zip-is-common, which is exposition only. And it's going to be true when the sizeof...(Rs) is 1. And common_range<Rs> && ..., so they're all common_ranges. And then using // to hard wrap because clang-format. Which may not be necessary, but it's OK for now with clang-format 15, which is better about this. Or, OK and it's good that the || operator is coming at the beginning of line because that's our convention. OK, I'm checking to make sure that everything is parenthesized correctly. Not - that they're not all bidirectional ranges, so the not is outside the fold expression. Good. And they're all common_ranges. Or. They're all random_access_ranges, and. They're all sized_ranges. OK. Nice. Looks good. OK, then we have a _Tuple_transform_closure. This is not depicted in the standardese up here at least. Is there anything else I can look for? tuple-transform OK, perhaps that's elsewhere. Search. What is this tuple-transform thing? I'm just being mentioned. Lots of "equivalent to"s. Did I already wrap? Come on. Here we go, range adapter helpers. OK, uh. Exposition only. Let's see, this is making a tuple. Ohh, I see tuple-transform is apply, the _Tuple_transform_closure is just the lambda. OK. OK, so that's what this is, um. OK, so we've got. What the callback type? I guess that's F. OK, this just calls it f here. I'm thinking should this be named _CallableType or anything? I'm OK with _CallbackType. We do pass it to invoke, so really it is a callable type. Um, the. The issue here is that in the STL, especially when overhauling invoke and std::function, all that we try to be very careful about terminology. If something's passed to invoke and it goes through the invoke protocol, the standard formally refers to that thing as a callable type, meaning there could be a pointer to member function or pointer to member data in addition to something like a lambda function or function object, and it is callable through some generalized syntax. So we tried to be very careful about saying that. If this was like _FunctionType, I would definitely ask for a change. I'm OK with _CallbackType here, it's not user visible. OK, so template <class _CallbackType>. This has to be constexpr. This should really be [[nodiscard]], it's internal. Um. It's not absolutely necessary. I feel like it should be [[nodiscard]], at least this one. There's very low risk of us calling this thing and dropping it on the floor. I don't know if this merits a comment. First, I'm wondering if _Tuple_transform and the others here need to be marked. Usually with internal helpers we do want to mark them, um, because why would you call this if you don't return it? Yeah, we always return this stuff. I'd say it's fairly low risk. Um, I won't ask for [[nodiscard]] here. I will think about it for the public functions. OK, so going back here, _Tuple_transform_closure is just making the lambda. Probably because defining this lambda is pretty obnoxious, so we want to centralize it. OK, so template constexpr auto _Tuple_transform_closure. We take a callback by lvalue reference. OK. We are noexcept because we only store a reference to the callback. So we're not actually copying anything, so we can guarantee that we aren't throwing exceptions. OK, so we're going to return. We instead of just using a capture default, we name &_Callback and this is a generic lambda so we're templated on class... _ViewTupleTypes. In place of T's we take _ViewTupleTypes&&... _View_tuples. OK so that's this so far here. And then we return. We make a tuple of the invoke_result_t. Here we've got to check that the types are exactly being mentioned, because the value category and cv qualifiers can influence the result. The _CallbackType& and _ViewTupleTypes... Yep, that's good. And then we're calling it with. Or constructing this from the result of _STD invoke(_Callback, _STD forward<_ViewTupleTypes>(_View_tuples))... OK, that's all good. So my. OK, so that's essentially this here, but not the apply that's elsewhere. And then this is the apply call template <class _CallbackType, class _TupleType> constexpr auto _Tuple_transform. OK, this takes by perfect forwarding a _CallbackType&& _Callback. So that's matching this constexpr auto tuple-transform that's depicted as F&& and then _TupleType&& _Tuple. Here we're strengthening. This being commented, is strengthened even though it's not actually a standard function. But because it's depicted in the standard as exposition-only, I think it's reasonable to have a strengthened comment here. We're noexcept if this is noexcept _STD apply. So it's just gonna be the body, _STD apply. Yeah, that all matches. So we're going to return _STD apply to avoid ADL of make that closure, and then _STD forward<_TupleType>(_Tuple) OK correct. OK, so that's this thing done, and then we've got a tuple-for-each same structure, where we've got one helper to make the lambda and then another to actually apply it. so template <_CallbackType> constexpr auto _Tuple_for_each_closure. And take by lvalue ref _Callback. This one's always noexcept because we only capture a ref return. OK, so now this is the stuff capture &_Callback, class... _ViewTupleTypes, take _ViewTupleTypes&&... _View_tuples The lambda itself could throw. So it definitely should not be noexcept or anything. Um. Here we are casting the result to void because we don't want to invoke any sort of overloaded comma, which is good. So we call _STD invoke of the callback and then _STD forward<_ViewTupleTypes>(_View_tuples) And then? What is going on here? This parenthesis is not actually necessary because what else could the void bind to? It's not wrong. It might help visually parsing it. I don't think I'll complain. I'm trying to be a little bit less nitpicky in my comments. And here are the extra parenthesis is not the worst. This is already pretty complicated expression, so I won't grind my teeth. If there's an extra paren here, it's unusual enough that I'm OK with it. Then , ... OK, so that's good. Very, very like the attention to detail that, um, the standard doesn't bother to avoid overloaded comma here, but we need to according to our policies, and a strict reading of the standard does indicate that that's correct. _STD forward. OK, very semi good. And then _Tuple_for_each is the whole thing. template <class _CallbackType, class _TupleType> constexpr void _Tuple_for_each I'm checking all the names are ugly and they are, um, _CallbackType&& _Callback, _TupleType&& _Tuple We're noexcept If this is noexcept, _STD apply(_Tuple_for_each_closure(_Callback), _STD forward<_TupleType>(_Tuple)); Again, it's marked to strengthen. That's fine. And then we just dropped the return value on the floor. No need to cast because _STD apply is not um. [[nodiscard]]. OK, that's good. So we've got the _Tuple_for_each Uh, close enough. Now we've got helpers. OK, let's go back to zip view. [range.zip] as we discovered. I want the whole stable name. If this will cooperate. Come on. Here we go. OK, this is not depicting an all-random-access, but I'm guessing it's going to come up here. Yeah, with that _Maybe_const stuff. OK. So what are we doing here? Again, internal machinery template <bool _IsConst, class... _Views> concept _All_random_access is fold expression, how did we ever live without them? random_access_range<_Maybe_const<_IsConst, _Views>> OK. _All_bidirectional is bidirectional_range<blah> _All_forward is forward_range<blah>, OK, that seems reasonable. Next stop. OK, another helper _Zip_get_smallest_distance. Is this depicted in the standard? Oh and looking here, this is from iterator. OK so we can highlight this because it's done, all-random-access. Yep, that's that maybe-const maybe-const, maybe-const? Yep, exactly find the standard names. Let's see, does it have a _Zip_get_smallest_distance? Likely this here. And there are some maximum stuff here. OK, where exactly is this called? It's called in the operator- of iterators, which is in fact what I'm looking at here. This is iter - iter. Where is the general -iter? No, I'm looking at sentinel here. iter - iter. Here we go. This stuff. OK. So let's go back up to the definition. OK, so what's happening here? template <class _ResultType, class... _LHSTupleTypes, class... _RHSTupleTypes> OK. And this is constrained to exist only when the size of the tuple types are the same. I'm not sure that this constraint is necessary. This is only needed when general. You only need constraints to disambiguate overload resolution. If this simply. If we can structurally guarantee that this is only called with identically sized tuples, then really this could be a static_assert instead of requires. In the olden days with um. When our only machinery was like SFINAE with enable_if, I would absolutely ask, yeah, this should be a static_assert. Concepts are not as egregious as enable_if and. It's still not conventional to use this when a static_assert would suffice. But it's not completely wacky. I would be OK with this. I wouldn't. I wouldn't have written it like this myself, but I don't view this as inherently objectionable. And perhaps someday it may even become good style. Just say, hey, you know, list your requirements up front rather than just assuming stuff and static_assert'ing if it goes wrong, I could see an argument for that. I kind of think the static_assert is cheaper in terms of throughput, but if it's not overloaded, I think it's about the same throughput anyways. OK I I'll leave this for now. I'm not gonna not gonna comment on that. Mostly because it doesn't really have user impact. OK, so this helper is marked [[nodiscard]]. That's interesting that the previous helpers were not. Slightly inconsistent, but at least this whole group wasn't marked and this is marked. OK, I'll get this so it's [[nodiscard]] constexpr. OK, so we explicitly specify the _ResultType. Probably because we have to determine or use difference_type or whatever. _Zip_get_smallest_distance, we take const tuple<stuff>& _Lhs_tuple const tuple<right stuff>& _Rhs_tuple This is not strengthened in any way. But neither is the operator- required to be. Is anybody calling this strengthened because we need to make sure at all levels. Ah. Look at this. So operator- is strengthened to be. I'm noexcept if this is noexcept what happens if we call _Zip_get_smallest_distance but then _Zip_get_smallest_distance is never marked. So this is identical to noexcept(false). So this is an issue. If we're going to strengthen here we gotta strengthen this. OK so now it's time for comment. Ohh wait no sorry wow, I can't parse this. It's hiding down here in this. I missed it because this // clang-format off looked like it was a body, but it's actually strengthened here. OK, so it is strengthened. So we're fine. OK, false alarm. Uh OK, so we take two tuples. Uh, suppress clang-format Probably because it was dealing with this horribly. Um, interesting. We're noexcept if fold expression. Which is why we've got that extra layer of parens here. OK, so all of these things have got to be noexcept, um. static_cast<_ResultType>(_STD declval<const _LHSTupleTypes&>() - _STD declval<const _RHSTupleTypes&>())) && ...) So it's asking if we pairwise subtract each of these left - right, left - right, over and over are all those expressions are noexcept. OK, that is correct. Assuming that's what we're gonna do here. Um, OK, I see. Casey, would you like to contribute something to the class?

>> Casey: I I would like to suggest that we use the names of the parameters instead of calling std::declval to get things of this type and and value category.

>> Stephan: Uh but then we would need get and we would need index because these are the elements of the tuples and we've got to crack them open. How would you phrase it? With the parameters,

>> Casey: ohh OK

>> Stephan: we don't have any.

>> Stephan: We don't have an integer_sequence here.

>> Casey: I was missing that. Never mind.

>> Stephan: OK. In general, definitely a good good question. Um, because if we could just mention the parameter names, then that's simpler. But here we actually do need this complicated full expression. OK, I can already see that we've got some std qualified size_t, which we should just not qualify at all because we're within std. The two occurrences of std::size_t here should simply be unqualified as we're within std, so we'll always find the typedef with no ADL concerns. Uh, the two occurrences of std::size_t here should simply be unqualified as we as we're within std, so we'll always find the typedef. No ADL concerns. OK, Um, wow clang-format like. It's really not having a good day here. Hopefully 15 handles this better. OK, so we're going to have a const auto _Get_smallest_distance_closure That's a lambda that captures the tuples by ref, and it is. Templated. Interesting. On a pack of stuff. size_t _FirstIdx I don't know why this is commented out as default 0. We don't pass anything here. I'm really confused as to what's going on here. There's only two occurrences. We always just give it index_sequence_for. we deduce. I I don't see why we need this comment at all. It it it's not like it's been declared elsewhere to be defaulted to 0. If index sequence is empty then. I'm assuming we can't call this at all. This assumes that there's at least one that's interesting. Does this have a? Does does this have trouble if we are attempting to zip nothing? I'm not even sure if that's well formed, um. But that's the first question I have when I see something cracking open a pack of types and then assuming that there's always one um. OK, so I think the comment should be there. Then there's a question of what

>> Stephan: happens if this stuff is empty.

>> Casey: zip nothing is forbidden by the requirements

>> Stephan: OK, wonderful. OK, but I think this comment should not be here. Um. Let's see, I uh, let's ask cause I'm could be confused rather than saying there's definitely no reason for this. And then it turns out there's a reason and I look silly. Let's see what's, um, the purpose of the comment /* = 0 */ ? There appears to be only one use of _Get_smallest_distance_closure Immediately below. And it deduces um. _FirstIdx so there's no default behavior. OK, what's the purpose of the comment /* = 0 */ ? There appears to be only one use of _Get_smallest_distance_closure immediately below, and it deduces _FirstIdx so there's no default behavior. OK, interesting. We are using tag dispatch because that's the only way here to get access to this list of types. if constexpr has not quite superseded that. So we take an index_sequence. Uh, _FirstIdx and then a bunch of indexes. Ah, OK. I'm trying to look at what the _FirstIdx is used for. Where is it mentioned? It's not mentioned. Oh, it's just. I see. I see what that /* = 0 */ means. Here. It's. It's acknowledging that the sequence will always start with zero because we're using index_sequence_for. So it's the comment is a reminder that _FirstIdx will absorb the zero and then the _Idxs are one and above here we just directly hard code zero to get the first stuff and then we look at the rest of them with the indexes. So it's not a default, it's a reminder of what it is. That's reasonable. Um, it's just because I'm reading it strictly top down that I was confused. OK, I'll retract my comment. I found the purpose. That's pretty thoughtful to have it, so thank you. Uh OK. So index_sequence<_FirstIdx, _Idxs...> I suppose it could have just been named like 0, but that's fine. OK, so what's going on here? We get a const _ResultType _First_size is static_cast<_ResultType>(_STD get<0>(_Lhs_tuple) - _STD get<0>(_Rhs_tuple)); OK, we're always doing left minus right? OK, if that first size is 0, so if there are no differences between the first iterators, then the smallest is. Well, you win. It's zero, we can just short circuit. Otherwise, maybe some of the other stuff is. Uh, otherwise we're non-zero, so maybe some of the other stuff is non-zero and we need to substract. Now, I'm assuming. This seems like it's assuming that none of these will be negative. How does the operator minus work? Is it doing some sort of absolute value? The value with the smallest absolute value. OK, OK, so if we find 0, that's by definition the smallest absolute value, so that definitely wins. But if we get non-zero, whether a little bit bigger than zero or a little bit less than 0, maybe we'll find something at zero later on. OK. And there's no algorithm that really short circuits, um. Interesting that this is not. We're not taking the absolute value out of all of these. Um. It's like doing the subtractions. And then? That's odd. I'm trying to think like what happens because I haven't completely read through this. Um, what happens if you have a mix of like negative and positive values? Some are tiny, some are big. Is what this is doing, which is not taking the abs immediately equivalent to what the standard says, which says the smallest absolute value. Because I would expect to directly translate the standards to apply abs, either call abs or do it manually and then find the min. But this is doing something different. So this forms an initializer list, A named one, which is a little bit unusual. It's not wrong. It's kind of using it as a container, which is kind of weird, but not wrong. Um. Then what? What do we what? What? Where are we giving the sizes? Ohh that it's being given to the ranges? OK. That could have used an array, but initializer list is what the classic algorithm will take. So here we actually do want that. OK, const initializer_list<_ResultType> _Sizes is brace whatever that first size is, and at this point we know it's non-zero. And then? Not a fold expression, but a pack expansion of _STD get<_Idxs>(_Lhs_tuple) - _STD get<_Idxs>(_Rhs_tuple) over and over and over. OK. And then we do this odd sort of absolute value thing if the first size was negative. Then. Say we have like -10 then we look for the maximum of the sizes because we want to find the biggest, but this is assuming everybody's negative. I don't think that's right because what if we have a mix of negative and positive, if we have -10. And then some of the other differences are like -11, -5, a billion, positive billion then. The ranges::max will find the positive billion and we'll return that. But really we should have said the smallest absolute value in this case whatever I said -5, absolute it and so should be like 5. Ohh I see it returns the value with the smallest absolute value. So if the smallest absolute value. Or if the value with the smallest absolute value is -5 we should return -5. We don't abs it, but we do want the smallest one. We should not return a billion. I think this is incorrect if we have a mix of negatives and positives. I think it was trying to avoid. Greedily taking the absolute value because we do need to return the original one, but I don't think this is the right way to do it. In some sense it's like the comparison should be done with absolute. We could give it a comparator that says here's how to compare two values you abs them and then you compare. But then we can find the minimum according to that metric and then return whatever that is. That would be the right way to do it. So we would only call min with a predicate. OK, I think this is a bug. Unless I'm seriously confused about how this works. It sure seems like the zip code, the minus should be able to handle iterators being at different positions, um. But I'm not really sure how. All these when zipping are they always marching in lockstep? But then I would have talked about the small absolute value.

>> Casey: I I'm I'm confused. I don't think it's possible to get a mixture of negative and positive values, but that's because I don't think it's possible for the iterator pairs to

>> Casey: ever get out of sync.

>> Stephan: Right. Right.

>> Stephan: Like, I'm trying to figure out, yeah, why does the standardese, why is it trying to handle, like, you know, you know, what's the different absolute value? When I see that, my mind really goes to, OK, what if they're jumbled, but if it's like we're doing this thing,

>> Casey: I think all the constituent distances should be identical and we should be able to return any of them from this function.

>> Stephan: Yeah. I mean, that's how, that's how a zipper works, right? So. Yeah. Hmm. That's really weird.

>> Stephan: Is that just a defect in this

>> Casey: because of int. No that distance doesn't make sense.

>> Stephan: You know like if some of the different types are like smaller than, bigger, but then but then you would run out of space like when the smallest one runs out of room for the different type.

>> Casey: Nicole, can you explain? To us stupid people is uh

>> Stephan: is Nicole on the call? She is not. So we are asking for telepathy. Um, that's interesting. So. I think. This does merit a comment. The question is, should it be an LWG issue? Uh, what's going on here? Um.

>> Casey: Sorry, I'm good. Nicole has explained it in the chat.

>> Stephan: Oh, oh, she's in the chat, just not on the call.

>> Casey: Where we have when our underlying iterators all common. The end iterator of the zip view is the end iterators of all the underlying views. And if we don't know the size of those underlying views, or they're not random access so we can't grab an arbitrary iterator out of them, then we don't know that those end iterators are actually in sync with each other.

>> Stephan: Ohh because you can exhaust some ranges.

>> Casey: Don't know how long the ranges are.

>> Stephan: But what happens if you exhaust ranges before others?

>> Casey: you are you were at the end if you exhaust one of the ranges before the others Yeah, the the the end of the zip view is when the first underlying range hits its end.

>> Stephan: OK, but. But in that case, aren't they still in sync? Don't they all still have the same value? Yes, the iterator values of that iterator are in sync, but. If you want to model common so your zip_view has an end iterator that it returns.

>> Stephan: OK

>> Casey: your underlying ranges are all

>> Casey: forward_ranges. They're all, say they're forward common ranges. Then your zip_view's end iterator is a tuple of the end iterators of all the underlying ranges. But they may have different lengths so that one that is the only value out of sync is int.

>> Stephan: Ohh weird.

>> Casey: The only way to get an out of sync value. Out of the design.

>> Stephan: Because otherwise,

>> Casey: and that's why the equality comparison says if any of them compare equal, they're equal. Because that way the end iterator and the end and the yeah sorry, the iterator you reach by iterating through the sequence will be equal to the iterator that end returns. Just by that, they have different constituent values,

>> Stephan: OK,

>> Stephan: because you're considering it

>> Casey: Thank you Nicole

>> Stephan: as soon as somebody is hit and OK. That makes sense. Um. Yeah, so. OK, so going back here, this is doing subtraction. And it's trying to handle the case of. What if one of these iterators is like the end iterator? You have to. Essentially, the position of it is virtually the one that's closest to the beginning, so the smallest absolute value. Is that right? That does get the right answer if you like subtract two end iterators, or if you're end - begin

>> Casey: or absolute value, because the left hand argument could be the end iterator value or the right hand argument could be the end iterator value.

>> Stephan: Yeah, yeah. And you can't have anything beyond that point, so you don't need to worry because, um, if you try to increment increment, you do stop as soon as one of them hits end. OK, so there's limited jumbleness permitted, but can't you still get into the position? The case I had where you've got like a small negative and a big positive? Can't you have that?

>> Casey: No

>> Stephan: ohh because they can't be

>> Stephan: relatively jumbled like that. It's either they're all in sync, or you are the end iterator

>> Stephan: and they're jagged.

>> Casey: Right

>> Stephan: If you ever have a jagged case that

>> Casey: you'll never advance past the,

>> Stephan: yeah so the. The uh regardless of whether one is before or afterwards in the jagged case, they all have the same sign. It's never possible to have a mix of negatives and positives in the jagged case and in the non-jagged case. It's also never possible have a mix of negative and positives. OK, so that's that's interesting. OK, so that indicates this is correct. Highly non-obvious. OK, so let's read this with new eyes. Uh, const initializer_list<_ResultType> _Sizes is _STD get<_Idxs>(_Lhs_tuple) - _STD get<_Idxs>(_Rhs_tuple) over and over. There's no short circuiting if we find a 0, but we already tried to find like the case where. And the thing that the optimization is reasonable because most of the time if they're non jagged, then if the first one zero, then hey you're equal you return 0. Otherwise if they're not, the answer is very very likely nonzero. It's only for like we're in a jagged case. You might find a 0, but we don't really need to optimize that, so I don't need to worry about short circuiting. OK, so then return. If the first size is less than zero, it's negative. Then we assume they're all the same sign. Try to find the maximum of the remaining sizes, because that one's going to be closest to 0 otherwise, if the first size is. Not less than zero, but in this case we know it's strictly greater 0 because we already tested for quality. Then find the minimum of all the sizes. OK, that is correct. Agreed. And then at the end of _Get_smallest_distance return _Get_smallest_distance_closure because we need to expand the pack index_sequence_for<_LHSTupleTypes...>{} and we've already required. That they be the same length. OK, that is. Reasonable. OK. And then an equal helper template <class... _LHSTupleTypes, class... _RHSTupleTypes> requires (sizeof...(_LHSTupleTypes) == sizeof...(_RHSTupleTypes)) Here I'm making sure that we don't mix up left and right. Very very easy. It's [[nodiscard]]. OK, so it's consistent with previous constexpr bool _Zip_iterator_sentinel_equal OK, so it's not iterator difference, this is. Are you just equal to a sentinel? const tuple<_LHSTupleTypes...>& _Lhs_tuple, const tuple<_RHSTupleTypes...>& _Rhs_tuple This one is strengthened. Not commented as strengthened, but this one is not exactly mapping to anything. In the standard, so that's fine. Um, we're noexcept if this fold expression is noexcept (_STD declval<const _LHSTupleTypes&>() == _STD declval<const _RHSTupleTypes&>()) && ...) Okay, comparing 2 const lvalues, they all got to be noexcept OK. Um const auto _Evaluate_equality_closure is capture left and right tuples by ref. OK, and then we're gonna go invoke it. Uh, template on size_t... _Indices. Take index_sequence<_Indices...> And then just apply is this equal to that equal: ((_STD get<_Indices>(_Lhs_tuple) == _STD get<_Indices>(_Rhs_tuple)) || ...) Ah, and you're equal if any of them are equal. Because you only need one to hit the end. OK, so that's why it's more. OK, so when we actually compute the answer, we fold over or. But when we compute noexceptness, all of them need to be noexcept. So we use and there. Here we're and'ing the noexcept. Here we're or'ing the answers OK, return _Evaluate_equality_closure(index_sequence_for<_LHSTupleTypes...>{}); brace brace for temporary tag. Yep, that's good. OK. Now we can get to zip_view and here we have our first _EXPORT_STD because it is standard. It's got here. What's what's cool about _EXPORT_STD is that for the range of stuff we actually need very few of them, because so much of it is like helper. iterators, helper sentinels, operator()s, so we don't need a zillion of them. It's great. Turn off clang-format for clang-format 14. This is OK to keep. Uh, we'll clean that up later once we merge with clang-format 15. Um, OK, so this is exported because it's public. template <input_range... _ViewTypes> requires (view<_ViewTypes> && ...) && (sizeof...(_ViewTypes) > 0) OK, we have a class zip view. derived publicly because it's a class, from view_interface<zip_view<_ViewTypes...>> turn on clang-format OK, private data members. Uh, [[no_unique_address]] commented out. Someday it's gonna be cool. We have a tuple<_ViewTypes...> _Views; OK, that's that. Exposition only. So we got this here. And then, template <bool _IsConst> struct _Category_base {}; And I believe that is the convention name. template <bool _IsConst> We specialize with requires if they are _All_forward. Assuming that's specified for, what are we doing, iterator here? Let's see, this is an iterator. Do you have a specialization? This one says forward_iterator_tag. Trying to see if there's two separate standardeses. No, there's not. OK. Let's talk about iterator category. I see. OK, yeah, this is this is implementing. This here. Uh. But wait, is this is this wrong? Um. _Category_base. Primary and then template <bool _IsConst> requires, when they're _All_forward 01:02:17.000 -> 01:02:22.860 _Category_base<_IsConst> using iterator_category = input_iterator_tag; Um. iterator_category is present if and only if all-forward is modeled. OK, what is the category? Is the category input? OK, category is input so this is correct even though it doesn't seem like it is OK. So the category is conditionally input OK. My brain is like if I see forward here, this should be forward. But no, the standardese is more complicated than that. OK template <bool _IsConst> class _Iterator : public _Category_base<_IsConst> Okay so that gets us the typedef. These are structs so that's publicly available. That's good. private data member, /* [[no_unique_address]] */ tuple<iterator_t<_Maybe_const<_IsConst, _ViewTypes>>...> _Current; That is this. OK. friend zip_view using extended friend syntax. Ah, let's see. Do we need that? Yes, we do because I'm a member as a child class, so I can access the parent class's contents because I have the same access as any other member. But if the parent wants to access the child class's contents we need to declare friendship. OK then we have constexpr explicit _Iterator(tuple<iterator_t<_Maybe_const<_IsConst, _ViewTypes>>...> _Current_) And that is going to be. Is that even depicted? Not actually depicted. Uh, this is private. Um, do we have an exposition only? No. It's just. The standard just assumes that we can. Ohh I see this one. Where is this coming from? Where was that declared? Did I just scroll over it? Ohh, it's hiding up here. OK, so it is mentioned in the standard, it's just exposition only, OK um. constexpr explicit _Iterator(tuple<iterator_t<_Maybe_const<_IsConst, _ViewTypes>>...> _Current_) Ah, how many times does this occur? Can we extract this with a typedef? Every time. 5. Ohh that's out there. Three is annoying enough that I do want to ask for extraction. Any more would be and my usual rule is if it's mentioned three times and if it's lengthy then. It's reasonable to extract. And it wraps here, which is really annoying. I'll suggest it. Um. This here we go. This thing is the one that occurs, yes. Occurs 3 times and is verbose enough to cause wrapping. Say Suggestion: Um, extracting a? What do we want to call this, _Current_tuple? Maybe?

>> Casey: _My_tuple?

>> Stephan: _My_tuple that that would be the more classic name, but _My_tuple _Current kind of sounds weird. At least _Current_tuple would reinforce the. What we're talking about. It is _My_tuple because it is the only data we're storing. I'll offer both suggestions. _My_tuple typedef. or any other name? I won't be too picky about the name. Would help credibility. OK. Suggestion: tuple<horribleness> occurs 3 times and is verbose enough to cause wrapping. Extracting a _Current_tuple or _My_tuple typedef (or any other name) would help readability. OK, otherwise just fine. Um, we're noexcept if - only one noexcept, two is a bug. If is_nothrow_move_constructible_v of blah. OK, because we do move it in strengthend current, move current, OK. Public. So iterator concept see below. Um, but here we go. iterator_concept is if _All_random_access<_IsConst, _ViewTypes...>, then random_access_iterator_tag. If they're _All_bidirectional, then bidirectional_iterator_tag. If they're _All_forward then forward_iterator_tag, otherwise input_iterator_tag. OK, good. Using value_type oh, here's the value_type um. That is the type def. If only this were up a bit, um. No, it's different. Oh, it's range_value_t, not iterator_t OK, so we can't use that typedef using value_type is tuple of range_value_t. Let's say here we go this here. using value_type = tuple<range_value_t<_Maybe_const<_IsConst, _ViewTypes>>...>; using difference_type = common_type_t<range_difference_t<_Maybe_const<_IsConst, _ViewTypes>>...>; _Iterator() = default; constexpr _Iterator(_Iterator<!_IsConst> _Rhs) This is strengthened here. And it requires um. The strengthening is. (is_nothrow_convertible_v<iterator_t<_ViewTypes>, iterator_t<const _ViewTypes>> && ...)) That's. Us. convertible takes what we are and then it's saying converting to? Is that the right order? That doesn't look right. Um. Let me let me come back to that. What is the requirement here? So requires _IsConst I got to be const because I can construct a const iterator from non-const, and convertible_to<iterator_t<_ViewTypes>, iterator_t<_Maybe_const<_IsConst, _ViewTypes>>> So saying for all of the component iterators the modifiable one, the iterator for the modifiable view has to be convertible to the iterator for constant view. You can always add constness, so that's fine. Because we're constructing an iterator. We're constructing our iterator of const because we're const from iterator of non-const. Yes. OK, so then this is asking. This is mirroring it. It's saying OK, OK, I think I think this is right. Um. is_nothrow_convertible_v iterator_t<_ViewTypes>? Not not doing the _Maybe_const thing. So this is actually. The types within the RHS OK, and can we convert those to iterator_t of? This is _Maybe_const, not const. I think this is wrong. Because we're converting to us and we are _IsConst, not !_IsConst. Like essentially the the strengthening here should substantially mirror the requirement for convertibility, except it's going to use this go through convertible_t is the requirement is the requirement busted? Did I miss that because it's using _Maybe_const?

>> Casey: Standard doesn't use _Maybe_const here.

>> Stephan: Yeah, good point. OK. So yeah, you're right. requires is busted. And then? I'm virtually certain the strengthening is not right. It they they should mirror, essentially it should be is_nothrow_convertible_v iterator_t views to iterator_t constant views because it's not just enough that it can be convertible like this describes the conversion we're going to do. Then we need to ask, can you do that without throwing? Um, so it needs to use the type_trait rather than the concept, but otherwise it should be identical. OK. Yeah, I think, I think this bug,

>> Casey: Agreed.

>> Stephan: I'll comment on that. OK, thanks. It's always nice to know that I'm not just jumping on phantoms. Um, OK uh, _Current(_STD move(_Rhs._Current)) uh which will do a component wise move of all the stuff in the tuple. So at least that's easy. You know, I'd really love to have noexcept(auto). I'd love to have requires like if I'm just well formed and I know why the standard at least doesn't have just requires of the body is well formed, I'd really love that noexcept(auto) though, having to spend, I mean look, the specification for the constructor is like 10 times the size of the actual implementation. Uh, the compiler knows whether this stuff is going to throw. Um, we're definitely working around a limitation of language here. OK, let's comment here. Should I have? Two comments or one comment? Cameron's joking that that'll be his next hackathon project. I think probably 2 comments because they are different. Let's come in on the requires first. Here I will give credit. Uh Casey um noticed that? the standardese says let's not highlight here, let's get everything here. Um. But uh. Which doesn't use _Maybe_const? Actually, now let me say, um, so this you, or so the usage. Of _Maybe_const here appears to be incorrect. OK, Casey noticed that the standardese says convertible_to<iterator_t<Views>, iterator_t<const Views>&gt && ... So the usage of _Maybe_const here appears to be incorrect, because that's the one missing thing. OK? Got it. And then a comment about this here. Um, so we think the iterator_t<_ViewTypes> is right, but this one should really be const. So and in fact. Even ignoring that like this is _Maybe_const<_IsConst>. this is _Maybe_const<!_IsConst>, so that's just opposite. I noticed that. This, uh, should I comment on the whole thing? No that'd be distracting to get the signature in there. That this exception specification says. Uh, let's see. Should I just extract? Nah, extract the whole iterator type. How many angles is that, two? Uh. But uh. Let's see. We are. There's um, should I mention there's two issues here, but (1) that flips the constness. I wanna say flips. That has the opposite constness of what we're actually. Converting here. Uh, let's see. I'll explain because this is confusing. This constructor is using a. This constructor takes a non-const iterator as the source. To construct a const iterator destination, so the is_nothrow_convertible_v. Uh type trait Is given the non-, alright. Should be given. I want to avoid any confusion about like what it should be given versus what we actually wrote in the source code. Should be given the non const source iterator first, which it is. iterator_t<_ViewTypes>. And then it should be given the const iterator destination second. OK, I think I have explained that. Um. OK, and this is big enough that I really want bullet points. One. Then two. Let's see. This should match the requires clause, which says. Select again. Let's grab the whole thing. Let me explain. Um except changing. Except using. is_nothrow_convertible_v instead of convertible_to, which says iterator_t<const Views> For the second argument. OK. I noticed that this exception specification says iterator_t<_Maybe_const<!_IsConst, _ViewTypes>>, but that has the opposite constness of what we're actually converting here. This constructor takes a non-const iterator as the source to construct a... I'm getting confused. Let me restart. I noticed that this exception specification says iterator_t<_Maybe_const<!_IsConst, _ViewTypes>> but that has the opposite constness of what we're actually converting here, this constructor takes a non-const iterator, correct, as the source to construct a const iterator destination. So the is_nothrow_convertible_v. type trait should be given the non-const source iterator first because we go from to to, which it is, iterator_t<_ViewTypes> and then it should be given the const iterator destination second, I'll bold that because that's the important bit. OK, two. This should match the requires clause, except using is_nothrow_convertible_v instead of convertible_to, which says iterator_t<const Views> for the second argument. I'll credit you again, similar to what Casey noticed. There. OK. That one tiny little character. Not expanding to a big comment, but I think we got this sorted out. Um, this sort of thing is just. It's possible to test, but it's really obnoxious to test. You gotta write a lot of test support code to validate this tiny thing. So I wouldn't ask for test coverage here. It's totally understandable how it's missed. I'm satisfied if the code expresses the conversion that we're actually gonna do. I don't think we need test coverage of this. OK.

>> Casey: Uh, the comment in the middle of the screen right now.

>> Stephan: Yeah

>> Casey: Appears to be incorrect. Isn't really quite true. It's correct because we we've constrained _IsConst to be true already by the time we get here. Yeah, it's just a little overcomplicated.

>> Stephan: OK, good point. Yeah, because we are. Yeah. requires _IsConst. OK, good point. Um. Um. We've constrained. What to say? The constraint has already guaranteed that _IsConst is true, so using. _Maybe_const<_IsConst> is correct, but overly, but unnecessary, unnecessarily verbose.

>> Casey: Yeah, that that'll work. And now I'm wondering if maybe some of this is overly complicated to avoid clang bugs with, uh, premature substitution.

>> Stephan: Then then it should be marked as, um, transition.

>> Casey: Um yeah, true. Yeah, we'll find out. I'm not worried about it

>> Stephan: OK, the constraint has already guaranteed that _IsConst is true. So using _Maybe_const<_IsConst> is correct, but unnecessarily verbose. OK, thank you for that correction. Ah, let's see. I think we can get through. Can we get through the rest of the iterator? This iterator's big. Uh, let's see how much we can get through the next 5 minutes. OK, so we got a deref. Wow. Iterators can dereference constexpr auto. OK, so now we're gonna pay attention to whether things should be [[nodiscard]] after the constructor, dereferencing should absolutely be [[nodiscard]]. constexpr auto operator*() const. This can be strengthened. Um, OK, so we've got a nontrivial strengthening here. We're noexcept if this fold expression is all true. We need to be able to dereference a std::declval<iterator_t<_Maybe_const<_IsConst, _ViewTypes>>>() so potentially apply constness to each of our component iterators. They all have to be noexcept. Because we return a tuple of references, so at that point we're fine. This looks correct. The parenthesis here is not necessary because it's unary and there's no other way it could bind. I won't comment on it, it's not wrong, and again, this is a pretty complicated expression, pretty complicated code. If this were a smaller PR and this were like the only issue I found, I'd probably comment on it, but this is fine. Trying to be a little bit more easy going in my reviews. OK, and then this is going to return _Tuple_transform. Interesting, we have a stateless lambda. That takes an auto& _Iter because the _Tuple_transform works on every component of the tuple. Is that right? Trying to remember, it was like, yeah, an hour ago we reviewed this. _Zip_gets_smallest_distance, no, _Tuple_transform, apply to every element that will invoke something. That's... high powered machinery for, it's just a lambda invocation, but that's fine because it's the one that we use for users as well on every element of the tuple. OK, so. We use it down here. Here, _Tuple_transform(lambda), take auto& _Iter. And we're going to return decltype(auto). This is necessary. So we don't get any sort of decay. return *_Iter on the current tuple. OK. And then that will return? _Tuple_transform should return a tuple of references. Let's make sure that's right because we're not directly naming the type here. I think it is because the decltype(auto) and we used invoke_result_t _Tuple_transform returns whatever std::apply does. Interesting. And then the _Tuple_transform_closure returns, here we go, a tuple of invoke_result_t So if the lambda that we give it returns a reference, which it does because it returns decltype(auto) of dereferencing, and ideally, that's your return reference. Um. Then we're going to get a tuple of references. That seems right, and if it happens to return a prvalue, which you could get for an input_iterator, that'll participate in the tuple as well, and I'm assuming without looking that that is what this does. Yes, this is directly translating the standardese, OK? I'm convinced that's right. So that is, this is Effects: Equivalent to, wonderful. And. OK, incrementing. Not [[nodiscard]] because we can definitely discard this, constexpr _Iterator& operator++(). And then this is strengthened, we're noexcept if this is noexcept, can we call _Tuple_for_each with essentially what we're doing in the body here? OK. It's too bad we can't centralize that lambda. Um, Effects: Equivalent to tuple-for-each([](auto& i) { ++i; }, current_); return *this. OK, looks good. Um, constexpr void operator++(int). This one also strengthens. noexcept if noexcept pre increment. Again, redundant parenthesis, but it's consistent, which is good. std::declval<_Iterator>() That's us. Uh, why can't we just say *this here? We have access to *this in, um, noexcept don't we? We we had problems like. I'm asking because we had problems like 12 years ago when noexcept originally occurred. I'm virtually certain it's OK now. Where does that occur, so like, noexcept(*this) Or not. I'll do that. Let's do it. Regex search noexcept.*\*this. OK, concepts can do that. Yeah, when we when we're comparing to arrays. Yeah, we can totally mention *this. Um, I think we should do that. Uh. Because it is the body. Uh, I believe we should be able to say. noexcept(noexcept(++*this)) OK, that's right. Just do that, return void. And then post increment. This can be the last one we look at. Um. Sorry, not post increment. Alright, it's the other post increment, um, the one that is constrained for _All_forward. OK. Where is that this one here? So constexpr _Iterator, again, discardable. operator++(int). It's going to have requires, but first we have a constraint. This actually occurs repeatedly. The um. Update this: Occurs below, also for decrement. Um, so this one here that requires noexcept if we can pre increment? Sure. And because we return by value is_nothrow_copy_constructible_v<_Iterator<_IsConst>> Oh, that's our const. Why does this say _Iterator<_IsConst> and not _Iterator? Um, using the injected class name? That's us. That should just be _Iterator according to our conventions. We've access to the, UM, the injected class name. Even in noexcepts, there should, there should be no reason we can't use that. How, how, how, how often did this occur? Very rarely OK. Uh, that's the first occurrence again in, um, post-decrement. And. This is separate because this is in zip_view itself, so we do need to mention _IsConst there though this is like _Sentinel. Yeah _Sentinel<_IsConst> needs to form _Iterator<_IsConst> So yeah this is these two are the ones that should just use the injected class name. Let's see. We should be able to use the. Let's be fancy, italics, injected-class-name under _Iterator here instead of saying _IsConst. Occurs below in operator--(int). OK, we should be able to use the injected class name _Iterator here instead of saying _Iterator<_IsConst>, occurs below in operator--(int). Yeah. OK, that's a strengthening and then requires clause. _All_forward<_IsConst, _ViewTypes...>. We make a const auto _Temp that does not appear in the standard, is *this. ++*this; return temp; Uh, let's see. Does that const interfere with, um, the return value optimization and the move semantics stuff? I think I've actually lost track of whether it's, uh important. I think we should do what the standard says and not mark it const? That's one of our exceptions, to apply const to everything by default. Is that right, Casey? That. Uh, this local variable should not be for this um, post-increment where we should say where the standard says say auto temp is this, increment this, return temp, marking that as const. That inhibits the automatic moving and maybe the named return value optimization. I think it doesn't inhibit NRVO?

>> Casey: Yeah I don't think it should inhibit NRVO, but yeah, definitely automatic move is going to be inhibited. Yeah, if it's not useable for some reason.

>> Stephan: Yeah. So I think we should, uh, omit the const here, despite our love of const everywhere.

>> Casey: Yeah, I would rather that we didn't const things that we're gonna return, yeah, for that reason.

>> Stephan: OK, um, although const is one of our favorite keywords, and we mark local variables with it whenever possible. This is a rare exception when returning a local variable. This can inhibit automatic moving if the named return value optimization doesn't activate for whatever reason. The standardese depicts auto temp, and we should use. Uh. non-, just skipping words we should use non-const auto here to match it. Occurs below. OK, although const is one of our favorite keywords and we mark local variables with it whenever possible, this is a rare exception when returning local variable. This can inhibit automatic moving if the named return value optimization doesn't activate for whatever reason. The standardese depicts auto temp and we should use non-const auto here to match it. Occurs below. OK. And we are now at time limit, so I will, I think, submit a partial review looks like we actually got halfway through this header, even though it feels like we've haven't gotten that far a lot. There's a lot of the logic in the iterator. The actual view itself is pretty small in comparison to its iterators, because iterators are where all the fun stuff happens. We've already seen how it forms the dereference of everything and compares two iterators by using equal or subtraction. So it's pretty cool. Um, I will submit a partial review and then come back to this later after the toolset update and finish reviewing so we can get this ideally into 17.5 Preview 2, although depending on logistics it may or may not get into that release. We're gonna try though. Umm, OK. I'll submit this offline. Um, as always, um, thanks for watching this and we'll see you next time on Open Code Reviews.