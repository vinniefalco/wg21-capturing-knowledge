WEBVTT All right. Hello everyone. Welcome to another open code review. This week we will be taking a look at the OR an implementation of the ranges fold algorithms. Fold left, fold right. Etcetera. Umm. Share my screen. So one of the interesting things about this is that I already reviewed this because I forgot that we needed a video code review this week, and so the changes have. The changes that I requested have already been upstreamed, however. We will be. Looking at the. Paper, as well as what the original implementation was. It was a really good original implementation. There were very few changes that needed that we needed, although there was an interesting LWG issue that we needed to file because this the implementation as written in the paper accidentally reinterpret casts or constant casts, and so I will show you the process of. How? How to submit an LWG issue what that kind of looks like? At least my process for doing that. I don't know, maybe other people have different processes, but. Cool. Alright, so this is the paper we're going to be looking at this week. We, uh, are doing uh, Jay? Miss arkivmusic. Jam uh, sorry if I mispronounced your name. Uh has done the implementation here and you did a fantastic job, so. Uh, thank you very much for that. So the paper here it's if you've ever used some kind of, uh, functional programming language, you'll be really familiar with this if we have. Basically you have ranges fold or you have fold of a range, an initial value and then a. A. A function. And you basically. Let's see if there is an actual. Oh gosh. OK, let me, let me write it up. So if you do something like fold of some range R. Say 123. Then an initial value of 0 and the function object add then this is equivalent to, you know, add 0. Add one, add 2. Ohh I guess. Are now. That's definitely not how that works. OK, add one, add 2, add 3. At 0 something like that. And basically there are ten of two ways to do this. You could either have this fold be, you know, have one, add 2, add three at zero and zero, or you could have something like. That um and both of these are valid uh, choices. See, I missed that. Both of these are valid choices. I believe that this is a fold left and this is a fold right. Basically, that's that's how that's that's how this works. Um. So let's take a look at the. Paper itself. This is all you know fine. But let's look at the actual. Code that we need to add. So first, we've got this feature test macro. TP lip fold. We have a new result type. You've got. Flipped, which is an exposition only. Type um, that basically. Allows us to write indirectly indirectly binary write foldable concept easier and directly binary left foldable concept which. Wow, that's Tim. Do you, uh, left fold? Um. Or or it allows us to figure out when a function is left, foldable, got, fold left, fold left first, which allows us to. Do this without do do calls do. I don't wanna say this. It allows us to fold without the initial value, so if you look. That's the thing that I just closed and should not have if you have fold. 123. Add. Sad. If you don't want this initial zero, you can also have a fold first. 123 add. Which becomes ad. Something like that? Umm. So we've got fold left. Taking Iterator, Sentinel and range, Fold left first. Taking Iterator, Sentinel and range fold right. Taking Iterator, Sentinel and range fold right last taking Iterator, Sentinel and range which is the equivalent of full left first, fold right and then finally we have this interesting fold left with either or ITER fold left with utter. Wanna call it which? Takes the iterator, the Sentinel, the initializer, and the function. And unlike fold right which takes a bidirectional iterator, and so. It isn't like useful for us to return the iterator from fold, right? Uh, because we have to like, construct the, construct the last, and then kind of. Move to the left or to the front of the range with fold left, we could we just take the 1st and move right through the range and so as part of that we actually do get the final iterator. So for example if you have a. And a fold that's doing something on a 0 terminated. Array. Then your Sentinel will be. Something that returns true when you have a 0 termination and this fold left with Itter will go through and do the fold, and then it'll also give you back the actual iterator that we've discovered just by virtue of running through the list anyways. And then pull efforts with there is the same but without the initial value. Finally we get this struct invalue result, the actual declaration of it. And then this gives us the actual wording. Now. If you look here. One thing is that this hash define you'll notice if we go to the C plus draft. Virgin dot sign. You will notice that CPP live fold is not what actually got voted into the working paper and so. This is the actual hash defined of CPP Lib ranges fold and if we look at our. We look at our code. In fact, this person looked at the paper, which is a totally fair thing to do and they gave us this CP Lib Fold which is correct by the paper but is incorrect by the actual working paper that. They have set up and. So first thing we have to ask for is for CPP Lib fold to become CPP Lib ranges fold. It's a pretty easy change, you know they have to change this here, they have to change it in. Very. They have to change it in here. Yeah, easy change. And so they did actually do this, so let's. Let's open up that version of the changeset. And we can see. They've changed CPP Lib Ranges or Lib Fold to CPP Lib ranges folds. So that's fine, we've seen this. Totally great. Um, now let's take a look at algorithm. Which is where the actual code is. We we've added optional and you'll notice in and just fold. Come on, they're so fold. Left first. There we go. Fold left first. Returns an optional. Gosh, OK, I'm actually going to open this in uh. In the US because it's much easier for me to read. So if we go here. Hmm. Yeah, so this returns a ohh that's it. Really? Oh yeah, yeah. So it returns a range. Uh, this, like. Value. And it returns an optional. Basically. So we need optional now and algorithm. Hello. Flint is. Fine. It's in here it is not. Ohh my gosh. Ohh algorithm outside. So got a new flipped. Template Class F, class flipped F. Template class and class flipped FF public. Template Class T class you require some vocable FNT UT. Template Class T class U requires invocable F&amp;UT invoke results TF&amp;UT. TF and UT operator open paren close paren T&amp;NUN, end operator open paren close paren TNN. This is correct. Um. Going to assert these are all correct because I did actually do the check before. It's not very interesting. We get 2 new, uh, result types. We have fold left with utter result, fold left first with inner result which are just straight equivalents to in value result. Right. Here hold left with their result equals in value result holds off first with the result equals N value result. OK. Then we have fold left with ITER unchecked, so this allows us to have the same function. That does like the unchecked machinery because we have this iterator unwrapping thing in our standard library, but it actually does the actual work, so. Fold left with it or unchecked we'll do the actual work of. Fold left with it or. So if you got a full left with hitter. Which is? Here. Right here. We should have exactly the same code. It takes an iterator, Sentinel, a tie, and an F. Iterator, Sentinel, tie. Then. We get using utai equals to KT blah. You equals to KT. Invoke result TF&amp;T at a reference T. Yeah, that looks correct. Return type is. Fold left with it'll result it you type. Return type is for that. It's a result I you. And fold left without a result buttered iterator TRU. So. We'll notice here that. Uh. This return type is incorrect. Four fold left with utter of arrange type. However if we go down to fold left with inter over range. We do actually do this kind of. We do this kind of copying back into the correct? Um. And one of the things I noted was that this actually results in a triple move of you result dot value inside or no, just a double move of your result dot value when it could just be moved once. And so I've actually requested that. This unchecked function, uh? Not to do this, but the actual really important thing that I was noticing was yeah OK if first equals equals last return return type should move first. You tie stood move in it seems fine right? We've got this same code in the standard library and then else we have this U accumulator equals stood invoke function of init and 1st and start first. Which is exactly what we have here. Then we have 4 plus plus first first is not equal last plus plus first. Yeah, that looks correct. Accum equals invoke of F stood. Move Acomb started first. Yep, that looks correct. And we return, you know, stood moved, first stood move, Kim. So that all looks correct, however. We have a problem here. And it's a problem that you may have noticed if you. Really like weird stuff in the standard, but is really really confusing if you are not like well versed in standard's and that's. That this is a functional style ccast. Now if we look into the standard. See, I think it should be an expressions. And then I cast Santa, cast reinterpret, cast. Expert dot cast. So. We have. OK. Ah, yes, OK. I don't. I don't know how to say I I don't know where it says this, but basically a function style cast where you have type open paren. Can you see if you have the actual link? That would be very nice. It's expert.type.com. Simple type names or simple type specifier, type name specifier, followed by a parenthesized optional expression list or by a brace, and it last instructs the value of the specified type given the initializer. OK. If the ohh there we go. Yeah so. This is this is what this. Thing is, it it it's a explicit type conversion functional notation. Now we notice if the initializer is a parenthesized single expression. Which this is. Tech, but this is what that is. The type conversion expression is equivalent to the corresponding cast expression. Which is what this is. Which is a sea cast. So what it does is a type ID in the parentheses cast expression. And so if you have a functional style cast like this. What C++ will try to do? To get this to compile. Is first. They can't cast. Followed by a static cast. Followed by a static cast, followed by a cast cast, followed by a reinterpret cast, or finally a reinterpret cast followed by a constant cast. So basically if you have any kind of pointer. Yes, either Utah or the type of in it like tie here. You have a problem. Because, uh, Utah as suddenly um. You you can do a cost cast, you can do a reinterpret cast. If Utah is, I don't know, int star and stood move in it is class star. This will just work. And it will return you the reinterpret casted instar from castar. This is a problem. This is the fact that the standard is asking us to do a reinterpret cast or a constant cast. Here is a problem. The correct thing to do here is to explicitly ask for what we want, and the only safe cast is a static cast. And so we have to actually explicitly ask for, you know, static. Let me open this in actual. There we go. We need to actually explicitly ask for a static cast rather than using the functional style thing. And normally. In the implementation we will use static cast, but in the standard they'll use functional style cast and normally it's fine because the. Generally we know that we're actually like like explicitly doing a copy or we control both types. However, in this case both types are user defined, or they're they're user specifiable. And so this is a problem and we have to submit an issue to the library working group WG and so I wrote this issue. And see if I will open it. Remember how? Here's the thing. There we go. Saved it to my desk. There we go. So we have to e-mail the uh. The person who is in charge of LDG issues who is LWG dash chair@gmail.com and also Daniel Krugler. I think Casey please unmute and tell us what the actual correct thing to do is because I just did what other people together correcting is to e-mail an issue submission to LBG chair. Yeah. And whoever monitors that address is whoever monitors that address. It's not really important. But yeah, in practice it's Daniel. I'm looking at this and I don't see how you get a Comcast out of this. Ah, because it's actually very easy, OK? Have this very simple uh? Uh. Function object which just returns the second thing. This is. Trivially correct. It's not very useful to fold over it, but it is trivially correct. Calling fold right as because this returns a char star carestar P equals full right. Use empty carestar which is an empty range. Hello with this second function object will initialize P with constrast carestar hello. Because. If first equals, equals last. It will return you which is the return type of this. Of in it. And in it is a constant care star. That's how you can't cast with. Yeah, sorry, I'm. I'm a moron. I'm speaking faster than I could think. I'm I was thinking that since you as a result of decay, it could never be a constant type. And yeah, that doesn't matter, because it's the target type of the conversion of the source type of the conversion. Right? Right. Ignore Casey. So clearly this is bad. We do not want to allow people to get a cart care star. From a cost care star without explicitly asking for it and fold right is not explicitly asked asking for a cost cast. For very similar reasons. Um, you could have, I don't know, this return a it's star. Have this be an unsigned long long. Yeah, no, that wouldn't work. You, you. There is some way to make this a reinterpret cast. I am asserting. Ohh yeah it would be. You just have to have. And this would do the same thing, except with her reinterpret cast. This is bad. And so we've wrote up this issue. Now, this is the only part of the actual thing you need. If you want to write an issue, you can say, look, we see this, we think that there's an issue here. We don't necessarily have the solution, but we know that there's a problem. However, in this case, there is a very, very obvious solution, and so I. In fact, proposed resolution and the way that you do this, at least the way that my understanding is that you do this. Casey, please correct me if I'm wrong. Is you basically just? Give them a patch, and in this case you would have our dot fold P3, which is algorithm dot. That's the wrong one. Algorithm dot fold paragraph 3. And we replace return used to move in it with return static cast. Use to move in it. And in our gut fold piece 7. Just this one right here we change returns to move first you should move and it with returns to move first static cast you. And that's all that you really need. Um. Casey, please say anything that you would like to say about this process. No, no, you're you're done, right? This is how it works, right? You you basically just need to state what the problem is. And if you like, you submit a resolution, and a resolution takes the form of changes to the wording of the working draft. Yeah, this is a great submission. I have submitted many LWG issues personally. Uh, let's see. Don't know the wait, that's the wrong one. She 21 dot link slash WG 1000 this is the best way I know to get to the actual issues list. I'm sure that there is a better way. I have a lot of these kinds of things. And you'll notice that I don't know the correct solution here. All I know is there is a problem and so I don't actually submit a proposed resolution here, and that's totally fine as well. Um. Alright, that that's kind of all I wanted to talk about today. I just wanted to talk about how someone would look at the wording and be like that looks wrong and how to submit an issue. You just. It's open outlook. Really hope that there's no. Microsoft internal stuff there isn't. Mostly because no one cares about me. And wants to send me interesting. OK, there we go. So you just do LWG chair who is currently Jonathan Wakely. Apparently you do new issue request and you your issue. No, no, that's. What, no $5 sign? OK. And then copying this. I don't think you have to send it as marked down. I do because I'm the kind of nerd who likes markdown, and I think it looks pretty. But you send that off and you're done, and they'll send you back an e-mail eventually with. You know this is an issue or this needs clarification, and you continue talking to them and. They will. They will make it. I'll make sure it works. Alright, cool. That's kind of all I wanted to talk about. Is there anything you wanted to say, Casey, about this kind of stuff? No, you're the person who's been on the team for a lot longer. Anybody could submit an WG issue, right, if you don't have to be an implementer? If you find a defect in the standard, you can submit an issue. If it's in the library section, it should go to LWG chair. If it isn't in the library section, I think WG Chair will route it to the core people and get the right place. So. That's how we deal with bug reports for the standard, yeah, and there are a lot of bugs in the standard because, like every massive document worked on by massive numbers of people. People write bugs. It's it's really easy to do. Especially when you're doing things too right. That's because a large part of the implementer job is to implement the new wording and find the bugs in the new wording thereby, which is, you know, very easy. We we find lots of them. Every time we implement a new feature, there's usually three or four different defects that need to be reported. It's a fun part of our job. He said that sarcastically, but I think that is the fun part of it is to me. It really is to me because I'm a standard nerd, so I don't mind it. But it's kind of funny that, you know, when you're implementing the C++ standard library. It's like we don't design anything. We have the the design already presented for us in the form of the spec, and we're supposed to work to the spec, except that, you know, we're also supposed to be fixing the spec when it's broken. I mean that's the. I think that's the fun part of being a a a language tool implementer is that we do get to like. Be the people who are making sure that the language is the best it can be. Alright, well thanks y'all. This is pretty short, but I hope it was helpful and kind of gave you insight on how we solve these kinds of things because they do come up quite often. Especially in. Weird Edge Casey kind of things. Uh, like. Unrelated to Casey Carter, but Weird Edge Casey kind of things. Uh, where you know? Functional style cast doing a Comcast is absolutely. Bat **** behavior. But that's the language that we were stuck with, and so we will uh, we we gotta make sure that we fix those stuff when we see it. Alright, thanks so much. Bye. OK, now I have to figure out how to turn off. There we go.