Hi everyone and welcome back to another VC libraries Open code review in today's special Intercontinental Edition, we will be reviewing site brands PR to implement P25O5R5 monadic functions for state expected. This is a C + + 23 feature. So here is the PR 3361. I've got the tracking issue open that as usual lists the feature test macro change where the value is increasing. So we'll be looking out for that. The actual paper which is adding a functions and then or else transform and transform error. These are being added to stood expected and they're somewhat similar to the other monadic functions that were added to optional that we previously reviewed, and I've opened up the corresponding section of the working paper here. So let's dive right into the code. OK alt Click to minimize everything. Umm, OK. So we're adding a new test, we've got changes to libx skips, changes to our century to header arrival, core H846 lines of product code change the new test and the feature test macro as usual. I like to eat dessert first, so I will review the small changes first. So I've also core we are listing the new paper. In the C + 23 guarded section. Yeah, that's correct and it is in sorted order that looks good. Let's make sure there are no typos. Yeah, Alex, good. We've got the increased feature test macro. Because expected is a. See was supposed 23 feature to begin with. So essentially, there's no. Uh, there's no variation in the macro. We have a special section below. If we have something like a C + + 20 feature that changes in 23. But in this case the feature will appear fully formed in C23 with these monadic functions. So we just have the new value, which is quite easy. I'm pretty sure this is right. Well, let's make sure there's some typos. Yeah, perfect. Ensure I copy pasted it from your comments. So that's good for the. Yes, yeah. And we could, we could double check the working draft as well. In this case. I'm not too concerned that I got the the value wrong because it's set to the value that was the current month when the changes were voted into the working paper. Every once in a while they do something weird with the feature test macros. It's good to occasionally double check I, Katie. Yeah, this is lexical analysis, cat. But yeah. I always double check for typos because it's so easy to like. Accidentally copy paste like one line off if somebody copy paste from the working paper. Every once in a while patches something fun. So let's look at the feature test macro test. So this is the CPP Lib expected. Again we've got the new value update and all three locations. Perfect. So nice and easy. I've got the new test being added. Umm, as the right value here, I'm just eyeballing it. Yep, and it's being added in sorted order. Minac functions for state expected. OK, correct test directory name that that one gets occasionally type out and it won't be caught by our test harness because test dot list is used only by the internal test harness, which someday we will fix. Hopefully we just need to unify our test harnesses. So here's the new ENV list. So this feature depends on concepts and is otherwise a C + 23 features. So concepts, latest matrix, but it tolerates. The permissive mode, so there's no struct here, so that's good. And then, oh, got a double check. We've got our banner. So that's right. The new test, which I'll come back to, but we do have the banner. OK, I'll quickly scan to see if there's any unnecessary use of stood. No. Excellent. Just in the title. OK, so I think we're already ohh the also the libs X skips. So because we and Lipsius Plus implement features at different paces, we've got. A version macro test there that will fail because we've increased the version test macro here or the feature test macro so the skip comment is list CPP has not implemented P25O5R5 monadic functions for STD expected exactly down a call. This is being added in our known issues area. Yeah, this is near the top. This is a issues known to. I could keep expanding. I guess one more time. Yeah, issues known upstream that they'll realize that they need to update this macro. So in the expected results, we use forward Slash Pass beginning with stood and we need to have fail or skipped at the end. So this is all correct and then in the internal skip test text again this one is if this is messed up we won't find it till we mirror the PR. Internally this is the fun part of working in a open source. Still internal code base. We don't have a stood component, everything is backslashes and no fail. That's exactly identical. So that's good. Aside from those differences. Avoiding divergence between these files makes them maintainable again, something we should resolve someday. OK, let's actually look at the product code. That's up to the top. OK, we've also got updates to the situations here. I'll double check these quickly. Let's see. Can I split? Maybe I wanna monitor. That's like wider than what I have here. Aspect ratio. It's not the most convenient. Of course, we could always, you know, change the STL to be like 80 columns, but the cure would be worse. 120 columns is in general so much nicer to a read. OK, so I always double check this because it's easy to get these citations or I'm 4928 is the right paper number. That's all curing properly, but it looks like the place where these requirements have are specified is actually changed every once in a while. Stable names change or sometimes stuff gets moved around between sections, so there's now something expected under general. Let's see if search will cooperate. Yes. So this is the unexpected. And Scroll down paragraph two. OK, indeed paragraph two. I'm talks about the requirements, so they're all coming from 2. They're all the same here, so that's good. We've also got a stable name citation here. This one doesn't appear with the working paper because we're not citing any specific paragraph. This is indeed the constructor section. We've got some cleanup comments, I guess I can. Change this now that I saw talked about in the the history of the PR. No, I don't wanna go up to the top of the working paper. Where we're changing strength and to be attached directly here against no except saying, hey, we're doing something a bit stronger than what the standard specifies, so fairly minor cleanup. It's OK to mix that in with the features. OK, so now we've got some support machinery. And this is to enforce. The requirements for expected because we're going to need to refer to them elsewhere. Previously, we did that directly within expected itself. So we had export template class expected and then we immediately began static asserting stuff about it. But now we're going to extract this so we can use it elsewhere. So we also have A tag. So this is an internal tag. Oh, and by the way, with export stood that is for the new C + 23 feature modules. I'm not expecting any modules impact for this feature because all of these things are being added or member functions, not top level functions or classes, so expected will still of course be marked as export and these will all be just attached to that. All the internal stuff does not get exported. That's the cool thing about modules. So nothing to worry about there. We've got A tag following our user usual convention. It has an explicit and defaulted constructor to make it hard to accidentally construct. This is called ugly. Under score construct expected from invoke result tag. That's nice and self-explanatory. Then we have a concept. Any use of concepts needs to be guarded by SQLite concepts. I believe the whole feature is. Yeah, the the entire file is guarded by that. OK, excellent. I can also open it up here in case I need context. Yeah, so. Umm. If anybody tries to include this, we emit a nice warning saying the contents of expected to available only with 23 or later, and in particular we need concepts. OK. Thanks Sai. So I lost my place. Here we go. I think I can go ahead and maximize this now. OK, so this is now is invoke constructable. So we're going to ask, can we construct? A transformed invoke result tee. From stuff. Now it's interesting that this is using parenthesis syntax which is. Famously willing to do a C style semantic casts, UM instead of is constructible. I know we talked about this a bit in the the comments that it relates to or potentially relates to. You deferred temporary materialization. Would it be Yeah. possible to express this as an is constructible, or must it be? I think it has to be this way because the so the idea behind This sort of syntax here. this is that you might want to support types in transform or transform error which are non movable. So if you're if you pass for example a Lambda which returns non movable type by value then due to deferred temporary materialization that can be constructed in place directly into the. The expected object and doing. Umm. Doing is constructible on invoke result doesn't take into account the deferred temporary materialization so that it says no. You can't do this even though you can. Interesting. Nicole, you have your hand up. Uh, so it's not a particularly an issue because we're casting from. Team to remove CV raft but that is technically a sea cast of, so if we want to make sure that we're not using a ccast, we could use static cast instead. Uh, it's good point. But also like. It it's not a sea castle. Ever be anything other than a static cast? I I would definitely prefer a static cast if it has the same So. semantics I'm looking for. Is constructible to remind myself how it works. Where do we put it? It's not a a other. It's not a unary type tray. This convertible or is it type property queries? Nope. Type properties. There we go. OK, so the definition of is constructible. Specified to see below. I used to know how this works before she has 17 changed everything. It is constructible. Here we go. The predicate condition shall be satisfied if and only if the following variable definition will be well formed. They are never interpreted as a function declaration. Make a tea. Named variable out of Declval args. This. Does handle deferred temporary materialization? The Declval adds ref ref doesn't it? It. All the declval. Because we are, I see. So it acts as if you it acts as if you like returned. And our value reference, so the different. The args are of. Yeah. Ah, OK. And if the if the Lambda itself, I guess the. They're the result of invoking. So you're saying if this thing Yeah. So if the result of invoking. is not movable. Is non movable, then it gets still can be constructed in place and the UM the paper. The paper was written with that in If it's the exact same type. mind, such that it's specified that we have to support that so. OK. A question before I actually get to that. Do we have test coverage for this? Yes. Excellent. OK. So then this is a reasonable, but I do like the idea of using a static cast here, which should be exactly equivalent in semantics, because we never want to Conn's cast or a reinterpret cast, which are the other things that the C, the functional functional style C semantics syntax is going to do. So out here, Cole. Suggests. Using static cast here as. Ah type args. Is a. Technically, a functional style C semantics cast, which we prefer to avoid, we we absolutely avoid all the season tax cases except for void. We try to avoid the functional style casts as much as possible, although there are some cases where it's necessary. Umm with like user client types and there's some ranges scenario which I always forget which really can't use like braces. Although in theory and some of those cases probably could use static cast, we just haven't done that everywhere. OK, so I Nicole suggest using static cast here as type bars as technically a functional style C semantics cast which we prefer to avoid. OK, so let's actually look at the machinery template, class owner, fun class owner ties concept is invoke constructable. We're requires fun. Refer funk. Vowels. So can we make? The invoke result T. Of invoking fun on ties. This is all correct, because when we're taking ref ref. If we just pass the type itself, that preserves the value category properly and is not redundant like saying fun refresh would be identical but. Unnecessary. So we don't do that. Then we want to remove the CV ref from that. That cosmetic. It essentially is cause you should in theory be able to construct a const whatever, even a constant out other stuff. But this is certainly a very cheap and it's simpler to think about. OK, I like that then stood in. It certainly needs to be a removed reference T. Not yes. Yeah, yeah. Because, yeah, trying to construct a reference out of it would not do what we want. Construct from student votes did forward fun Funk stood 4 ties, valves OK avoiding ADL. That's great. That's great. Uh, here are the extracted requirements. Now template class tie. This is following the same check unexpected argument machinery. Which? Uh, if I can open this up, here we go. Check. I need not case. Yeah. This thing we had a. And still have a helper struct that always drives from true type that goes and enforces a bunch of static asserts. We don't actually have a lot of precedent of this in the code base, so it's nice that it occurs right near to the next one. We need to add because usually we just need to enforce like one or two static assertions, but for unexpected we had like 5 different things we needed to check, so wrapping them up in a helper struct was convenient and so we're doing the similar thing here. Check expected argument. Also dry some true type. Umm. Oh, this is not being specialized. This is simply the primary template itself. Why do we need to specialize? Uh, no, that unexpected argument behaves the same way. I was getting confused by the four declaration of unexpected here. OK, so it's always primary template, which is the standard's term 4 template that has not yet been specialized. Template costs high start check expected argument, derive some true type, stacked a bunch of stuff. These are all they should be exactly be the same as before, not a reference, not a function. The citations are being updated. This is the same paragraph. OK, here we're not changing the stable name or anything. Yeah, it's just updating the working paper. I guess I can check to make sure that the paragraph number has not changed. I am very picky. Umm, because if we, if we ever let the paragraph numbers get out of sync, we'll never be able to find her. It'll be hard to find what we were trying to cite. Type 2 or paragraph two or type is a valid value type. If cool things are satisfied. And then the CP-17 destructible things are different. Yeah, paragraph 2's good. OK. So they're all sitting paragraph 2. So it's not a reference, not a function, and then the diff is not really convenient here. There's this array coming from. Is that new? Now looks new here. I don't believe I added that. Intentionally at least so. There's. Is the is the diff or was this copy pasted from unexpected possibly? Unexpected forbids array. It looks like there might be copy paste or I don't know if it's wrong yet I got to look at the standard. But OK, so now now since I've seen something unusual, I'm getting paranoid. I I need to double check everything. Yeah, yeah, for sure. So we got the not a reference. We got not a function and the the wording I guess is is also the same, not a reference, not a function. So then it's the not an array that's appearing out of thin air. Umm, we'll come back to that then here the diff is making things nice in place T and expect tea and can't be unexpected itself. So those are all. Those are all fine. But what's going on with the array? So let's look at the standard. Umm, a type T is a valid value type for expected if remove CBT is void. Or a complete non array object type that is not in place T and expect or specialization of unexpected. Interesting. So we're enforcing teens to be a complete nonary object type where we just missing this before that's interesting. Yes, we were. OK, so this is uh, this is correcting a deficiency. Yeah, I I noticed that's when I was comparing the conditions and Because the. Yeah. added the not array case. Yeah, we still check error. OK, interesting. Next, Casey. So let's actually, for my own education, make sure that this is actually now exhaustive. So. We allow it to be void. Which is not a reference of function array, so it won't trigger any of that. Umm, we can't check completeness, of course says we non array. That's the array part object types. Here I've immersed the standard definition. Object types are non void, non reference non function. So we can't be referenced. We can't be function. But we do permit void so that's good. And then we specifically forbid in place T and expect T or specialization of unexpected. OK, so this is. Uh, complete and correcting a deficiency. Thank you. It's good. I wonder if that was added at some point. I could have sworn that when we originally reviewed expected, we made sure it was exhaustive, so either we missed something or they passed it later and we missed it, which is unusual. We could do archaeology to find out exactly what happened, but I'm not too interested at this point. I'm just happy to get the fix. OK, so we got the struct there. We're retaining the export, stood on class, expected the Div is just confused here. And then we static assert that ties satisfies the expected argument and then error satisfies unexpected, so that's good. We've got a stable name change, which is fairly unusual. That's not helping. Umm I've got 2 copies that work in draft open. There we go. Expect object cons for constructor. Yeah, there it is. They're stable asterisk. Uh, clean up to attach, strengthen there, clean up plus clang format. OK, not too concerning. Some paragraph changes since I haven't seen any issues with paragraphs, I'm less concerned about these now. 16 is value or? Yep. Value or. 18 is the referee version of value or? Yep. That's the mandates. OK. Ah, some questions from Nicole talking to Sai about. The specification value or. This is very warm, no error or. Yes. So the context here is the. Possible API symmetry? Umm, the template argument to error or is defaulted to error so that you can call it with an empty brace list, whereas the. Uh and template argument to value or is not defaulted, so you cannot pass anti braces to value or cynical comment was. Do we need to make an issue and? My answer was maybe, maybe not. I don't know. I I looked at the. Alright. I looked at the original minutes from the. AWG calls and. And it seemed like. It was to support this kind of refactoring. Where you have like an an error code and you're doing like calling a a function to to test for an error and and you wanna Umm. make this this kind of refactor to to get back a default error afterwards. So that was their reason for having the default on the the error or my. Kind of guessed from from reading the notes was that they find a A. A good use case for this for error or and. Umm. I didn't find necessarily strong one for for adding this to value or but I don't know if it's worth filing an issue on 1st for symmetry sake. Umm, it seems like it might be worth sending a mail to library evolution because this is really a design question. It looks like Yeah. it's not just an outright the misspecified the API or they just forgot something during an edit, or maybe not a full library evolution issue, but just a mail to the reflector asking hey was did anybody think about this? Umm, because it's always possible that they patched error or and then nobody noticed that value org didn't get patched. Or Well, it error is error is new in this paper. maybe it was intentional. Ohh OK, that's the 10. But value or was the existing one. Value or was already existing and they added error or as part Ah. of this paper, yeah. OK, so that makes it more likely that this paper has a cool innovation that then could have been possibly, but was not retroactively applied. Could be, yeah. OK, so that it does seem like it does seem that it merits the library of evolution. Issue slash mail. Say, can you take care of this or should we file an issue right now in the repo as a reminder? And I can, if you just write a note there, I'll. I'll send an OK. e-mail to the reflector and. I'll follow up and. And on that common thread. I still need to figure out how to get my Microsoft e-mail working with the reflector. Let's say paths. Let's say OK, we should send an e-mail to the library evolution reflector and ask whether value or should be changed. OK, great. Umm so dropping the this or probably moving? Thanks diff UM ohh. There's like all the new code. Is it ever going to? OK, expected object EQ. That actually change. OK, no change here. It's just the diff gets confused. Template class under score Utah equals error. So here I actually do want to have. Actually, sorry for jumping back and forth. Class template expected there's error or and then everything else is an expected object of an attic. But there are some patching here. Oh. Oh, here's where the array thing comes from. Typo. Expected Object General did not used to forbid arrays. It said reference function or possibly C equal in place T wow, that's getting messed up unexpect or so forth. And now they've added a complete non array object type. So that's where the delta came from. Excellent. Umm. Means we didn't just forget something. OK, so then we add the observers the error or and then the whole monadic subclause. Anything else? I'm just looking for all the diffs the paper could have had also void OK. Expected void been attic and then the error or. And then that's it, OK. So now I can look at the working draft. Excuse me, am I looking at the right area? OK, expect object obs. Error or OK. She wanted some side by side. OK, so you tie error. OK so here is the first of many member functions. Split the this. OK. And it kind of works. Here we go. So template class Utah equals error. That matches where's my highlight. Here are template class G which we're calling utai is error. OK, that's good. That's our usual name for stuff. This is what I'm server. All of these are. They're all observers. I'm trying to. See which ones need to discard where is that there wording. Error or yeah, you only ever call this if you want the value. He's like, what's the error? And if we don't have one, then get a fall back. OK, but for these, these are all taking function Yeah. So you could reasonably do them as side effects. objects. They're doing stuff. Yeah. OK. So we don't expect any notice cards for the and then or else transform transform error. But all of the errors for the primary template and the void specialization should be nodiscard OK. Umm we we tried to be quite careful about following our criteria for notice card to avoid false positives, making it the extremely useful warning. In fact, we just had our compiler give Cameron Venkus for the nodiscard that we applied to remove if or and remove because he tried to call that without sending the result to erase member function and got a warning saying hey, this is not how you use remove and remove if. And otherwise that would assembly compiled into the wrong thing and the compiler. So error or is notice card great returns a context per error. Takes a Utah Ruff Ruff other. That's what we're calling E this is Const. Ref. We are strengthening the noexcept, so there's a strengthened and aside from Clang format. Being weird here and we sort of just tolerate this as not worth turning off clang format. We need two things to be true is no throw copy constructable V the error cause we could. Return that. And because both of these need to be true because we don't know until runtime which one we're gonna do is no throw convertible V utai. Which is. The other two error. Which is the return type and that is an implicit conversion, so that's right and the order is correct. Famously constructable convertible specify things in the opposite order. Very easy to get confused. But we're converting from Utah to error so that all looks good. Uh, you've got the construct 1 here. Then we've got static certs to emit nice messages to enforce some mandate, and these are actually the nono throw mirrors of the strengthening. There is copy constructible V error and we cite is copy constructible. VE must be true we when we send messages to the user. We tried to talk about names that they would understand rather than our internal names. That's great. And we cite in 4928 expect object OBS 20. Yes. And then is convertible V from Utah, which is G to error is convertible VG to E must be true. OK, that's all good. And then returns. If has value, so we test our internal bool rather than calling the member function as a micro optimization is just simpler. Return stood for GE stood forward Utah other correct. Otherwise the internal error. And again, we have the data members, so we don't need to call error prone. OK, this is all perfect. OK, so now that we've seen this, I can move a bit faster because now I just need to sort of mentally look at the differences. This one doing is move convertible. But it still wants his convertible GE. If we have a if we need to use the fall back. And then we need to move the error, the reference portion OK. So template class you tie error. Notice carcass expert error, error or the recursion is no through move constructible error and is no throw convertible from you tie to error still strengthened. We need the move constructible move constructible good, no typos. The citation paragraphs need to update 2, so it's 22 and 23 for the returns, but 22 for both requirements. OK, that's good. If his value, 40 other otherwise stood, move the unexpected perfect. OK, that's error. Expected object lunatic. That is the new section. OK, so we've got some requirements here. This is occurring in standard order, which is great. Here's the constraint, so template class fun. Requires is copy constructible V the error, so that's a constraint. Uh, we are correctly not seeing any nodiscard let me just do a quick search to get that out of the way. It's going to turn up all the ones in the context too. Error or error or these are the void ones presumably? Or did we wrap around ohh we wrapped around? Yeah. Umm. Uh, do they ohh do the error orders for void not return anything. Umm, no, the error isn't for void are marked as no discard. Oh dear, I did my search. Miss him then? Uh kiss. Our, our. That's the primary. This. Yeah, this is void. Ohh. They're nice card. OK, so my search missed them. OK, great. So they're both nice card. Thank you. OK, so now I can stop worrying about nodiscard. Let's go up. OK, an attic and then. OK, so template class fun. Got the constraint constexpr auto and then take fun refresh funk L ref. So here I I guess I can comment on the naming. This is funk. Which is reasonable. This is being passed to the invoke Protocol, so technically this is a callable object. Umm, but since we're consistently using invoke here, I'm not too worried about saying you know, renaming like after callable or anything. When we implemented invoke itself, I Yeah. tried to be unusually careful about the naming, saying call by object when we specifically meant to generalize notion of something that could be a pointer to member, because that's what revoke handle specially and using function object in the standardese term only when it meant things that are callable with exactly parentheses. But the rest of the code is less strict about that, and rightly so. We don't need d2374c2c-2ced-46bf-b0cc-ee2218620be9/4727-10 to. Constantly use the exact standard terminology everywhere I also copied the. I copied the naming scheme from optional for. and it aligns with. Umm. Chris symmetry. Yeah, and yeah, that that makes reading this easier. OK, that's good. This is not strengthened because we don't. There would be little value in saying there is no throw invocable and all that. Umm so this says using Utai is and this mirrors paragraph one. Remove C graft. The invoke result T of F on what is the deck of type of value? It's an odd way that they phrased this. We say tie Rev. Is that the? Ah, there's, uh, there. The standard specifies it as decltype value because it's stacking together the definitions of the modifiable reference and const reference versions of the member function. So at this point in the specification, it doesn't know which one. It's in constant non const, but we know that value is going to return T Rex for Const ref, so we can just say tie ref and avoid that whole decltype, which is simpler and better for throughput, so that's good. So we've got that. And basically every time there's a difference between the implementation of the standards. I tried to understand. Are we doing something clever here? Are we doing something bad? Sometimes clever and bad? Static Serge. OK, so this is the mandate. Utah has to be a specialization of expected. I'm nitpick here. We like spaces after our commas that occurs below. I. Let's pack. Should have a space after the comma. Cursed below, so I won't comment on that anymore. Expected TE. And that is the the parameters to expected double colon and then F. Here we can just sort of talk about. F without caring too much that it's a rough raff. This message, say FFRF. The user doesn't really care about that. If they really care, they could look at the the standard here. They just give us a thing. Yeah, it's an L value or an R value, but we just want the type of the thing. We don't need to talk about. Oh, you know, is it sensitive to value category? If the user knows about that stuff, they're going to read the standard anyway. So this is a little bit. Imprecise, but it's imprecise in a good way. It avoids overloading the user with information it requires the return type of F to be a specialization of expected. Uh sighting and 4920 expected object fanatic 3 yes, that's correct. I want to make sure there's a space in the proper place. Yes. OK, that's good. Umm, there's a a gotcha where if we wrap a multiline string and we don't have a space here, then the message won't have a space and it's very easy to miss visually. Always look out for that because I I love finding that even though it's like completely in the PIC stack assert is saying VC. Type name. You tied up bacon air type must be error. OK, the standard doesn't think it needs to say type name, but we're actually implementing code, so we need to say type name expect at E and then F requires the error type. Of the return type of app. OK, be the return type has to be a specialization of expected, so requires the error type of the return type of F to be, and that matches up with E here. OK, good. Also Monadic 3 OK, that's right. So you've got the mandates. Done. OK, affects equivalent 2, which is the favorite wording for an implementer because it just says hey, do this thing. Don't worry about too much what it does. Of course we do need to transform into something that's actually implementable if has value test the data member returns to invoke avoid ADL stood forward FF so from funk. And then our value. And where the L value forms so we don't need to move or anything otherwise return. You tie with a Paran so here if we could do. Don't know if we could do braces, but we definitely want static or we would like static cast of unexpected comma unexpected, so that's error. OK. Could we use braces here? And I'll think so because we so the the Convention is that when possible in our new code, although the old code is quite inconsistent, we tried to use braces to construct temporaries cuz it doesn't look like a function call. It makes code more readable. Umm, but there are sometimes semantic differences between parentheses and braces. Famously for like vector. And branches stuff, so we can't unconditionally do that sort of thing. We can if we know the type here. Utah is the return value. We have no idea what this thing is. It might care about braces. But wait, it's an expected you time. Must be an expected. So it is us. We can use braces here we we know what we are. That would be nicer than static cast. And that this this occurs repeatedly. I would like braces here. Let's do that. Or and then overloads. Yeah, makes sense. Yeah, yeah, basically anywhere that really anywhere we say this thing, I don't know if that occurs other than and then. Well, and then is the only one where we know that the return Ah. type is going to be a specialization of expected. Ah, OK. And you're right, it does indeed occur only for and then OK. Umm. Do we not know it for or else? Since. Umm. And maybe we do. Yes, yeah, yeah, we do. Umm. And that also does use. Parentheses, parentheses as well, so. Umm. Yeah, for overloads of and then and or else. OK, I can go look at orelse. We're coming back. Here's an orelse ohh I see it's a in place value. Yeah. OK, I'll update this comment. Umm. OK, we're freed since we know that you tie is a specialization of expected, we can use braces to construct utie which would follow our prevention occurs below also in or else where Utah is constructed from in place. That. OK, so now the construct version. Let's see. There was a comment and this is the the history. It's not. It doesn't appear attached here because I think the code changed about whether some of this stuff could be extracted. Unfortunately there is a C + 23 feature called deducing this, but a it has a problem with the core language itself. There's a certain corner case that doesn't exactly handle that. You could use a ccast, I believe to work around, but that's horrible. And in any event, the question is moot because right now. Although MSVC MSVC has implemented the deducing this feature, it is not yet supported in modules and the STL now supports modules. So at this time we're not using it at all. There was a question of, I think it was from CPP learner. Correct me if I'm wrong. Where could these be extracted out to? A helper function or helper member function and in this case I think that's not really feasible because too much varies here. We need to return like value or move value depending on. Here's the move value depending on where our value reference or not. And yeah that could be like a straightforward like or something, but that's adding a lot of complexity because then it wouldn't be a direct translation of the standardese. We need to think about. OK, what happens if we extract this out to a helper? It's a little bit, I mean it's a little bit repetitive to have all these implementations here, but I think that if we try to extract it out, it would be harder to follow. Umm so I'm I'm OK with this. In an ideal world, we could just wave a magic wand and and specify it once be done with it, but at this point I think that repeating it is the simplest approach. I'd rather have basically more code that more directly aligns with the standard, and I have to think less whenever I see something that needs a big transformation. I got to think hard about. Yeah. We introduced any divergence that the user could observe cause almost everything is observable. If you look closely enough. OK, so we're looking at the constant reversion here. Umm, still requires copy constructible V error constexpr auto and then for the refund Const ref. Using Utah still the same. Yeah, go ahead. So I think I think, Nicole, you had a comment at one point that actually the. That requires clause needs to be is copy constructable via of const error. Is that right? So copy constructor will be. This is for the and then construct Rep. Function. It does not affect. And then for construct. I mean technically it could affect it for wrath, but I think that. I feel less. I I don't feel as strongly about like. About that difference, but the issue is below in and then for construct rough. Uh, it required the end event for contract requires is move Oh, this one. constructed will be which is not a thing that will actually like. That's not a constraint that makes sense for construct raft. Like it's just. You you'd want contract for up to be part of. Yeah. The const graph. World. That that's a bug in the standard. I have. Have you filed an LWG issue about that? Yeah. I have not yet if you Scroll down a little bit on the review. Yeah, here we go. Yep. Yep, councillor foff. Yep, highly bogus. Umm. OK so so I asked what's the protocol here? Do we fix the code to be correct to file a Dr filed resolution fixing? I would say having thought about it for all 10 seconds, this is a case where the code is or. The standard is clearly bogus, and the right thing to do is obvious. So in this case I think we should just fix the code and simultaneously file a defect report issue saying. Here's how we fixed it cuz as written, it's not the biggest thing in the world. Nobody would really notice. It requires a specific type to really care about this like I guess a move only yeah. Would be a move only error type where you call the constant R value overload, which is already pretty hard to call. So in theory we could just implement what standard does and nobody would know, so eventually would go fix it, but it would be strictly less work for us to go fix it now and simultaneous report it and then when they voted into the standard like hey, we already confirmed. So I think we should just change the code and file the issue. So I'll I'll record that here. Yeah, but so. Be argument that I would have is whether. We want to use is copy constructible, which I think is totally reasonable like. Any construct will construct will bind to a construct draft. Like you probably wanted to do a copy. Umm. Or the other option, I think if we're going to say. That the contract rap. It's gonna get constructed via the constructor of constructor if it's distinct from the construct constructor. And I think probably we should also distinguish the rest. From the contract, so like using something like is constructor is convertible V Const tie ref to Thai is convertible the tie ref to tie is convertible B tirecraft to tie is convertible be cause tirecraft to pie like that makes sense. Yes, that will also be horrible to transcribe for the recording. All those type traits. I I think I will ask. I'm so sorry whoever said the described it. You'll be transcribing this one. Congratulations. I think since we have our concepts expert Casey on the call, my understanding is that in the concepts world, we try to avoid being super duper fine grained about exactly which operations were going to perform, because only types that are extremely unusable care about that. My understanding of the concepts design that we have in 20 and 23 is that we try to have fewer and higher level concepts and try to avoid accommodating types that are very, very strange and a type that cares about and might be constructed from a modifiable lvalue or a constant L value is extremely strange at that point, you're sort of descending into auto Porter territory. Umm. So according to my understanding and correct me if I'm wrong. It is reasonable for both the L value and constant L value forms of this to just say we require is copy constructible, which is specified to ask what happens if I construct this from a constant L value. So essentially adding Const when we ask about the constraint and if the type happens to behave weirdly, well, that's bad, that the type shouldn't do that, which would then argue for the const our value overload to the member function to just ask is copy constructible. Even though it would be specified to. Well, I guess then the question is then do we split the specification to say? Do we just copy from value in that case or do we just always say stood move value? Which is technically constructing from a const star value and yet have the constraint say is copy constructible. Umm, what do you think, Casey? More anybody in general? I hate to split the specification. But it does really seem like the right thing to do here. I I agree with you. So split the specification and just make it plain plain copy from value or just not move from it. Yeah. And and use copy constructable for the const or value case, yeah. OK. So and then becomes the equivalent to like I just got I see so. moved up under contract. Basically. Yeah, I think so. Like if you look at the effect. Could could we just remove the contract Rev in that case because it'll just call the contract? It's a it's equivalent to the contract. Function I like I I don't personally think that the cons RAF RAF. Actually. Benefits us very much here. I I think it's. I think it's like just having an extra function for no good reason. Unlike optional where you want it to be like crazy and do But. interesting things. It does feel over generic to me, but it's basically a design That. question. Yeah. Yeah, that is, that is entering design territory. I I guess we should ask Ellie WG if if they wanna support. Different behavior for Const reference for construct. Even though we definitely wouldn't do that in the concepts No. to sign, there are Gray areas. In in optional that have been perpetrated to expected. Where they try to go above and beyond support weird corner cases that they probably should. Yeah. The interesting thing, there are some cases where you absolutely do want to respect contract ref like tuple get is a famous one where I think I found the LWG issue to say we should actually support all four combinations of lvalue, rvalue, modifiable const, because that way if you try to. I do like a stood get on Const R value tuple and then pass it to something that wants to reject temporaries that we properly handle those. It's unclear to me whether that applies to this end then or if we would just need a move overload of Const ref versus ref ref. It's unclear what this L value form does cuz correct me if I'm wrong, it's value that cares about it's not really error. The value is fully overloaded on L value versus R value and modifiable versus Const, and the function could absolutely care about that because if I want to modify if I'm like a function that takes int ref and then goes modifies the thing I really care if the value is modifiable. Umm. This do we move the value? We do. Yeah. OK, so that argues more strongly that. So. Oh, go ahead. Ohh yeah so so that that goes back to your point of like wanting to reject. Temporary is like if somebody has a function that takes an. That takes in. Don't know sometime and then return the reference to that type in, like a new type. You really want that to not be a temporary. And so you could reject our values by doing that. If that makes sense. So basically something like this. Where you want to take a thing. You know, maybe do stuff and then return a reference to the thing, but if you're giving any Cerner temporary, you just need to reject that on site, which is sort of similar scenario. We Yeah. haven't, like, refrigerator and whatever, where you have a valid reason for observing sometimes, but because we maintain a persistent reference elsewhere, we need to reject temporary. So this really cares about constar value references. So that's a good motivation to have all four. OK, so I think. I think that that's an argument for. I guess we're kind of resolving the issue or think about the issue itself here to have all four overloads. But in that case, then that does argue to correctly constrain all of them. Umm. Although the sorry, the constraint only cares about E, the argument for what we do with E is less important than what we send to the function. Cause like if you have an arbitrary function, the scenario of ohh you know doesn't want to reject our values, that's interesting. If it's purely the question of can we copy or move EE should really not care if it's being constructed from. Modifiable value versus constel value. More constar value. So I think. Having the two specifications here that says deck type value and decltype stood move value, that's definitely still necessary. I think the only question is for the error case, how do we constrain and what do we return? I I could see Argo. OK, so I guess this is less simple and less obvious than originally thought. Umm, which now moves me towards. Let's file an issue and come back to this later in the implementation because it will really only make a difference if somebody calls the constar value version of this and if the E type cares about it and that's so obscure like in practice like we wouldn't even have found this Umm yeah. in that implementation in the test of the implementation itself. It's only when we exhaustively reviewed it, OK. Yeah. Frankly, I don't even think this needs to be a constraint at all Umm. like. It is very weird to sphene based on whether the expected like phone away and then based on whether unexpected. Is copy constructible like what the what are you doing that you Yeah, because like you. need that sphinx constraint? What? Because you can't Sweeney away based on the call ability of the the function you pass in anyway so. It's like you. You can't, like parsh, partially spinach the way Yeah, like why, what are you doing? That's a good point. you're you're overloads that. So that would, that would argue just for cause like I think the standard is actually gotten maybe a little bit overboard on service thing, things in the constraints that really should only be when we really want the function to participate in like overload resolution nicely. Otherwise it should either be a mandate or should just be in the standard. It should be a mandate in the implementation. It should be we're going to do a thing and then if it fails to compile well you get the compile error and have fun. Yeah. And this really feels like that, because I mean if the. Or like static cast or static a certain, not static cast. Yeah. Yeah. Well, yeah. Implemented through a mandate. Yeah. It's so that that's an argument for dropping the constraint entirely. That would be my preferred resolution. Yeah, that, that. Yeah. OK. We talked about this in the video code review and while this is definitely an issue, it is surprisingly subtle. So we should file an issue, file an LWG issue, and wait for it to be resolved. It could be reasonable to drop the constraints on these overloads entirely. What overload resolution scenario would they be improving? Sounds good to me. OK, finding bugs in the standard. OK. So we are in the constructor of overload, which is the one causing us all this trouble. Constexpr auto and then for the refund consider frac. He's in Utah, his move C Rev invoke result T. How we've got we've got a little the different here, OK, because that's the the decal type of stood move. Of value. OK, let me make sure that this is all correct. I think I I think I glossed over this the first time I saw this. So the L value form needs to say Tyra F. Constant values is const. Tyra off. Our value says tie. Tom Star values is constant, all correct. OK. And then stack of Serge is specialization, return Type F must be specialization of expected for the R value ones. Seven. Is the mandate correct? And then type name Utah error type must be error. Yes, airtime must be easy. If his value stood, invoke stood Ford Fund funks did move value that's right. Otherwise you tie unexpected move unexpected. OK. That's and then now or else. Ah OK. Template on class fun requires is copy constructible V of tie. So that's this constraint. Constexpr auto or else photographer funk? I guess we're going to see we're going to see the same sort of issue here. Or actually know only for the error. There's asking about tea, not east. We move value. Oh, but the same issue that the constant the constant refresh one. OK, so this occurs in all of them. Yeah, I'm on the on, not in transfer transform and transform Because it's asking me for structure, OK. error don't have constraints on them but and then and or else OK. do. We should fix this or else. So using a phone or funk I'll wrap. OK is in Utah remove CV raft, invoke result T fun on. Decker type of error. Which is Arraf. I'll quickly scan Const araf. Error as an R value const error. OK great. Uh, OK, stack assert Utah must be expected. Where's your tie? Oh, you tie the return value. Yep. I'm double checking. The name is correctly changed. Or else here. Return type F must be specialization of expected 11. Is the mandate cracked also for? That Const L value. This one also says or else here I'm just quickly scanning. I'm still are else 15 for the R value. Yep. Tyler's 15 OK, so all the messages are good. Let's go back up. Go. OK, let me to value type, OK. If it's value then return Utah of the in place tag and value. This is the lvalue form otherwise stood invoke stood forward from funk unexpected. OK great. Then there's the construct one. We've already checked that we've checked the messages in place value student Vokes deferred from funk. Unexpected. OK, great. Our value. We checked the type being fed to invoke result there and the messages. I guess I did not actually check the spaces, but the spaces all look good for the line wrapping OK. Umm, so this one. Now it needs moves. Here we go. So move the value, move the error stood move value stood move unexpected. You still got stood qualification everywhere. Good. And then the construct ref. STD move values did move unexpected. OK, that's all the OR else is. Uh, getting faster at this. Now transform template class fun. Requires this copy constructible V the error. That's this one. Constexpr auto transform. And refer funk. Actually transform also has the. I was wrong. Yeah, they do have the. Yeah. Yeah, yeah. Yeah. Yeah, this has the same problem, yeah. And the transform error. OK, so it's actually all of them. I'll go back up. Morales transformer. Transformer. OK, let's go back down. Transform. OK. It's got structure. The error constexpr auto transform fund refer funk L ref. Uh. We begin with the static assert static assert. The invocable concept? Uh, because that's the mandate. Yeah, so, so basically the the issue with this mandate is that. Well, that's interesting. So it mandates that that declaration is valid in order to work out the type you you need to do invoke result T of fun and tie. So I have to I do a kind of multi stage approach where because in order to work out the the you you need to do the Yeah. invoke results. So first I check that it's invokable and it's just static cert if not and then because I know that invoking is safe. And I do it and then I check the rest of the. That the mandates clause. Yeah, that's very interesting, because if you didn't do this, then attempting to form the invoke result that would seen away and so we'd get an error like, hey, you're trying to make a UTI type def, but it didn't have such a nested double colon type. That would be technically conformant, but pretty horrible message. So I really like this. This will result in better user experience if the function is not invokable with the value for whatever reason, and that could easily happen. If anything, it's more likely than like, oh, The Yeah. thing is in copy constructible, it's just like you're trying to Right. Yeah, absolutely. call some Lambda and you've got the type wrong or too many types or something, or too few. OK, so let's double check this multi stage deal. So we're static asserting that fun is invocable Thai ref because that matches what we're going with the invoke result. We got to say expected TE form F. Uh requires that F is invocable with T. Again, glossing over the value category, which is reasonable. Umm, looks like we do have a space there. Yep. Umm site expected object monadic paragraph 19. Yep, that's the mandate. OK, so now we know that's an invocable, and now we can actually form Utah. Using Utah is remove CVT. We're not removing CV ref here. Umm invoke result T of fun on Tyreke? That's the deck of type of value. So now we have U. And then. Uh mandates you is a valid value type for expected, which is happening down here outside the if constexpr. OK, check expected argument. You type value and This is why this is factored out. This is not being asserted with a message, but that's because check expected argument emits nice messages messages is. I can't pluralize for all of the different failure scenarios. It Yeah. would be confusing and redundant to also cite. Hey, you know, it's really this mandates here it should be fairly clear like we're complaining about an expected the template instantiation context will show that there's a transform. It should be pretty self-explanatory. It's also always true. Yeah. Ohh, you're right. Yeah. This one is always true. Yeah. Value is always true for this case. So we can't pass the message even if we wanted to. Umm OK. Yeah, you would have to like completely duplicate all of the Hence the this is cute. I like it. static asserts inside the. It would be a a mess for not a lot of of benefit really. Yeah. OK, so that's nice. So now we've checked this, then if is void V of U as false. So if we're not void V then we're gonna static assert some stuff this thing. Using the special is invoke constructible. Uh fun tie ref. Expected TEF requires that the return type of F. Is constructible with the result of invoking app. OK. And then site and 4928 expect object 19 and this is. This is wrapped a little bit weirdly, and these could be stacked onto a single line, uh. I guess it's more consistent. I think Clang format did that. Oh, interesting. I think you could probably manually set it the other way. But uh. Yeah, if you if you had originally written this on one line and then this on the next cling form, it would wrap this I wrote it on one line and then did a yeah. one. Ah, OK. Is that consistent with what we do elsewhere? This always appears it's a little bit weird. I won't. I won't comment on it is consuming a bunch of lines. It's not. It's not too weird. It doesn't make it longer. OK, I'm I can't resist. I'm going to comment. These can be. Yeah. Can six join those last two lines? Yeah. On uh, these can be combined. Yeah, if this code wasn't already pretty long, I'd be like, yeah, OK. We can spend a line here, but it occurs like four or more times and it's so cheap to fix. Yeah, yeah, yeah, yeah. Ah, OK. I'll say I lost my place and I removed this. We're just transform transform. OK, so we're citing this 19 is the mandates. OK, so we've got all this here. Now, we've checked the expected argument now we implement. OK. So affects, we've got three conditions. If has value, but the standard specifies the false case. So we do that first, and this is good. Thank you for phrasing all of these conditions positively. We have a convention where we try to avoid unnecessary negation in conditions. It's sometimes it makes stuff clearer. Yeah, it just makes the codes a lot easier to read, I think. Yeah. Otherwise gets tangled up. You're like, wait, is this the negative case and what's going on here? So if it's value, do Yeah. positive stuff. Otherwise we don't value. Than return make an expected and reforming utai error. Here we should use braces of unexpect and then the error which is unexpected. OK, let's see. This is a different enough in the text that I'll. I'll make a separate comment for this. Umm. We can use braces when constructing. Uh curves below. Yeah. Then actually. Oh, it occurs everywhere here. Ding, Ding, Ding, all these all these cases. Let me. Yeah. So and every case in where we are explicitly constructing Yeah. an expected then should just braces. Mostly. These temporary they're all expected Utah error. Can you use braces and instructing these? Her her peated land law. OK, we can use braces when constructing these expected. You tie air objects occurs repeatedly below. OK. Yeah. Umm. The the ones where there's like arguments is a little bit lower priority and we certainly have a lot of. I'm. Older usages, but when new code is nice. OK, so if has value false then expected UE unexpected error. OK got that. Otherwise. Umm if is void, V is false. Wow, the standard flips all of these. Umm. That's this case. Returns an expected UE object. Who's? Hazel Member is true. So construct is expected from invoke result tag. And then the Val member is direct non list initialize so it's saying do not use braces with invoke stirred Ford F value OK. Otherwise, this one evaluates invoke stood Ford F. And value and then returns expected UE. Print, print, brace, brace. OK, so all looks good here. You ties void. So there's no need to ignore anything. And this was already implemented? Or is this implemented below? That constructor is implemented. And. Below. OK, so here's naive benzene. The the tag is is above and the the constructor is below. Right. OK whoops, that's my place. OK transform L ref. Great. OK. So the new constructor. OK, so now the construct version. Let me check the paragraphs real quick. So. El Raff mandates is 19 for Const Graff or Rifraff, it's 23, it's 1923. Yeah, OK, maximize this because the wrapping is horrible. OK, so. This is the era off version sighting 1919. Constructif, which is the next one, 1919. And then Ruff Ruff 23232323. OK good. So consider if. Template copy constructible here. I'm not looking at the standard, I'm just looking for the differences that I'm expecting, so we should see consti ref for each of these. But the messages don't need to change. OK, we still got the remove CVT. So where does the construct appear invokable when we make the invoke result and then when we ask our, you invoke constructable? No changes down here because we just say value, but then the move one will be a little bit different. Here we say for the reference one tie, tie, tie. And then we stood move value stood move. Value stood, move unexpected. And then for Contra frac, we say constant constant constant I. Stood move values should move values to move unexpected OK that looks good. I don't see any copy paste errors here. Quickly scanning for anything else. Don't see any issues. Cap that looks good and then. The Ruff Ruff won. Yeah, that looks good. Then account Straff 10 it requires a different. We already talked about this where it's copy, copy, move, move, but that should probably change. Yep, copy. Copy, move, move. OK. And the construct raffone. The Invocable not invoke constructible. OK. Talks good. Now transform error. So let's actually look at the standard again. Left. OK, Tryon. Transform error. Our first. Down here. OK template class F constexpr auto transform error. FL ref version. OK, same multistep deal we static assert. Speaker OK, transform error stack assert invokable fun. Well, this is a little bit different with error ref. Because Gene needs to be removed, CVS invoke result of the decal type of error. OK, air ref. We we had high ref and Const hired for the L value ones up here, right? Yes. OK, good. We weren't dropping her off. OK so here stack assert, invocable fun with Arref expected TE form error. F requires that F is invocable with E OK, that's correct, no copy paste errors for 27. Yep, that's the right mandate. K and then use new tie as remove CVT, invoke result T fun air ref stack cert is invoke constructable. Fun error. Raff expected TE transform error if requires that the return type of F is constructible with the result of invoking F OK, that doesn't need to mention error again site 27. Umm, so that's all the mandates. Sarah bugging the standard here it says Gee is valid value type for expected, but then the static assert is checked unexpected argument for Utah. Yes, that was a a bug in the standard. I think Casey if you. Click on the the conversation, yeah. This one. Ah, excellent. Yeah, I figured out. I figured out an issue without cracking the common open first. Your cat. I am paying attention. OK, great. And we've already got an issue that's in voting status. Thank you. OK. It's it's so nice. The standard two include these little little gems to find. OK, so we are doing the right thing here. Even though the standard says the wrong thing, Utah's gotta be a valid, unexpected argument, OK? So we've already checked your invocable. You formed Utah invoke constructible. So that's. All this. Make G with invoke F on error. OK, because G is the folk resolve. OK, that looks good. OK, so then the actual implementation sets if we have a value, if his value is true, return expected TG which is Ty Utah from in place and value correct otherwise. On expected TG object. So Thai utai whose Hazel inverse false. So constructive Spector from vocal result tag unexpected. Umm. And then he'd be direct non list initialized with invoke forward FF. So switchboard, funk and error unexpected. OK great and then the usual move changes there OK. So construct. Um or I should check before I minimize that the mandates paragraph? 27 and 31 OK. So for the L version 2727. And spaces here try 727 and then 31313131. Perfect. OK, construct O. We expect to see concern Arav, concert rap Concert, RAF. But we still say value and unexpected. OK, that's good. And then the rough rough version, which now says move constructible here. Let's good here we have error, error, error, move value move unexpected Alstead qualified good. And then concert or counselor, Prof is cancer. Cancer, cancer. Stood move. Value should move unexpected. Great. And then the quality operators fix up these strengthens OK implementation of the constructor. Let's see are we getting close to the end of expected. I know we're getting close to the end of our time slot then we've got the void specialization, OK, which is gonna be of course pretty highly repetitive. I think we might wanna call it a wrap once we get to the end of the primary template and I'll review the rest offline. But like that was pretty much exactly my my reaction when I Umm. was doing the standard and all this stuff, and I was like, oh, no, I've got the void ones. Uh, it's like ohh, it's a whole extra sequel. OK, so I lost my Yeah. place. Uh, the constructor, OK. So nice comment explaining why we're doing this thing. These overloads force copy elision from the invoke call into value. OK. Ah, so we have several overloads here. One takes a function and Arg. One takes a funk by itself or in Transformers called on an expected void E. Ah. How do we do the specializations of expect? Isn't it an entirely different specialization? So so yes, it's an entirely different specialization, but it's when you're calling transform on an expected void E Ah. such that it then needs to construct our expected TE. But you need to call that invokable with no arguments, so the the TE primary template needs. OK. And that constructor, which takes no argument to pass to the invocable. Makes sense? OK, let's see. OK, see. Basically, exactly this is the same thing. OK, Casey was confused about the same thing. Maybe that means I need to change the comment? Hilarious. Yeah, nitpick space after coming here. OK. Umm OK, these. Yeah, we saw that template class, fun class UX. Constexpr constructor. Expected. And we take the tag here. The tag occurs first, which is most helpful for tag dispatch. Here is a necessary case for tag dispatch. Basically or tag. I guess that's not really dispatch, it's more like disambiguation. I'm because constructors don't have names. Fun rough of funk UX ref ref Arg. We are no except, but this is all internal, so no reason to come in is strengthened. We're not. We're not. Except if this is noexcept. Let's make a tie. This probably be a static cast. It invokes did Fortran function before. Do you XRG? Yeah, I think I think let's, let's phrase this as a static cast as well. Yeah. Smile for using. Static cast here. And in the below 2 reloads as well. Now OK. Yeah. And then construct value with student Vogue stood forward from funk stood 40X. RG has value such a true as an aside boy it would be nice if the standard Committee was able to add features that avoided the repetitiveness of this code. It's like that's just go and look through what library implementers are suffering through and help them write more elegant code which will help everyone. OK, rant over 4. That's one for no except auto. The. Yeah. There are reasons to be uncomfortable with it, but the alternative is so bad, and I was so happy when we got like expected or sorry explicit bool. So convenient. Yeah. OK, so this is the helper tag. From there funk I wonder. We could make this variadic, but making it variadic just to handle the zero or one case. Is not the biggest thing in the world. Umm, I guess that oh, and this allows you to bypass the invoke, There's also the case where. Yes. So the this, the standard does say to use invoke here, but yeah. I thought couldn't just call the function. Absolutely. Because if there's no arguments, yeah, because if. Avoid the invoke call. Yeah, they can't be a Member Pointer or a member function pointer, so. Yeah, it would need a class object or pointer thing. OK, so that's a nice. Metaprogramming throughput optimization. We're no except if this is no, except the construct the tie from directly calling the funk. Said has value true. So many parentheses looks like Lisp. Yeah. And then, funny wax, if we have an unexpected tag, all the tags function RG. And these are these are unambiguous because it's, um. Whenever I see heavy overload. I tried to make sure that there's no possibility for ambiguity. This is 3 args disambiguated on the first tag, two and four, so purely by errity, these can never conflict with each other, so that's good. And in the most dire case of tuple, we have these internal tags that help us fully disambiguate which one we need, and we have a very careful template. Any trick to avoid ever impulsively constructing those things that's not necessary here, I think. Yeah, I thought about like making a construct expected from Umm. invoke tag unexpected or something, but I thought I can just we've already gotten unexpected. I can just use that. Yeah, that does seem reasonable. Umm, no, except if noexcept construct the error, this one Static cast again get. could also be static cast. Also for error. Avoid. Uh, just a avoid a ton of comments here. Error. Student Vogue storefront from Funks did 40X RG. And then construct the unexpected from that has value set to false. OK, great. And then we're up to the void specialization. Wonderful. OK. And we are exactly at the end of our time slot. So I think I will pause here. Let's see. I'm thinking should I submit this review and then come back in cause a lot of the recommended changes are in effect the void one as well. Umm. I'm tempted to do that and then. Well. One thing is I've already made all of the changes which you've suggested, including in the Void specialization. Ah, nice. So fast. And then the test, which I'll come back and review. Yeah, OK. I think I'll submit my review now. I will look for your changes and then I will resume at the void specialization. I will add a comment. A here. This is purely a note to self. Actually, no, I don't need to add a comment, that's annoying. I will add it in the review itself. Great. Uh. Thanks, um. Note to self. I reviewed the product code up to the Boyds specialization and still need to review. The new. Test file OK. Cool. I just pushed all of those changes as well. Excellent. I'll come back and review the rest of it later today. And this is looking great and thank you for implementing this and we should hopefully be able to move this forward to is this an final review right now Casey Casey did approve, OK. So it is in final review. So once I sign off. And I the necessary changes are like small, I might go ahead and push them anyways if they don't need your expertise then we should be able to get this ready to merge and hopefully merge. Great. This week we just missed the deadline for getting changes into 17-6 Preview 2, although the date for that to actually releases in the future. We don't say exactly when, but the internal branch deadline for changes flowing is already passed so this is now slated to go into 17 seven. But it will be one of the first changes in 17-7. And. Let's see. That will bring us. This is over 5% of our remaining C + 23 features we're at. I guess I can open up this project here. Here we go. Yeah. We have rapidly diminishing set of C + 23 features to implement, although the committee is voting in more stuff this week. Hopefully not actual features, just like patch papers. So the total number of papers might increase, but hopefully no new massive things will come in. Umm, so thanks. UMI think that does it for this video code for you and we'll see you next week. Great. Thanks so much.